
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000180 <Reset_Handler>:
 8000180:	b672      	cpsid	i
 8000182:	4825      	ldr	r0, [pc, #148]	; (8000218 <endfiniloop+0x4>)
 8000184:	f380 8809 	msr	PSP, r0
 8000188:	4824      	ldr	r0, [pc, #144]	; (800021c <endfiniloop+0x8>)
 800018a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800018e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000192:	6008      	str	r0, [r1, #0]
 8000194:	2002      	movs	r0, #2
 8000196:	f380 8814 	msr	CONTROL, r0
 800019a:	f3bf 8f6f 	isb	sy
 800019e:	f004 fd37 	bl	8004c10 <__core_init>
 80001a2:	f006 fe15 	bl	8006dd0 <__early_init>
 80001a6:	481e      	ldr	r0, [pc, #120]	; (8000220 <endfiniloop+0xc>)
 80001a8:	491e      	ldr	r1, [pc, #120]	; (8000224 <endfiniloop+0x10>)
 80001aa:	4a1f      	ldr	r2, [pc, #124]	; (8000228 <endfiniloop+0x14>)

080001ac <msloop>:
 80001ac:	4291      	cmp	r1, r2
 80001ae:	bf3c      	itt	cc
 80001b0:	f841 0b04 	strcc.w	r0, [r1], #4
 80001b4:	e7fa      	bcc.n	80001ac <msloop>
 80001b6:	491d      	ldr	r1, [pc, #116]	; (800022c <endfiniloop+0x18>)
 80001b8:	4a17      	ldr	r2, [pc, #92]	; (8000218 <endfiniloop+0x4>)

080001ba <psloop>:
 80001ba:	4291      	cmp	r1, r2
 80001bc:	bf3c      	itt	cc
 80001be:	f841 0b04 	strcc.w	r0, [r1], #4
 80001c2:	e7fa      	bcc.n	80001ba <psloop>
 80001c4:	491a      	ldr	r1, [pc, #104]	; (8000230 <endfiniloop+0x1c>)
 80001c6:	4a1b      	ldr	r2, [pc, #108]	; (8000234 <endfiniloop+0x20>)
 80001c8:	4b1b      	ldr	r3, [pc, #108]	; (8000238 <endfiniloop+0x24>)

080001ca <dloop>:
 80001ca:	429a      	cmp	r2, r3
 80001cc:	bf3e      	ittt	cc
 80001ce:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001d2:	f842 0b04 	strcc.w	r0, [r2], #4
 80001d6:	e7f8      	bcc.n	80001ca <dloop>
 80001d8:	2000      	movs	r0, #0
 80001da:	4918      	ldr	r1, [pc, #96]	; (800023c <endfiniloop+0x28>)
 80001dc:	4a18      	ldr	r2, [pc, #96]	; (8000240 <endfiniloop+0x2c>)

080001de <bloop>:
 80001de:	4291      	cmp	r1, r2
 80001e0:	bf3c      	itt	cc
 80001e2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e6:	e7fa      	bcc.n	80001de <bloop>
 80001e8:	f006 fe9a 	bl	8006f20 <__init_ram_areas>
 80001ec:	f004 fd08 	bl	8004c00 <__late_init>
 80001f0:	4c14      	ldr	r4, [pc, #80]	; (8000244 <endfiniloop+0x30>)
 80001f2:	4d15      	ldr	r5, [pc, #84]	; (8000248 <endfiniloop+0x34>)

080001f4 <initloop>:
 80001f4:	42ac      	cmp	r4, r5
 80001f6:	da03      	bge.n	8000200 <endinitloop>
 80001f8:	f854 1b04 	ldr.w	r1, [r4], #4
 80001fc:	4788      	blx	r1
 80001fe:	e7f9      	b.n	80001f4 <initloop>

08000200 <endinitloop>:
 8000200:	f006 fa76 	bl	80066f0 <main>
 8000204:	4c11      	ldr	r4, [pc, #68]	; (800024c <endfiniloop+0x38>)
 8000206:	4d12      	ldr	r5, [pc, #72]	; (8000250 <endfiniloop+0x3c>)

08000208 <finiloop>:
 8000208:	42ac      	cmp	r4, r5
 800020a:	da03      	bge.n	8000214 <endfiniloop>
 800020c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000210:	4788      	blx	r1
 8000212:	e7f9      	b.n	8000208 <finiloop>

08000214 <endfiniloop>:
 8000214:	f006 beb4 	b.w	8006f80 <__default_exit>
 8000218:	20000800 	.word	0x20000800
 800021c:	08000000 	.word	0x08000000
 8000220:	55555555 	.word	0x55555555
 8000224:	20000000 	.word	0x20000000
 8000228:	20000400 	.word	0x20000400
 800022c:	20000400 	.word	0x20000400
 8000230:	080088bc 	.word	0x080088bc
 8000234:	20000800 	.word	0x20000800
 8000238:	200008b4 	.word	0x200008b4
 800023c:	200008b8 	.word	0x200008b8
 8000240:	200014a8 	.word	0x200014a8
 8000244:	08000180 	.word	0x08000180
 8000248:	08000180 	.word	0x08000180
 800024c:	08000180 	.word	0x08000180
 8000250:	08000180 	.word	0x08000180

08000254 <_port_switch>:
 8000254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000258:	f8c1 d00c 	str.w	sp, [r1, #12]
 800025c:	68c3      	ldr	r3, [r0, #12]
 800025e:	469d      	mov	sp, r3
 8000260:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000264 <_port_thread_start>:
 8000264:	2300      	movs	r3, #0
 8000266:	f383 8811 	msr	BASEPRI, r3
 800026a:	4628      	mov	r0, r5
 800026c:	47a0      	blx	r4
 800026e:	2000      	movs	r0, #0
 8000270:	f006 fdfe 	bl	8006e70 <chThdExit>

08000274 <_port_switch_from_isr>:
 8000274:	f006 fe34 	bl	8006ee0 <chSchDoReschedule>

08000278 <_port_exit_from_isr>:
 8000278:	df00      	svc	0
 800027a:	e7fe      	b.n	800027a <_port_exit_from_isr+0x2>
 800027c:	0000      	movs	r0, r0
	...

08000280 <tmo.10681>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 8000280:	4770      	bx	lr
 8000282:	bf00      	nop
 8000284:	f3af 8000 	nop.w
 8000288:	f3af 8000 	nop.w
 800028c:	f3af 8000 	nop.w

08000290 <test_012_002_setup.10521>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8000290:	f640 1340 	movw	r3, #2368	; 0x940
 8000294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000298:	2200      	movs	r2, #0
  mp->object_size = size;
 800029a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800029e:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80002a0:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 80002a2:	609a      	str	r2, [r3, #8]
 80002a4:	4770      	bx	lr
 80002a6:	bf00      	nop
 80002a8:	f3af 8000 	nop.w
 80002ac:	f3af 8000 	nop.w

080002b0 <null_provider.10247>:

  (void)size;
  (void)align;

  return NULL;
}
 80002b0:	2000      	movs	r0, #0
 80002b2:	4770      	bx	lr
 80002b4:	f3af 8000 	nop.w
 80002b8:	f3af 8000 	nop.w
 80002bc:	f3af 8000 	nop.w

080002c0 <test_004_001_setup.9048>:
 *   the state of the reference are tested.
 * .
 */

static void test_004_001_setup(void) {
  tr1 = NULL;
 80002c0:	f640 73e8 	movw	r3, #4072	; 0xfe8
 80002c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80002c8:	2200      	movs	r2, #0
 80002ca:	601a      	str	r2, [r3, #0]
 80002cc:	4770      	bx	lr
 80002ce:	bf00      	nop

080002d0 <test_002_004_execute.8644>:

static void test_002_004_execute(void) {

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 80002d0:	f241 3330 	movw	r3, #4912	; 0x1330
 80002d4:	2201      	movs	r2, #1
 80002d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80002da:	601a      	str	r2, [r3, #0]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80002dc:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80002e0:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 80002e2:	b292      	uxth	r2, r2
 80002e4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 80002e6:	b29b      	uxth	r3, r3
 80002e8:	429a      	cmp	r2, r3
 80002ea:	d0fb      	beq.n	80002e4 <test_002_004_execute.8644+0x14>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 80002ec:	4770      	bx	lr
 80002ee:	bf00      	nop

080002f0 <test_002_003_execute.8642>:

static void test_002_003_execute(void) {

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 80002f0:	f241 3330 	movw	r3, #4912	; 0x1330
 80002f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80002f8:	2201      	movs	r2, #1
 80002fa:	601a      	str	r2, [r3, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80002fc:	2320      	movs	r3, #32
 80002fe:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000302:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000304:	b672      	cpsid	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000306:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800030a:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800030c:	2300      	movs	r3, #0
 800030e:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000312:	b662      	cpsie	i
 8000314:	4770      	bx	lr
 8000316:	bf00      	nop
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w

08000320 <notify1.8219>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000320:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000324:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8000328:	68da      	ldr	r2, [r3, #12]
 800032a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800032e:	60da      	str	r2, [r3, #12]
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000340:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000344:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000346:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800034a:	2300      	movs	r3, #0
 800034c:	f383 8811 	msr	BASEPRI, r3
 8000350:	4770      	bx	lr
 8000352:	bf00      	nop
 8000354:	f3af 8000 	nop.w
 8000358:	f3af 8000 	nop.w
 800035c:	f3af 8000 	nop.w

08000360 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8000360:	b430      	push	{r4, r5}
 8000362:	2320      	movs	r3, #32
 8000364:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000368:	f241 030c 	movw	r3, #4108	; 0x100c
 800036c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000370:	681d      	ldr	r5, [r3, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000372:	1e4c      	subs	r4, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8000374:	442a      	add	r2, r5
 8000376:	4422      	add	r2, r4
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000378:	4249      	negs	r1, r1
 800037a:	4404      	add	r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800037c:	ea02 0001 	and.w	r0, r2, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8000380:	4021      	ands	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8000382:	685a      	ldr	r2, [r3, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 8000384:	4401      	add	r1, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8000386:	4291      	cmp	r1, r2
 8000388:	d807      	bhi.n	800039a <chCoreAllocAlignedWithOffset+0x3a>
 800038a:	428d      	cmp	r5, r1
 800038c:	d805      	bhi.n	800039a <chCoreAllocAlignedWithOffset+0x3a>
    return NULL;
  }

  ch_memcore.nextmem = next;
 800038e:	6019      	str	r1, [r3, #0]
 8000390:	2300      	movs	r3, #0
 8000392:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000396:	bc30      	pop	{r4, r5}
 8000398:	4770      	bx	lr
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 800039a:	2000      	movs	r0, #0
 800039c:	2300      	movs	r3, #0
 800039e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 80003a2:	bc30      	pop	{r4, r5}
 80003a4:	4770      	bx	lr
 80003a6:	bf00      	nop
 80003a8:	f3af 8000 	nop.w
 80003ac:	f3af 8000 	nop.w

080003b0 <wakeup.4670>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80003b0:	b410      	push	{r4}
 80003b2:	2320      	movs	r3, #32
 80003b4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 80003b8:	f890 3020 	ldrb.w	r3, [r0, #32]
 80003bc:	2b07      	cmp	r3, #7
 80003be:	d80e      	bhi.n	80003de <wakeup.4670+0x2e>
 80003c0:	e8df f003 	tbb	[pc, r3]
 80003c4:	270d0d2b 	.word	0x270d0d2b
 80003c8:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80003cc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80003ce:	689a      	ldr	r2, [r3, #8]
 80003d0:	3201      	adds	r2, #1
 80003d2:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80003d4:	e890 000c 	ldmia.w	r0, {r2, r3}
 80003d8:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80003da:	6802      	ldr	r2, [r0, #0]
 80003dc:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80003de:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80003e2:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 80003e4:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80003e8:	6881      	ldr	r1, [r0, #8]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80003ea:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80003ec:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80003f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
  do {
    cp = cp->queue.next;
 80003f4:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80003f6:	689a      	ldr	r2, [r3, #8]
 80003f8:	428a      	cmp	r2, r1
 80003fa:	d2fb      	bcs.n	80003f4 <wakeup.4670+0x44>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80003fc:	685a      	ldr	r2, [r3, #4]
 80003fe:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000400:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000402:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000404:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000406:	6058      	str	r0, [r3, #4]
 8000408:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 800040c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000410:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8000412:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000414:	2200      	movs	r2, #0
 8000416:	601a      	str	r2, [r3, #0]
 8000418:	e7e1      	b.n	80003de <wakeup.4670+0x2e>
 800041a:	2300      	movs	r3, #0
 800041c:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000420:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000424:	4770      	bx	lr
 8000426:	bf00      	nop
 8000428:	f3af 8000 	nop.w
 800042c:	f3af 8000 	nop.w

08000430 <chSysIntegrityCheckI.4415>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000430:	07c2      	lsls	r2, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000432:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000434:	d513      	bpl.n	800045e <chSysIntegrityCheckI.4415+0x2e>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
 8000436:	f241 23c0 	movw	r3, #4800	; 0x12c0
 800043a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800043e:	6819      	ldr	r1, [r3, #0]
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 8000440:	2200      	movs	r2, #0
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000442:	4299      	cmp	r1, r3
 8000444:	d003      	beq.n	800044e <chSysIntegrityCheckI.4415+0x1e>
      n++;
      tp = tp->queue.next;
 8000446:	6809      	ldr	r1, [r1, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n++;
 8000448:	3201      	adds	r2, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 800044a:	4299      	cmp	r1, r3
 800044c:	d1fb      	bne.n	8000446 <chSysIntegrityCheckI.4415+0x16>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800044e:	6859      	ldr	r1, [r3, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000450:	4299      	cmp	r1, r3
 8000452:	d003      	beq.n	800045c <chSysIntegrityCheckI.4415+0x2c>
      n--;
      tp = tp->queue.prev;
 8000454:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n--;
 8000456:	3a01      	subs	r2, #1
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000458:	4299      	cmp	r1, r3
 800045a:	d1fb      	bne.n	8000454 <chSysIntegrityCheckI.4415+0x24>
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800045c:	bb9a      	cbnz	r2, 80004c6 <chSysIntegrityCheckI.4415+0x96>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800045e:	0783      	lsls	r3, r0, #30
 8000460:	d515      	bpl.n	800048e <chSysIntegrityCheckI.4415+0x5e>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8000462:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000466:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800046a:	461c      	mov	r4, r3
 800046c:	f854 1f1c 	ldr.w	r1, [r4, #28]!
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8000470:	2200      	movs	r2, #0
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000472:	42a1      	cmp	r1, r4
 8000474:	d003      	beq.n	800047e <chSysIntegrityCheckI.4415+0x4e>
      n++;
      vtp = vtp->next;
 8000476:	6809      	ldr	r1, [r1, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 8000478:	3201      	adds	r2, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800047a:	42a1      	cmp	r1, r4
 800047c:	d1fb      	bne.n	8000476 <chSysIntegrityCheckI.4415+0x46>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 800047e:	6a1b      	ldr	r3, [r3, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000480:	42a3      	cmp	r3, r4
 8000482:	d003      	beq.n	800048c <chSysIntegrityCheckI.4415+0x5c>
      n--;
      vtp = vtp->prev;
 8000484:	685b      	ldr	r3, [r3, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 8000486:	3a01      	subs	r2, #1
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8000488:	42a3      	cmp	r3, r4
 800048a:	d1fb      	bne.n	8000484 <chSysIntegrityCheckI.4415+0x54>
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800048c:	b9da      	cbnz	r2, 80004c6 <chSysIntegrityCheckI.4415+0x96>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800048e:	f010 0004 	ands.w	r0, r0, #4
 8000492:	d015      	beq.n	80004c0 <chSysIntegrityCheckI.4415+0x90>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
 8000494:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800049c:	691a      	ldr	r2, [r3, #16]
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800049e:	2000      	movs	r0, #0
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 80004a0:	429a      	cmp	r2, r3
 80004a2:	d003      	beq.n	80004ac <chSysIntegrityCheckI.4415+0x7c>
      n++;
      tp = tp->newer;
 80004a4:	6912      	ldr	r2, [r2, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 80004a6:	3001      	adds	r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 80004a8:	429a      	cmp	r2, r3
 80004aa:	d1fb      	bne.n	80004a4 <chSysIntegrityCheckI.4415+0x74>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 80004ac:	695a      	ldr	r2, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80004ae:	429a      	cmp	r2, r3
 80004b0:	d003      	beq.n	80004ba <chSysIntegrityCheckI.4415+0x8a>
      n--;
      tp = tp->older;
 80004b2:	6952      	ldr	r2, [r2, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 80004b4:	3801      	subs	r0, #1
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 80004b6:	429a      	cmp	r2, r3
 80004b8:	d1fb      	bne.n	80004b2 <chSysIntegrityCheckI.4415+0x82>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80004ba:	3000      	adds	r0, #0
 80004bc:	bf18      	it	ne
 80004be:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80004c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80004c4:	4770      	bx	lr
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80004c6:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80004c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80004cc:	4770      	bx	lr
 80004ce:	bf00      	nop

080004d0 <_idle_thread.4314>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80004d0:	e7fe      	b.n	80004d0 <_idle_thread.4314>
 80004d2:	bf00      	nop
 80004d4:	f3af 8000 	nop.w
 80004d8:	f3af 8000 	nop.w
 80004dc:	f3af 8000 	nop.w

080004e0 <chThdYield.4374>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 80004e0:	b570      	push	{r4, r5, r6, lr}
 80004e2:	2320      	movs	r3, #32
 80004e4:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80004e8:	f241 22c0 	movw	r2, #4800	; 0x12c0
 80004ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80004f0:	6810      	ldr	r0, [r2, #0]
 80004f2:	6995      	ldr	r5, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80004f4:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80004f6:	68ac      	ldr	r4, [r5, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80004f8:	42a3      	cmp	r3, r4
 80004fa:	d203      	bcs.n	8000504 <chThdYield.4374+0x24>
 80004fc:	2300      	movs	r3, #0
 80004fe:	f383 8811 	msr	BASEPRI, r3
 8000502:	bd70      	pop	{r4, r5, r6, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000504:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000506:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000508:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800050a:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800050c:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800050e:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000512:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000514:	f885 1020 	strb.w	r1, [r5, #32]
 8000518:	e000      	b.n	800051c <chThdYield.4374+0x3c>
 800051a:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 800051c:	689a      	ldr	r2, [r3, #8]
 800051e:	4294      	cmp	r4, r2
 8000520:	d9fb      	bls.n	800051a <chThdYield.4374+0x3a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000522:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000524:	4629      	mov	r1, r5
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000526:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8000528:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 800052a:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 800052c:	605d      	str	r5, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800052e:	f7ff fe91 	bl	8000254 <_port_switch>
 8000532:	2300      	movs	r3, #0
 8000534:	f383 8811 	msr	BASEPRI, r3
 8000538:	bd70      	pop	{r4, r5, r6, pc}
 800053a:	bf00      	nop
 800053c:	f3af 8000 	nop.w

08000540 <bmk_thread8.10684>:
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
}
#endif

static THD_FUNCTION(bmk_thread8, p) {
 8000540:	b538      	push	{r3, r4, r5, lr}
 8000542:	f241 25c0 	movw	r5, #4800	; 0x12c0
 8000546:	4604      	mov	r4, r0
 8000548:	f2c2 0500 	movt	r5, #8192	; 0x2000

  do {
    chThdYield();
 800054c:	f7ff ffc8 	bl	80004e0 <chThdYield.4374>
    chThdYield();
 8000550:	f7ff ffc6 	bl	80004e0 <chThdYield.4374>
    chThdYield();
 8000554:	f7ff ffc4 	bl	80004e0 <chThdYield.4374>
    chThdYield();
 8000558:	f7ff ffc2 	bl	80004e0 <chThdYield.4374>
    (*(uint32_t *)p) += 4;
 800055c:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 800055e:	69aa      	ldr	r2, [r5, #24]
 8000560:	3304      	adds	r3, #4
 8000562:	6023      	str	r3, [r4, #0]
 8000564:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8000568:	0759      	lsls	r1, r3, #29
 800056a:	d5ef      	bpl.n	800054c <bmk_thread8.10684+0xc>
}
 800056c:	bd38      	pop	{r3, r4, r5, pc}
 800056e:	bf00      	nop

08000570 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8000570:	4b0b      	ldr	r3, [pc, #44]	; (80005a0 <test_terminate_threads+0x30>)
 8000572:	b430      	push	{r4, r5}
 8000574:	f103 0014 	add.w	r0, r3, #20
 8000578:	2520      	movs	r5, #32
 800057a:	2400      	movs	r4, #0
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 800057c:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8000580:	b14a      	cbz	r2, 8000596 <test_terminate_threads+0x26>
 8000582:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8000586:	f892 1021 	ldrb.w	r1, [r2, #33]	; 0x21
 800058a:	f041 0104 	orr.w	r1, r1, #4
 800058e:	f882 1021 	strb.w	r1, [r2, #33]	; 0x21
 8000592:	f384 8811 	msr	BASEPRI, r4
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8000596:	4283      	cmp	r3, r0
 8000598:	d1f0      	bne.n	800057c <test_terminate_threads+0xc>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800059a:	bc30      	pop	{r4, r5}
 800059c:	4770      	bx	lr
 800059e:	bf00      	nop
 80005a0:	20000fd0 	.word	0x20000fd0
 80005a4:	f3af 8000 	nop.w
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <test_emit_token>:
 80005b0:	2320      	movs	r3, #32
 80005b2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 80005b6:	f241 3358 	movw	r3, #4952	; 0x1358
 80005ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005be:	681a      	ldr	r2, [r3, #0]
 80005c0:	4904      	ldr	r1, [pc, #16]	; (80005d4 <test_emit_token+0x24>)
 80005c2:	428a      	cmp	r2, r1
    *test_tokp++ = token;
 80005c4:	bf3e      	ittt	cc
 80005c6:	1c51      	addcc	r1, r2, #1
 80005c8:	6019      	strcc	r1, [r3, #0]
 80005ca:	7010      	strbcc	r0, [r2, #0]
 80005cc:	2300      	movs	r3, #0
 80005ce:	f383 8811 	msr	BASEPRI, r3
 80005d2:	4770      	bx	lr
 80005d4:	2000100c 	.word	0x2000100c
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <dyn_thread1.10516>:
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {

  test_emit_token(*(char *)p);
 80005e0:	7800      	ldrb	r0, [r0, #0]
 80005e2:	f7ff bfe5 	b.w	80005b0 <test_emit_token>
 80005e6:	bf00      	nop
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <h1.9871>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80005f0:	2041      	movs	r0, #65	; 0x41
 80005f2:	f7ff bfdd 	b.w	80005b0 <test_emit_token>
 80005f6:	bf00      	nop
 80005f8:	f3af 8000 	nop.w
 80005fc:	f3af 8000 	nop.w

08000600 <h2.9868>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8000600:	2042      	movs	r0, #66	; 0x42
 8000602:	f7ff bfd5 	b.w	80005b0 <test_emit_token>
 8000606:	bf00      	nop
 8000608:	f3af 8000 	nop.w
 800060c:	f3af 8000 	nop.w

08000610 <h3.9865>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8000610:	2043      	movs	r0, #67	; 0x43
 8000612:	f7ff bfcd 	b.w	80005b0 <test_emit_token>
 8000616:	bf00      	nop
 8000618:	f3af 8000 	nop.w
 800061c:	f3af 8000 	nop.w

08000620 <thread.8784>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8000620:	7800      	ldrb	r0, [r0, #0]
 8000622:	f7ff bfc5 	b.w	80005b0 <test_emit_token>
 8000626:	bf00      	nop
 8000628:	f3af 8000 	nop.w
 800062c:	f3af 8000 	nop.w

08000630 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8000630:	b538      	push	{r3, r4, r5, lr}
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000632:	7801      	ldrb	r1, [r0, #0]
 8000634:	f241 3534 	movw	r5, #4916	; 0x1334
 8000638:	b1a1      	cbz	r1, 8000664 <test_println+0x34>
 800063a:	4604      	mov	r4, r0
 800063c:	f2c2 0500 	movt	r5, #8192	; 0x2000
    streamPut(test_chp, *msgp++);
 8000640:	6828      	ldr	r0, [r5, #0]
 8000642:	6803      	ldr	r3, [r0, #0]
 8000644:	689b      	ldr	r3, [r3, #8]
 8000646:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000648:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800064c:	2900      	cmp	r1, #0
 800064e:	d1f7      	bne.n	8000640 <test_println+0x10>
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8000650:	6828      	ldr	r0, [r5, #0]
 8000652:	f646 7190 	movw	r1, #28560	; 0x6f90
 8000656:	6803      	ldr	r3, [r0, #0]
 8000658:	f6c0 0100 	movt	r1, #2048	; 0x800
 800065c:	681b      	ldr	r3, [r3, #0]
 800065e:	2202      	movs	r2, #2
 8000660:	4798      	blx	r3
 8000662:	bd38      	pop	{r3, r4, r5, pc}
 8000664:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8000668:	e7f2      	b.n	8000650 <test_println+0x20>
 800066a:	bf00      	nop
 800066c:	f3af 8000 	nop.w

08000670 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8000670:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8000672:	7801      	ldrb	r1, [r0, #0]
 8000674:	b161      	cbz	r1, 8000690 <test_print+0x20>
 8000676:	f241 3534 	movw	r5, #4916	; 0x1334
 800067a:	4604      	mov	r4, r0
 800067c:	f2c2 0500 	movt	r5, #8192	; 0x2000
    streamPut(test_chp, *msgp++);
 8000680:	6828      	ldr	r0, [r5, #0]
 8000682:	6803      	ldr	r3, [r0, #0]
 8000684:	689b      	ldr	r3, [r3, #8]
 8000686:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000688:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 800068c:	2900      	cmp	r1, #0
 800068e:	d1f7      	bne.n	8000680 <test_print+0x10>
 8000690:	bd38      	pop	{r3, r4, r5, pc}
 8000692:	bf00      	nop
 8000694:	f3af 8000 	nop.w
 8000698:	f3af 8000 	nop.w
 800069c:	f3af 8000 	nop.w

080006a0 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(msg);
  return false;
}

bool _test_assert_sequence(char *expected, const char *msg) {
 80006a0:	b4f0      	push	{r4, r5, r6, r7}
 80006a2:	f241 3658 	movw	r6, #4952	; 0x1358
  char *cp = test_tokens_buffer;
 80006a6:	f640 77fc 	movw	r7, #4092	; 0xffc
 80006aa:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80006ae:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80006b2:	6835      	ldr	r5, [r6, #0]
 80006b4:	463b      	mov	r3, r7
 80006b6:	e005      	b.n	80006c4 <_test_assert_sequence+0x24>

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
 80006b8:	f813 4b01 	ldrb.w	r4, [r3], #1
 80006bc:	f810 2b01 	ldrb.w	r2, [r0], #1
 80006c0:	4294      	cmp	r4, r2
 80006c2:	d106      	bne.n	80006d2 <_test_assert_sequence+0x32>
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 80006c4:	42ab      	cmp	r3, r5
 80006c6:	d3f7      	bcc.n	80006b8 <_test_assert_sequence+0x18>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 80006c8:	7800      	ldrb	r0, [r0, #0]
 80006ca:	b910      	cbnz	r0, 80006d2 <_test_assert_sequence+0x32>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 80006cc:	6037      	str	r7, [r6, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 80006ce:	bcf0      	pop	{r4, r5, r6, r7}
 80006d0:	4770      	bx	lr
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80006d2:	f241 0414 	movw	r4, #4116	; 0x1014
  test_global_fail     = true;
 80006d6:	f241 021c 	movw	r2, #4124	; 0x101c
  test_failure_message = msg;
 80006da:	f241 0318 	movw	r3, #4120	; 0x1018
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80006de:	2001      	movs	r0, #1
 80006e0:	f2c2 0400 	movt	r4, #8192	; 0x2000
  test_global_fail     = true;
 80006e4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  test_failure_message = msg;
 80006e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80006ec:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 80006ee:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 80006f0:	6019      	str	r1, [r3, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 80006f2:	bcf0      	pop	{r4, r5, r6, r7}
 80006f4:	4770      	bx	lr
 80006f6:	bf00      	nop
 80006f8:	f3af 8000 	nop.w
 80006fc:	f3af 8000 	nop.w

08000700 <_test_assert>:
  test_global_fail     = true;
  test_failure_message = msg;
  return true;
}

bool _test_assert(bool condition, const char *msg) {
 8000700:	b410      	push	{r4}

  if (!condition)
 8000702:	b990      	cbnz	r0, 800072a <_test_assert+0x2a>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8000704:	f241 0414 	movw	r4, #4116	; 0x1014
  test_global_fail     = true;
 8000708:	f241 021c 	movw	r2, #4124	; 0x101c
  test_failure_message = msg;
 800070c:	f241 0318 	movw	r3, #4120	; 0x1018
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8000710:	2001      	movs	r0, #1
 8000712:	f2c2 0400 	movt	r4, #8192	; 0x2000
  test_global_fail     = true;
 8000716:	f2c2 0200 	movt	r2, #8192	; 0x2000
  test_failure_message = msg;
 800071a:	f2c2 0300 	movt	r3, #8192	; 0x2000
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 800071e:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8000720:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8000722:	6019      	str	r1, [r3, #0]
bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
}
 8000724:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000728:	4770      	bx	lr

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 800072a:	2000      	movs	r0, #0
}
 800072c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000730:	4770      	bx	lr
 8000732:	bf00      	nop
 8000734:	f3af 8000 	nop.w
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <test_002_001_execute.8664>:
 * - [2.1.3] Testing Registry List integrity.
 * - [2.1.4] Testing Port-defined integrity.
 * .
 */

static void test_002_001_execute(void) {
 8000740:	b510      	push	{r4, lr}
  bool result;

  /* [2.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 8000742:	f241 3430 	movw	r4, #4912	; 0x1330
 8000746:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800074a:	2301      	movs	r3, #1
 800074c:	6023      	str	r3, [r4, #0]
 800074e:	2320      	movs	r3, #32
 8000750:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8000754:	2001      	movs	r0, #1
 8000756:	f7ff fe6b 	bl	8000430 <chSysIntegrityCheckI.4415>
 800075a:	2300      	movs	r3, #0
 800075c:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
 8000760:	f646 7194 	movw	r1, #28564	; 0x6f94
 8000764:	f080 0001 	eor.w	r0, r0, #1
 8000768:	b2c0      	uxtb	r0, r0
 800076a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800076e:	f7ff ffc7 	bl	8000700 <_test_assert>
 8000772:	b100      	cbz	r0, 8000776 <test_002_001_execute.8664+0x36>
 8000774:	bd10      	pop	{r4, pc}
  }

  /* [2.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8000776:	2302      	movs	r3, #2
 8000778:	6023      	str	r3, [r4, #0]
 800077a:	2320      	movs	r3, #32
 800077c:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8000780:	2002      	movs	r0, #2
 8000782:	f7ff fe55 	bl	8000430 <chSysIntegrityCheckI.4415>
 8000786:	2300      	movs	r3, #0
 8000788:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "virtual timers list check failed");
 800078c:	f646 71ac 	movw	r1, #28588	; 0x6fac
 8000790:	f080 0001 	eor.w	r0, r0, #1
 8000794:	b2c0      	uxtb	r0, r0
 8000796:	f6c0 0100 	movt	r1, #2048	; 0x800
 800079a:	f7ff ffb1 	bl	8000700 <_test_assert>
 800079e:	2800      	cmp	r0, #0
 80007a0:	d1e8      	bne.n	8000774 <test_002_001_execute.8664+0x34>
  }

  /* [2.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 80007a2:	2303      	movs	r3, #3
 80007a4:	6023      	str	r3, [r4, #0]
 80007a6:	2320      	movs	r3, #32
 80007a8:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80007ac:	2004      	movs	r0, #4
 80007ae:	f7ff fe3f 	bl	8000430 <chSysIntegrityCheckI.4415>
 80007b2:	2300      	movs	r3, #0
 80007b4:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "registry list check failed");
 80007b8:	f646 71d0 	movw	r1, #28624	; 0x6fd0
 80007bc:	f080 0001 	eor.w	r0, r0, #1
 80007c0:	b2c0      	uxtb	r0, r0
 80007c2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80007c6:	f7ff ff9b 	bl	8000700 <_test_assert>
 80007ca:	2800      	cmp	r0, #0
 80007cc:	d1d2      	bne.n	8000774 <test_002_001_execute.8664+0x34>
  }

  /* [2.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 80007ce:	2304      	movs	r3, #4
 80007d0:	6023      	str	r3, [r4, #0]
 80007d2:	2320      	movs	r3, #32
 80007d4:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80007d8:	2008      	movs	r0, #8
 80007da:	f7ff fe29 	bl	8000430 <chSysIntegrityCheckI.4415>
 80007de:	2300      	movs	r3, #0
 80007e0:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 80007e4:	f646 71ec 	movw	r1, #28652	; 0x6fec
 80007e8:	f080 0001 	eor.w	r0, r0, #1
 80007ec:	b2c0      	uxtb	r0, r0
 80007ee:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 80007f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_set_step(4);
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 80007f6:	f7ff bf83 	b.w	8000700 <_test_assert>
 80007fa:	bf00      	nop
 80007fc:	f3af 8000 	nop.w

08000800 <test_printn.part.0.8336>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8000800:	b508      	push	{r3, lr}
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
 8000802:	f241 3334 	movw	r3, #4916	; 0x1334
 8000806:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800080a:	6818      	ldr	r0, [r3, #0]
 800080c:	2130      	movs	r1, #48	; 0x30
 800080e:	6803      	ldr	r3, [r0, #0]
 8000810:	689b      	ldr	r3, [r3, #8]
 8000812:	4798      	blx	r3
 8000814:	bd08      	pop	{r3, pc}
 8000816:	bf00      	nop
 8000818:	f3af 8000 	nop.w
 800081c:	f3af 8000 	nop.w

08000820 <test_printn>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8000820:	b570      	push	{r4, r5, r6, lr}
 8000822:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8000824:	b348      	cbz	r0, 800087a <test_printn+0x5a>
 8000826:	f10d 0501 	add.w	r5, sp, #1
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 800082a:	f64c 46cd 	movw	r6, #52429	; 0xcccd
 800082e:	462b      	mov	r3, r5
 8000830:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
 8000834:	fba6 1200 	umull	r1, r2, r6, r0
 8000838:	08d2      	lsrs	r2, r2, #3
 800083a:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800083e:	eba0 0141 	sub.w	r1, r0, r1, lsl #1
 8000842:	3130      	adds	r1, #48	; 0x30
 8000844:	b2c9      	uxtb	r1, r1
 8000846:	f803 1c01 	strb.w	r1, [r3, #-1]
 800084a:	461c      	mov	r4, r3

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 800084c:	4610      	mov	r0, r2
 800084e:	3301      	adds	r3, #1
 8000850:	2a00      	cmp	r2, #0
 8000852:	d1ef      	bne.n	8000834 <test_printn+0x14>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000854:	466b      	mov	r3, sp
 8000856:	429c      	cmp	r4, r3
 8000858:	d90d      	bls.n	8000876 <test_printn+0x56>
 800085a:	f241 3634 	movw	r6, #4916	; 0x1334
 800085e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8000862:	e002      	b.n	800086a <test_printn+0x4a>
 8000864:	f814 1c02 	ldrb.w	r1, [r4, #-2]
 8000868:	3c01      	subs	r4, #1
      streamPut(test_chp, *--p);
 800086a:	6830      	ldr	r0, [r6, #0]
 800086c:	6803      	ldr	r3, [r0, #0]
 800086e:	689b      	ldr	r3, [r3, #8]
 8000870:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000872:	42ac      	cmp	r4, r5
 8000874:	d1f6      	bne.n	8000864 <test_printn+0x44>
      streamPut(test_chp, *--p);
  }
}
 8000876:	b004      	add	sp, #16
 8000878:	bd70      	pop	{r4, r5, r6, pc}
 800087a:	b004      	add	sp, #16
 800087c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8000880:	f7ff bfbe 	b.w	8000800 <test_printn.part.0.8336>
 8000884:	f3af 8000 	nop.w
 8000888:	f3af 8000 	nop.w
 800088c:	f3af 8000 	nop.w

08000890 <test_013_012_execute.10699>:
 * - [13.12.8] The size of an event listener is printed.
 * - [13.12.9] The size of a mailbox is printed.
 * .
 */

static void test_013_012_execute(void) {
 8000890:	b570      	push	{r4, r5, r6, lr}

  /* [13.12.1] The size of the system area is printed.*/
  test_set_step(1);
  {
    test_print("--- System: ");
 8000892:	f247 0004 	movw	r0, #28676	; 0x7004
 */

static void test_013_012_execute(void) {

  /* [13.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8000896:	f241 3530 	movw	r5, #4912	; 0x1330
 800089a:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800089e:	2301      	movs	r3, #1
  {
    test_print("--- System: ");
 80008a0:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 80008a4:	f247 0414 	movw	r4, #28692	; 0x7014
 80008a8:	f6c0 0400 	movt	r4, #2048	; 0x800
 */

static void test_013_012_execute(void) {

  /* [13.12.1] The size of the system area is printed.*/
  test_set_step(1);
 80008ac:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 80008ae:	f7ff fedf 	bl	8000670 <test_print>
    test_printn(sizeof(ch_system_t));
 80008b2:	2070      	movs	r0, #112	; 0x70
 80008b4:	f7ff ffb4 	bl	8000820 <test_printn>
    test_println(" bytes");
 80008b8:	4620      	mov	r0, r4
 80008ba:	f7ff feb9 	bl	8000630 <test_println>
  }

  /* [13.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
  {
    test_print("--- Thread: ");
 80008be:	f247 001c 	movw	r0, #28700	; 0x701c
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [13.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80008c2:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 80008c4:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [13.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80008c8:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 80008ca:	f7ff fed1 	bl	8000670 <test_print>
    test_printn(sizeof(thread_t));
 80008ce:	2044      	movs	r0, #68	; 0x44
 80008d0:	f7ff ffa6 	bl	8000820 <test_printn>
    test_println(" bytes");
 80008d4:	4620      	mov	r0, r4
 80008d6:	f7ff feab 	bl	8000630 <test_println>
  }

  /* [13.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
  {
    test_print("--- Timer : ");
 80008da:	f247 002c 	movw	r0, #28716	; 0x702c
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [13.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 80008de:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 80008e0:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [13.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 80008e4:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 80008e6:	f7ff fec3 	bl	8000670 <test_print>
    test_printn(sizeof(virtual_timer_t));
 80008ea:	2014      	movs	r0, #20
 80008ec:	f7ff ff98 	bl	8000820 <test_printn>
    test_println(" bytes");
 80008f0:	4620      	mov	r0, r4
 80008f2:	f7ff fe9d 	bl	8000630 <test_println>

  /* [13.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 80008f6:	f247 003c 	movw	r0, #28732	; 0x703c
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [13.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 80008fa:	2604      	movs	r6, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 80008fc:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [13.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8000900:	602e      	str	r6, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8000902:	f7ff feb5 	bl	8000670 <test_print>
    test_printn(sizeof(semaphore_t));
 8000906:	200c      	movs	r0, #12
 8000908:	f7ff ff8a 	bl	8000820 <test_printn>
    test_println(" bytes");
 800090c:	4620      	mov	r0, r4
 800090e:	f7ff fe8f 	bl	8000630 <test_println>

  /* [13.12.5] The size of a mutex is printed.*/
  test_set_step(5);
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8000912:	f247 004c 	movw	r0, #28748	; 0x704c
    test_println(" bytes");
#endif
  }

  /* [13.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8000916:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8000918:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_println(" bytes");
#endif
  }

  /* [13.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 800091c:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 800091e:	f7ff fea7 	bl	8000670 <test_print>
    test_printn(sizeof(mutex_t));
 8000922:	2010      	movs	r0, #16
 8000924:	f7ff ff7c 	bl	8000820 <test_printn>
    test_println(" bytes");
 8000928:	4620      	mov	r0, r4
 800092a:	f7ff fe81 	bl	8000630 <test_println>

  /* [13.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 800092e:	f247 005c 	movw	r0, #28764	; 0x705c
    test_println(" bytes");
#endif
  }

  /* [13.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8000932:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8000934:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_println(" bytes");
#endif
  }

  /* [13.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8000938:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 800093a:	f7ff fe99 	bl	8000670 <test_print>
    test_printn(sizeof(condition_variable_t));
 800093e:	2008      	movs	r0, #8
 8000940:	f7ff ff6e 	bl	8000820 <test_printn>
    test_println(" bytes");
 8000944:	4620      	mov	r0, r4
 8000946:	f7ff fe73 	bl	8000630 <test_println>

  /* [13.12.7] The size of an event source is printed.*/
  test_set_step(7);
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 800094a:	f247 006c 	movw	r0, #28780	; 0x706c
    test_println(" bytes");
#endif
  }

  /* [13.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800094e:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8000950:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_println(" bytes");
#endif
  }

  /* [13.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8000954:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8000956:	f7ff fe8b 	bl	8000670 <test_print>
    test_printn(sizeof(event_source_t));
 800095a:	4630      	mov	r0, r6
 800095c:	f7ff ff60 	bl	8000820 <test_printn>
    test_println(" bytes");
 8000960:	4620      	mov	r0, r4
 8000962:	f7ff fe65 	bl	8000630 <test_println>

  /* [13.12.8] The size of an event listener is printed.*/
  test_set_step(8);
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8000966:	f247 007c 	movw	r0, #28796	; 0x707c
    test_println(" bytes");
#endif
  }

  /* [13.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 800096a:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 800096c:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_println(" bytes");
#endif
  }

  /* [13.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8000970:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8000972:	f7ff fe7d 	bl	8000670 <test_print>
    test_printn(sizeof(event_listener_t));
 8000976:	2014      	movs	r0, #20
 8000978:	f7ff ff52 	bl	8000820 <test_printn>
    test_println(" bytes");
 800097c:	4620      	mov	r0, r4
 800097e:	f7ff fe57 	bl	8000630 <test_println>

  /* [13.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8000982:	f247 008c 	movw	r0, #28812	; 0x708c
    test_println(" bytes");
#endif
  }

  /* [13.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8000986:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8000988:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_println(" bytes");
#endif
  }

  /* [13.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 800098c:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 800098e:	f7ff fe6f 	bl	8000670 <test_print>
    test_printn(sizeof(mailbox_t));
 8000992:	2028      	movs	r0, #40	; 0x28
 8000994:	f7ff ff44 	bl	8000820 <test_printn>
    test_println(" bytes");
 8000998:	4620      	mov	r0, r4
#endif
  }
}
 800099a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_set_step(9);
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
 800099e:	f7ff be47 	b.w	8000630 <test_println>
 80009a2:	bf00      	nop
 80009a4:	f3af 8000 	nop.w
 80009a8:	f3af 8000 	nop.w
 80009ac:	f3af 8000 	nop.w

080009b0 <print_line.8334>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
 80009b0:	b570      	push	{r4, r5, r6, lr}
 80009b2:	f241 3634 	movw	r6, #4916	; 0x1334
 80009b6:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80009ba:	254c      	movs	r5, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
 80009bc:	6830      	ldr	r0, [r6, #0]
 80009be:	212d      	movs	r1, #45	; 0x2d
 80009c0:	6803      	ldr	r3, [r0, #0]
 80009c2:	f241 3434 	movw	r4, #4916	; 0x1334
 80009c6:	689b      	ldr	r3, [r3, #8]
 80009c8:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 80009ca:	3d01      	subs	r5, #1
    streamPut(test_chp, '-');
 80009cc:	f2c2 0400 	movt	r4, #8192	; 0x2000
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 80009d0:	d1f4      	bne.n	80009bc <print_line.8334+0xc>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80009d2:	6820      	ldr	r0, [r4, #0]
 80009d4:	f646 7190 	movw	r1, #28560	; 0x6f90
 80009d8:	6803      	ldr	r3, [r0, #0]
 80009da:	f6c0 0100 	movt	r1, #2048	; 0x800
 80009de:	681b      	ldr	r3, [r3, #0]
 80009e0:	2202      	movs	r2, #2
 80009e2:	4798      	blx	r3
 80009e4:	bd70      	pop	{r4, r5, r6, pc}
 80009e6:	bf00      	nop
 80009e8:	f3af 8000 	nop.w
 80009ec:	f3af 8000 	nop.w

080009f0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80009f0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80009f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009f8:	69da      	ldr	r2, [r3, #28]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80009fa:	b4f0      	push	{r4, r5, r6, r7}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80009fc:	4282      	cmp	r2, r0
 80009fe:	d00f      	beq.n	8000a20 <chVTDoResetI+0x30>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000a00:	6802      	ldr	r2, [r0, #0]
 8000a02:	6841      	ldr	r1, [r0, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000a04:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000a06:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8000a08:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;
 8000a0a:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000a0c:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 8000a0e:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8000a10:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000a12:	d003      	beq.n	8000a1c <chVTDoResetI+0x2c>
      vtp->next->delta += vtp->delta;
 8000a14:	8901      	ldrh	r1, [r0, #8]
 8000a16:	8913      	ldrh	r3, [r2, #8]
 8000a18:	440b      	add	r3, r1
 8000a1a:	8113      	strh	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a1c:	bcf0      	pop	{r4, r5, r6, r7}
 8000a1e:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000a20:	6811      	ldr	r1, [r2, #0]
 8000a22:	4618      	mov	r0, r3
 8000a24:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000a28:	4281      	cmp	r1, r0
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000a2a:	f04f 0400 	mov.w	r4, #0
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000a2e:	bf08      	it	eq
 8000a30:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000a34:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8000a36:	60d4      	str	r4, [r2, #12]
 8000a38:	bf08      	it	eq
 8000a3a:	60dc      	streq	r4, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000a3c:	d0ee      	beq.n	8000a1c <chVTDoResetI+0x2c>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000a3e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000a42:	6a47      	ldr	r7, [r0, #36]	; 0x24

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000a44:	8916      	ldrh	r6, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000a46:	8cdc      	ldrh	r4, [r3, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000a48:	890d      	ldrh	r5, [r1, #8]
 8000a4a:	b2ba      	uxth	r2, r7
 8000a4c:	1973      	adds	r3, r6, r5
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000a4e:	1b14      	subs	r4, r2, r4

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000a50:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8000a52:	b2a4      	uxth	r4, r4

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000a54:	42a3      	cmp	r3, r4

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000a56:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000a58:	d9e0      	bls.n	8000a1c <chVTDoResetI+0x2c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000a5a:	1b1b      	subs	r3, r3, r4
 8000a5c:	b29b      	uxth	r3, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000a5e:	2b01      	cmp	r3, #1
 8000a60:	bf98      	it	ls
 8000a62:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 8000a64:	4413      	add	r3, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000a66:	b29b      	uxth	r3, r3
 8000a68:	6343      	str	r3, [r0, #52]	; 0x34
 8000a6a:	e7d7      	b.n	8000a1c <chVTDoResetI+0x2c>
 8000a6c:	f3af 8000 	nop.w

08000a70 <_port_irq_epilogue>:
 8000a70:	2320      	movs	r3, #32
 8000a72:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000a76:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8000a7a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8000a7e:	685b      	ldr	r3, [r3, #4]
 8000a80:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000a84:	d102      	bne.n	8000a8c <_port_irq_epilogue+0x1c>
 8000a86:	f383 8811 	msr	BASEPRI, r3
 8000a8a:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000a8c:	f3ef 8209 	mrs	r2, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000a90:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000a94:	f842 3c04 	str.w	r3, [r2, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000a98:	f1a2 0320 	sub.w	r3, r2, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000a9c:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000aa0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aa8:	6819      	ldr	r1, [r3, #0]
  tprio_t p2 = currp->prio;
 8000aaa:	699b      	ldr	r3, [r3, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000aac:	6889      	ldr	r1, [r1, #8]
 8000aae:	689b      	ldr	r3, [r3, #8]
 8000ab0:	4299      	cmp	r1, r3
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000ab2:	bf8b      	itete	hi
 8000ab4:	f240 2375 	movwhi	r3, #629	; 0x275
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000ab8:	f240 2378 	movwls	r3, #632	; 0x278

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000abc:	f6c0 0300 	movthi	r3, #2048	; 0x800
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000ac0:	f6c0 0300 	movtls	r3, #2048	; 0x800
 8000ac4:	f842 3c08 	str.w	r3, [r2, #-8]
 8000ac8:	4770      	bx	lr
 8000aca:	bf00      	nop
 8000acc:	f3af 8000 	nop.w

08000ad0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8000ad0:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000ad2:	2220      	movs	r2, #32
 8000ad4:	4603      	mov	r3, r0
 8000ad6:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 8000ada:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8000adc:	b128      	cbz	r0, 8000aea <chPoolAlloc+0x1a>
    mp->next = mp->next->next;
 8000ade:	6802      	ldr	r2, [r0, #0]
 8000ae0:	601a      	str	r2, [r3, #0]
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8000ae8:	bd08      	pop	{r3, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 8000aea:	689a      	ldr	r2, [r3, #8]
 8000aec:	2a00      	cmp	r2, #0
 8000aee:	d0f8      	beq.n	8000ae2 <chPoolAlloc+0x12>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8000af0:	6858      	ldr	r0, [r3, #4]
 8000af2:	2104      	movs	r1, #4
 8000af4:	4790      	blx	r2
 8000af6:	2300      	movs	r3, #0
 8000af8:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8000afc:	bd08      	pop	{r3, pc}
 8000afe:	bf00      	nop

08000b00 <chEvtAddEvents>:
 8000b00:	2320      	movs	r3, #32
 8000b02:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->epending |= events;
 8000b06:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000b0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000b0e:	699b      	ldr	r3, [r3, #24]
 8000b10:	2100      	movs	r1, #0
 8000b12:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000b14:	4310      	orrs	r0, r2
 8000b16:	6358      	str	r0, [r3, #52]	; 0x34
 8000b18:	f381 8811 	msr	BASEPRI, r1
  events = currp->epending;
  chSysUnlock();

  return events;
}
 8000b1c:	4770      	bx	lr
 8000b1e:	bf00      	nop

08000b20 <chEvtUnregister>:
 8000b20:	2320      	movs	r3, #32
 8000b22:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8000b26:	4602      	mov	r2, r0
 8000b28:	e002      	b.n	8000b30 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 8000b2a:	428b      	cmp	r3, r1
 8000b2c:	d007      	beq.n	8000b3e <chEvtUnregister+0x1e>
 8000b2e:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 8000b30:	6813      	ldr	r3, [r2, #0]
 8000b32:	4283      	cmp	r3, r0
 8000b34:	d1f9      	bne.n	8000b2a <chEvtUnregister+0xa>
 8000b36:	2300      	movs	r3, #0
 8000b38:	f383 8811 	msr	BASEPRI, r3
 8000b3c:	4770      	bx	lr
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
 8000b3e:	680b      	ldr	r3, [r1, #0]
 8000b40:	6013      	str	r3, [r2, #0]
 8000b42:	2300      	movs	r3, #0
 8000b44:	f383 8811 	msr	BASEPRI, r3
 8000b48:	4770      	bx	lr
 8000b4a:	bf00      	nop
 8000b4c:	f3af 8000 	nop.w

08000b50 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000b50:	e92d 05f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl}
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000b54:	6883      	ldr	r3, [r0, #8]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b56:	6906      	ldr	r6, [r0, #16]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000b58:	6845      	ldr	r5, [r0, #4]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b5a:	f843 6c6c 	str.w	r6, [r3, #-108]
 8000b5e:	6946      	ldr	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000b60:	2400      	movs	r4, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000b62:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000b66:	2101      	movs	r1, #1
  tp->name      = name;
  REG_INSERT(tp);
 8000b68:	f241 22c0 	movw	r2, #4800	; 0x12c0

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000b6c:	f8d0 800c 	ldr.w	r8, [r0, #12]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b70:	f843 6c68 	str.w	r6, [r3, #-104]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000b74:	f2c2 0200 	movt	r2, #8192	; 0x2000

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000b78:	6806      	ldr	r6, [r0, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000b7a:	f803 cc28 	strb.w	ip, [r3, #-40]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000b7e:	f803 1c26 	strb.w	r1, [r3, #-38]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000b82:	f803 4c27 	strb.w	r4, [r3, #-39]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000b86:	6957      	ldr	r7, [r2, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b88:	f240 2065 	movw	r0, #613	; 0x265
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000b8c:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000b90:	f843 5c2c 	str.w	r5, [r3, #-44]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b94:	f1a3 0a6c 	sub.w	sl, r3, #108	; 0x6c
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8000b98:	f1a3 051c 	sub.w	r5, r3, #28
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000b9c:	f6c0 0000 	movt	r0, #2048	; 0x800
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8000ba0:	f1a3 0c20 	sub.w	ip, r3, #32

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000ba4:	f843 6c30 	str.w	r6, [r3, #-48]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000ba8:	f843 8c40 	str.w	r8, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000bac:	f843 8c0c 	str.w	r8, [r3, #-12]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8000bb0:	f843 ac3c 	str.w	sl, [r3, #-60]
 8000bb4:	f843 0c4c 	str.w	r0, [r3, #-76]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000bb8:	f843 4c10 	str.w	r4, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000bbc:	f843 4c14 	str.w	r4, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000bc0:	f843 7c34 	str.w	r7, [r3, #-52]
 8000bc4:	f843 2c38 	str.w	r2, [r3, #-56]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8000bc8:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000bca:	6139      	str	r1, [r7, #16]
 8000bcc:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bce:	f843 5c1c 	str.w	r5, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 8000bd2:	f843 5c18 	str.w	r5, [r3, #-24]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000bd6:	f843 cc20 	str.w	ip, [r3, #-32]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8000bda:	e8bd 05f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl}
 8000bde:	4770      	bx	lr

08000be0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000be0:	f241 22c0 	movw	r2, #4800	; 0x12c0
 8000be4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000be8:	b470      	push	{r4, r5, r6}
 8000bea:	6810      	ldr	r0, [r2, #0]
 8000bec:	6995      	ldr	r5, [r2, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000bee:	6883      	ldr	r3, [r0, #8]
 8000bf0:	68ac      	ldr	r4, [r5, #8]
 8000bf2:	42a3      	cmp	r3, r4
 8000bf4:	d801      	bhi.n	8000bfa <chSchRescheduleS+0x1a>
    chSchDoRescheduleAhead();
  }
}
 8000bf6:	bc70      	pop	{r4, r5, r6}
 8000bf8:	4770      	bx	lr
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000bfa:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000bfc:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000bfe:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8000c00:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000c02:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000c04:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000c08:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000c0a:	f885 1020 	strb.w	r1, [r5, #32]
 8000c0e:	e000      	b.n	8000c12 <chSchRescheduleS+0x32>
 8000c10:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8000c12:	689a      	ldr	r2, [r3, #8]
 8000c14:	4294      	cmp	r4, r2
 8000c16:	d3fb      	bcc.n	8000c10 <chSchRescheduleS+0x30>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000c18:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000c1a:	4629      	mov	r1, r5
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000c1c:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8000c1e:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8000c20:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 8000c22:	605d      	str	r5, [r3, #4]
  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
  }
}
 8000c24:	bc70      	pop	{r4, r5, r6}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000c26:	f7ff bb15 	b.w	8000254 <_port_switch>
 8000c2a:	bf00      	nop
 8000c2c:	f3af 8000 	nop.w

08000c30 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8000c30:	b510      	push	{r4, lr}
 8000c32:	2320      	movs	r3, #32
 8000c34:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8000c38:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000c3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c40:	699b      	ldr	r3, [r3, #24]
 8000c42:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8000c44:	6899      	ldr	r1, [r3, #8]
 8000c46:	428c      	cmp	r4, r1
 8000c48:	d001      	beq.n	8000c4e <chThdSetPriority+0x1e>
 8000c4a:	4281      	cmp	r1, r0
 8000c4c:	d200      	bcs.n	8000c50 <chThdSetPriority+0x20>
    currp->prio = newprio;
 8000c4e:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 8000c50:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 8000c52:	f7ff ffc5 	bl	8000be0 <chSchRescheduleS>
 8000c56:	2300      	movs	r3, #0
 8000c58:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8000c5c:	4620      	mov	r0, r4
 8000c5e:	bd10      	pop	{r4, pc}

08000c60 <test_003_003_execute.8789>:
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_003_003_execute(void) {
 8000c60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000c64:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8000c68:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8000c6c:	69a3      	ldr	r3, [r4, #24]
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8000c6e:	f241 3530 	movw	r5, #4912	; 0x1330
 8000c72:	689e      	ldr	r6, [r3, #8]
 8000c74:	f2c2 0500 	movt	r5, #8192	; 0x2000
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000c78:	1c77      	adds	r7, r6, #1
static void test_003_003_execute(void) {
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8000c7a:	2301      	movs	r3, #1
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000c7c:	4638      	mov	r0, r7
static void test_003_003_execute(void) {
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8000c7e:	602b      	str	r3, [r5, #0]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000c80:	f7ff ffd6 	bl	8000c30 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8000c84:	ebb0 0c06 	subs.w	ip, r0, r6
  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8000c88:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 8000c8a:	f247 019c 	movw	r1, #28828	; 0x709c
 8000c8e:	f1dc 0000 	rsbs	r0, ip, #0
 8000c92:	eb50 000c 	adcs.w	r0, r0, ip
 8000c96:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000c9a:	f7ff fd31 	bl	8000700 <_test_assert>
 8000c9e:	b108      	cbz	r0, 8000ca4 <test_003_003_execute.8789+0x44>
 8000ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000ca4:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8000ca6:	f247 01c0 	movw	r1, #28864	; 0x70c0
 8000caa:	6898      	ldr	r0, [r3, #8]
 8000cac:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000cb0:	ebb7 0e00 	subs.w	lr, r7, r0
 8000cb4:	f1de 0000 	rsbs	r0, lr, #0
 8000cb8:	eb50 000e 	adcs.w	r0, r0, lr
 8000cbc:	f7ff fd20 	bl	8000700 <_test_assert>
 8000cc0:	2800      	cmp	r0, #0
 8000cc2:	d1ed      	bne.n	8000ca0 <test_003_003_execute.8789+0x40>
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8000cc4:	2302      	movs	r3, #2
  {
    p1 = chThdSetPriority(p1);
 8000cc6:	4640      	mov	r0, r8
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8000cc8:	602b      	str	r3, [r5, #0]
  {
    p1 = chThdSetPriority(p1);
 8000cca:	f7ff ffb1 	bl	8000c30 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8000cce:	1a3d      	subs	r5, r7, r0
 8000cd0:	4268      	negs	r0, r5
 8000cd2:	f247 019c 	movw	r1, #28828	; 0x709c
 8000cd6:	4168      	adcs	r0, r5
 8000cd8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000cdc:	f7ff fd10 	bl	8000700 <_test_assert>
 8000ce0:	2800      	cmp	r0, #0
 8000ce2:	d1dd      	bne.n	8000ca0 <test_003_003_execute.8789+0x40>
 8000ce4:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8000ce6:	f247 01c0 	movw	r1, #28864	; 0x70c0
 8000cea:	6898      	ldr	r0, [r3, #8]
 8000cec:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000cf0:	1a34      	subs	r4, r6, r0
 8000cf2:	4260      	negs	r0, r4
 8000cf4:	4160      	adcs	r0, r4
  }
}
 8000cf6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
     check is performed.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(p1);
    test_assert(p1 == prio + 1, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8000cfa:	f7ff bd01 	b.w	8000700 <_test_assert>
 8000cfe:	bf00      	nop

08000d00 <chSysRestoreStatusX.part.2.4326>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8000d00:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8000d02:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8000d06:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8000d0a:	b11c      	cbz	r4, 8000d14 <chSysRestoreStatusX.part.2.4326+0x14>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000d0c:	2300      	movs	r3, #0
 8000d0e:	f383 8811 	msr	BASEPRI, r3
 8000d12:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8000d14:	f7ff ff64 	bl	8000be0 <chSchRescheduleS>
 8000d18:	f384 8811 	msr	BASEPRI, r4
 8000d1c:	bd10      	pop	{r4, pc}
 8000d1e:	bf00      	nop

08000d20 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d20:	b4f0      	push	{r4, r5, r6, r7}
  thread_t *otp = currp;
 8000d22:	f241 27c0 	movw	r7, #4800	; 0x12c0
 8000d26:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8000d2a:	f8d7 c018 	ldr.w	ip, [r7, #24]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000d2e:	6885      	ldr	r5, [r0, #8]
 8000d30:	f8dc 4008 	ldr.w	r4, [ip, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d34:	4606      	mov	r6, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000d36:	42a5      	cmp	r5, r4
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000d38:	6241      	str	r1, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000d3a:	d80e      	bhi.n	8000d5a <chSchWakeupS+0x3a>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000d3c:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8000d3e:	463b      	mov	r3, r7
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000d40:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8000d44:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000d46:	689a      	ldr	r2, [r3, #8]
 8000d48:	4295      	cmp	r5, r2
 8000d4a:	d9fb      	bls.n	8000d44 <chSchWakeupS+0x24>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000d4c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000d4e:	6033      	str	r3, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
 8000d50:	6072      	str	r2, [r6, #4]
  tp->queue.prev->queue.next = tp;
 8000d52:	6016      	str	r6, [r2, #0]
  cp->queue.prev             = tp;
 8000d54:	605e      	str	r6, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8000d56:	bcf0      	pop	{r4, r5, r6, r7}
 8000d58:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000d5a:	2300      	movs	r3, #0
 8000d5c:	f88c 3020 	strb.w	r3, [ip, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8000d60:	463b      	mov	r3, r7
  do {
    cp = cp->queue.next;
 8000d62:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000d64:	689a      	ldr	r2, [r3, #8]
 8000d66:	4294      	cmp	r4, r2
 8000d68:	d9fb      	bls.n	8000d62 <chSchWakeupS+0x42>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000d6a:	685a      	ldr	r2, [r3, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8000d6c:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000d6e:	f8cc 3000 	str.w	r3, [ip]
  tp->queue.prev             = cp->queue.prev;
 8000d72:	f8cc 2004 	str.w	r2, [ip, #4]
  tp->queue.prev->queue.next = tp;
 8000d76:	f8c2 c000 	str.w	ip, [r2]
  cp->queue.prev             = tp;
 8000d7a:	f8c3 c004 	str.w	ip, [r3, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8000d7e:	f886 4020 	strb.w	r4, [r6, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000d82:	4630      	mov	r0, r6
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8000d84:	61be      	str	r6, [r7, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000d86:	4661      	mov	r1, ip
  }
}
 8000d88:	bcf0      	pop	{r4, r5, r6, r7}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8000d8a:	f7ff ba63 	b.w	8000254 <_port_switch>
 8000d8e:	bf00      	nop

08000d90 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8000d90:	b508      	push	{r3, lr}
 8000d92:	2220      	movs	r2, #32
 8000d94:	4603      	mov	r3, r0
 8000d96:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
 8000d9a:	6882      	ldr	r2, [r0, #8]
 8000d9c:	3201      	adds	r2, #1
 8000d9e:	2a00      	cmp	r2, #0
 8000da0:	6082      	str	r2, [r0, #8]
 8000da2:	dd03      	ble.n	8000dac <chSemSignal+0x1c>
 8000da4:	2300      	movs	r3, #0
 8000da6:	f383 8811 	msr	BASEPRI, r3
 8000daa:	bd08      	pop	{r3, pc}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000dac:	6800      	ldr	r0, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8000dae:	2100      	movs	r1, #0

  tqp->next             = tp->queue.next;
 8000db0:	6802      	ldr	r2, [r0, #0]
 8000db2:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000db4:	6053      	str	r3, [r2, #4]
 8000db6:	f7ff ffb3 	bl	8000d20 <chSchWakeupS>
 8000dba:	2300      	movs	r3, #0
 8000dbc:	f383 8811 	msr	BASEPRI, r3
 8000dc0:	bd08      	pop	{r3, pc}
 8000dc2:	bf00      	nop
 8000dc4:	f3af 8000 	nop.w
 8000dc8:	f3af 8000 	nop.w
 8000dcc:	f3af 8000 	nop.w

08000dd0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000dd0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000dd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000dd8:	b430      	push	{r4, r5}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000dda:	681a      	ldr	r2, [r3, #0]
  thread_t *otp = currp;
 8000ddc:	6999      	ldr	r1, [r3, #24]

  tqp->next             = tp->queue.next;
 8000dde:	6814      	ldr	r4, [r2, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000de0:	2501      	movs	r5, #1
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000de2:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000de6:	6063      	str	r3, [r4, #4]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000de8:	f882 5020 	strb.w	r5, [r2, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000dec:	601c      	str	r4, [r3, #0]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000dee:	4610      	mov	r0, r2
}
 8000df0:	bc30      	pop	{r4, r5}
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000df2:	619a      	str	r2, [r3, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000df4:	f7ff ba2e 	b.w	8000254 <_port_switch>
 8000df8:	f3af 8000 	nop.w
 8000dfc:	f3af 8000 	nop.w

08000e00 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8000e00:	b510      	push	{r4, lr}
 8000e02:	2320      	movs	r3, #32
 8000e04:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8000e08:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8000e0c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000e10:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 8000e12:	4613      	mov	r3, r2
 8000e14:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 8000e18:	4298      	cmp	r0, r3
 8000e1a:	d009      	beq.n	8000e30 <chMsgWait+0x30>
 8000e1c:	6801      	ldr	r1, [r0, #0]
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 8000e1e:	240d      	movs	r4, #13
 8000e20:	62d1      	str	r1, [r2, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
 8000e22:	604b      	str	r3, [r1, #4]
 8000e24:	2200      	movs	r2, #0
 8000e26:	f880 4020 	strb.w	r4, [r0, #32]
 8000e2a:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  return tp;
}
 8000e2e:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8000e30:	200e      	movs	r0, #14
 8000e32:	f7ff ffcd 	bl	8000dd0 <chSchGoSleepS>
 8000e36:	69a2      	ldr	r2, [r4, #24]
 8000e38:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000e3a:	f102 032c 	add.w	r3, r2, #44	; 0x2c
 8000e3e:	e7ed      	b.n	8000e1c <chMsgWait+0x1c>

08000e40 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8000e40:	b510      	push	{r4, lr}
 8000e42:	4603      	mov	r3, r0
 8000e44:	2220      	movs	r2, #32
 8000e46:	f382 8811 	msr	BASEPRI, r2
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000e4a:	6882      	ldr	r2, [r0, #8]
 8000e4c:	3a01      	subs	r2, #1
 8000e4e:	2a00      	cmp	r2, #0
 8000e50:	6082      	str	r2, [r0, #8]
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->u.rdymsg;
  }

  return MSG_OK;
 8000e52:	bfa8      	it	ge
 8000e54:	2000      	movge	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000e56:	db03      	blt.n	8000e60 <chSemWait+0x20>
 8000e58:	2300      	movs	r3, #0
 8000e5a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8000e5e:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 8000e60:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8000e64:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000e68:	69a2      	ldr	r2, [r4, #24]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000e6a:	2005      	movs	r0, #5
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 8000e6c:	6253      	str	r3, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8000e6e:	6859      	ldr	r1, [r3, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8000e70:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = tqp->prev;
 8000e72:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8000e74:	600a      	str	r2, [r1, #0]
  tqp->prev                  = tp;
 8000e76:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000e78:	f7ff ffaa 	bl	8000dd0 <chSchGoSleepS>

    return currp->u.rdymsg;
 8000e7c:	69a3      	ldr	r3, [r4, #24]
 8000e7e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000e80:	2300      	movs	r3, #0
 8000e82:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8000e86:	bd10      	pop	{r4, pc}
 8000e88:	f3af 8000 	nop.w
 8000e8c:	f3af 8000 	nop.w

08000e90 <bmk_thread7.10687>:
  } while (msg == MSG_OK);
  chSysUnlock();
}

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 8000e90:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000e92:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8000e96:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8000e9a:	69a3      	ldr	r3, [r4, #24]
 8000e9c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

  (void)p;
  while (!chThdShouldTerminateX())
 8000ea0:	075a      	lsls	r2, r3, #29
 8000ea2:	d40a      	bmi.n	8000eba <bmk_thread7.10687+0x2a>
    chSemWait(&sem1);
 8000ea4:	f640 1010 	movw	r0, #2320	; 0x910
 8000ea8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000eac:	f7ff ffc8 	bl	8000e40 <chSemWait>
 8000eb0:	69a3      	ldr	r3, [r4, #24]
 8000eb2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8000eb6:	075b      	lsls	r3, r3, #29
 8000eb8:	d5f4      	bpl.n	8000ea4 <bmk_thread7.10687+0x14>
 8000eba:	bd10      	pop	{r4, pc}
 8000ebc:	f3af 8000 	nop.w

08000ec0 <thread1.9234>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 8000ec0:	b510      	push	{r4, lr}
 8000ec2:	4604      	mov	r4, r0

  chSemWait(&sem1);
 8000ec4:	f640 70c8 	movw	r0, #4040	; 0xfc8
 8000ec8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ecc:	f7ff ffb8 	bl	8000e40 <chSemWait>
  test_emit_token(*(char *)p);
 8000ed0:	7820      	ldrb	r0, [r4, #0]
}
 8000ed2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 8000ed6:	f7ff bb6b 	b.w	80005b0 <test_emit_token>
 8000eda:	bf00      	nop
 8000edc:	f3af 8000 	nop.w

08000ee0 <thread3.9237>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {
 8000ee0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8000ee2:	f640 74c8 	movw	r4, #4040	; 0xfc8
 8000ee6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000eea:	4620      	mov	r0, r4
 8000eec:	f7ff ffa8 	bl	8000e40 <chSemWait>
  chSemSignal(&sem1);
 8000ef0:	4620      	mov	r0, r4
}
 8000ef2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 8000ef6:	f7ff bf4b 	b.w	8000d90 <chSemSignal>
 8000efa:	bf00      	nop
 8000efc:	f3af 8000 	nop.w

08000f00 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000f00:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8000f02:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000f06:	6881      	ldr	r1, [r0, #8]
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000f08:	b410      	push	{r4}
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.queue;
 8000f0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000f0e:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000f10:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8000f14:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000f16:	689a      	ldr	r2, [r3, #8]
 8000f18:	428a      	cmp	r2, r1
 8000f1a:	d2fb      	bcs.n	8000f14 <chSchReadyI+0x14>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000f1c:	685a      	ldr	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 8000f1e:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000f20:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8000f22:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8000f24:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8000f26:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000f28:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f2c:	4770      	bx	lr
 8000f2e:	bf00      	nop

08000f30 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8000f30:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8000f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8000f38:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8000f3a:	699c      	ldr	r4, [r3, #24]
 8000f3c:	2320      	movs	r3, #32
 8000f3e:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
 8000f42:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
 8000f44:	f890 2020 	ldrb.w	r2, [r0, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8000f48:	6b03      	ldr	r3, [r0, #48]	; 0x30

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
 8000f4a:	f100 012c 	add.w	r1, r0, #44	; 0x2c
  if (tp->state == CH_STATE_WTMSG) {
 8000f4e:	2a0e      	cmp	r2, #14
 8000f50:	e884 000a 	stmia.w	r4, {r1, r3}
  tp->queue.prev->queue.next = tp;
 8000f54:	601c      	str	r4, [r3, #0]
  tqp->prev                  = tp;
 8000f56:	6304      	str	r4, [r0, #48]	; 0x30
 8000f58:	d007      	beq.n	8000f6a <chMsgSend+0x3a>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8000f5a:	200c      	movs	r0, #12
 8000f5c:	f7ff ff38 	bl	8000dd0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8000f60:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8000f62:	2300      	movs	r3, #0
 8000f64:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8000f68:	bd10      	pop	{r4, pc}

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8000f6a:	f7ff ffc9 	bl	8000f00 <chSchReadyI>
 8000f6e:	e7f4      	b.n	8000f5a <chMsgSend+0x2a>

08000f70 <msg_thread1.9618>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8000f70:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8000f72:	2141      	movs	r1, #65	; 0x41

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8000f74:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8000f76:	f7ff ffdb 	bl	8000f30 <chMsgSend>
  chMsgSend(p, 'B');
 8000f7a:	4620      	mov	r0, r4
 8000f7c:	2142      	movs	r1, #66	; 0x42
 8000f7e:	f7ff ffd7 	bl	8000f30 <chMsgSend>
  chMsgSend(p, 'C');
 8000f82:	4620      	mov	r0, r4
 8000f84:	2143      	movs	r1, #67	; 0x43
 8000f86:	f7ff ffd3 	bl	8000f30 <chMsgSend>
  chMsgSend(p, 'D');
 8000f8a:	4620      	mov	r0, r4
 8000f8c:	2144      	movs	r1, #68	; 0x44
}
 8000f8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(msg_thread1, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  chMsgSend(p, 'D');
 8000f92:	f7ff bfcd 	b.w	8000f30 <chMsgSend>
 8000f96:	bf00      	nop
 8000f98:	f3af 8000 	nop.w
 8000f9c:	f3af 8000 	nop.w

08000fa0 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000fa0:	6b42      	ldr	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000fa2:	f890 3020 	ldrb.w	r3, [r0, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000fa6:	4311      	orrs	r1, r2
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000fa8:	2b0a      	cmp	r3, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8000faa:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000fac:	d00a      	beq.n	8000fc4 <chEvtSignalI+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000fae:	2b0b      	cmp	r3, #11
 8000fb0:	d000      	beq.n	8000fb4 <chEvtSignalI+0x14>
 8000fb2:	4770      	bx	lr
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000fb4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8000fb6:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000fb8:	428b      	cmp	r3, r1
 8000fba:	d1fa      	bne.n	8000fb2 <chEvtSignalI+0x12>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8000fbc:	2300      	movs	r3, #0
 8000fbe:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000fc0:	f7ff bf9e 	b.w	8000f00 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8000fc4:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000fc6:	4219      	tst	r1, r3
 8000fc8:	d1f8      	bne.n	8000fbc <chEvtSignalI+0x1c>
 8000fca:	4770      	bx	lr
 8000fcc:	f3af 8000 	nop.w

08000fd0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000fd0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8000fd2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000fd4:	4606      	mov	r6, r0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000fd6:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000fd8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000fda:	d00d      	beq.n	8000ff8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->flags |= flags;
 8000fdc:	68e3      	ldr	r3, [r4, #12]
 8000fde:	432b      	orrs	r3, r5
 8000fe0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000fe2:	b115      	cbz	r5, 8000fea <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8000fe4:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000fe6:	4213      	tst	r3, r2
 8000fe8:	d003      	beq.n	8000ff2 <chEvtBroadcastFlagsI+0x22>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8000fea:	6860      	ldr	r0, [r4, #4]
 8000fec:	68a1      	ldr	r1, [r4, #8]
 8000fee:	f7ff ffd7 	bl	8000fa0 <chEvtSignalI>
    }
    elp = elp->next;
 8000ff2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000ff4:	42a6      	cmp	r6, r4
 8000ff6:	d1f1      	bne.n	8000fdc <chEvtBroadcastFlagsI+0xc>
 8000ff8:	bd70      	pop	{r4, r5, r6, pc}
 8000ffa:	bf00      	nop
 8000ffc:	f3af 8000 	nop.w

08001000 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8001000:	b430      	push	{r4, r5}
  thread_t *ctp = currp;
 8001002:	f241 23c0 	movw	r3, #4800	; 0x12c0
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8001006:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 8001008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800100c:	6825      	ldr	r5, [r4, #0]
 800100e:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001010:	68e3      	ldr	r3, [r4, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001012:	42ac      	cmp	r4, r5
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001014:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001016:	d017      	beq.n	8001048 <chMtxUnlockS+0x48>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8001018:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800101a:	b14b      	cbz	r3, 8001030 <chMtxUnlockS+0x30>
 800101c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800101e:	4293      	cmp	r3, r2
 8001020:	d003      	beq.n	800102a <chMtxUnlockS+0x2a>
            (lmp->queue.next->prio > newprio)) {
 8001022:	6892      	ldr	r2, [r2, #8]
 8001024:	4291      	cmp	r1, r2
 8001026:	bf38      	it	cc
 8001028:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 800102a:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800102c:	2b00      	cmp	r3, #0
 800102e:	d1f5      	bne.n	800101c <chMtxUnlockS+0x1c>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8001030:	6baa      	ldr	r2, [r5, #56]	; 0x38
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001032:	682b      	ldr	r3, [r5, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8001034:	6081      	str	r1, [r0, #8]
 8001036:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8001038:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 800103a:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 800103c:	60a5      	str	r5, [r4, #8]
      mp->next = tp->mtxlist;
 800103e:	60e2      	str	r2, [r4, #12]
      tp->mtxlist = mp;
 8001040:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8001042:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8001044:	f7ff bf5c 	b.w	8000f00 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
 8001048:	2300      	movs	r3, #0
 800104a:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800104c:	bc30      	pop	{r4, r5}
 800104e:	4770      	bx	lr

08001050 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001050:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8001052:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8001056:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800105a:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 800105c:	6998      	ldr	r0, [r3, #24]
 800105e:	2320      	movs	r3, #32
 8001060:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001064:	6825      	ldr	r5, [r4, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001066:	68e3      	ldr	r3, [r4, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001068:	42ac      	cmp	r4, r5
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800106a:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800106c:	d01c      	beq.n	80010a8 <chMtxUnlock+0x58>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800106e:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8001070:	b14b      	cbz	r3, 8001086 <chMtxUnlock+0x36>
 8001072:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001074:	4293      	cmp	r3, r2
 8001076:	d003      	beq.n	8001080 <chMtxUnlock+0x30>
            (lmp->queue.next->prio > newprio)) {
 8001078:	6892      	ldr	r2, [r2, #8]
 800107a:	4291      	cmp	r1, r2
 800107c:	bf38      	it	cc
 800107e:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8001080:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8001082:	2b00      	cmp	r3, #0
 8001084:	d1f5      	bne.n	8001072 <chMtxUnlock+0x22>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001086:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8001088:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800108a:	6081      	str	r1, [r0, #8]
 800108c:	6023      	str	r3, [r4, #0]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800108e:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 8001090:	605c      	str	r4, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8001092:	60e2      	str	r2, [r4, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8001094:	60a5      	str	r5, [r4, #8]
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
 8001096:	63ac      	str	r4, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8001098:	f7ff ff32 	bl	8000f00 <chSchReadyI>
      chSchRescheduleS();
 800109c:	f7ff fda0 	bl	8000be0 <chSchRescheduleS>
 80010a0:	2300      	movs	r3, #0
 80010a2:	f383 8811 	msr	BASEPRI, r3
 80010a6:	bd38      	pop	{r3, r4, r5, pc}
    }
    else {
      mp->owner = NULL;
 80010a8:	2300      	movs	r3, #0
 80010aa:	60a3      	str	r3, [r4, #8]
 80010ac:	2300      	movs	r3, #0
 80010ae:	f383 8811 	msr	BASEPRI, r3
 80010b2:	bd38      	pop	{r3, r4, r5, pc}
 80010b4:	f3af 8000 	nop.w
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80010c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80010c2:	6882      	ldr	r2, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80010c4:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80010c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80010cc:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 80010ce:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80010d0:	2a00      	cmp	r2, #0
 80010d2:	d055      	beq.n	8001180 <chMtxLockS+0xc0>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80010d4:	68a1      	ldr	r1, [r4, #8]
 80010d6:	6893      	ldr	r3, [r2, #8]
 80010d8:	428b      	cmp	r3, r1
 80010da:	d207      	bcs.n	80010ec <chMtxLockS+0x2c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80010dc:	f892 3020 	ldrb.w	r3, [r2, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 80010e0:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80010e2:	2b06      	cmp	r3, #6
 80010e4:	d033      	beq.n	800114e <chMtxLockS+0x8e>
 80010e6:	2b07      	cmp	r3, #7
 80010e8:	d01d      	beq.n	8001126 <chMtxLockS+0x66>
 80010ea:	b19b      	cbz	r3, 8001114 <chMtxLockS+0x54>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80010ec:	462b      	mov	r3, r5
 80010ee:	e003      	b.n	80010f8 <chMtxLockS+0x38>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80010f0:	6899      	ldr	r1, [r3, #8]
 80010f2:	68a2      	ldr	r2, [r4, #8]
 80010f4:	4291      	cmp	r1, r2
 80010f6:	d302      	bcc.n	80010fe <chMtxLockS+0x3e>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80010f8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80010fa:	429d      	cmp	r5, r3
 80010fc:	d1f8      	bne.n	80010f0 <chMtxLockS+0x30>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80010fe:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001100:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8001102:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8001104:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001106:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8001108:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800110a:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 800110c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001110:	f7ff be5e 	b.w	8000dd0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001114:	e892 000a 	ldmia.w	r2, {r1, r3}
 8001118:	6019      	str	r1, [r3, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800111a:	4610      	mov	r0, r2
  tp->queue.next->queue.prev = tp->queue.prev;
 800111c:	6812      	ldr	r2, [r2, #0]
 800111e:	6053      	str	r3, [r2, #4]
 8001120:	f7ff feee 	bl	8000f00 <chSchReadyI>
 8001124:	e7e2      	b.n	80010ec <chMtxLockS+0x2c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001126:	6813      	ldr	r3, [r2, #0]
 8001128:	6850      	ldr	r0, [r2, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800112a:	6a56      	ldr	r6, [r2, #36]	; 0x24
 800112c:	6003      	str	r3, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800112e:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001130:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  tp->queue.next->queue.prev = tp->queue.prev;
 8001132:	6078      	str	r0, [r7, #4]
 8001134:	e002      	b.n	800113c <chMtxLockS+0x7c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001136:	6898      	ldr	r0, [r3, #8]
 8001138:	4288      	cmp	r0, r1
 800113a:	d302      	bcc.n	8001142 <chMtxLockS+0x82>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800113c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800113e:	429e      	cmp	r6, r3
 8001140:	d1f9      	bne.n	8001136 <chMtxLockS+0x76>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001142:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001144:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8001146:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8001148:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800114a:	605a      	str	r2, [r3, #4]
 800114c:	e7ce      	b.n	80010ec <chMtxLockS+0x2c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800114e:	6813      	ldr	r3, [r2, #0]
 8001150:	6850      	ldr	r0, [r2, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001152:	6a56      	ldr	r6, [r2, #36]	; 0x24
 8001154:	6003      	str	r3, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001156:	6817      	ldr	r7, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001158:	4633      	mov	r3, r6
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  tp->queue.next->queue.prev = tp->queue.prev;
 800115a:	6078      	str	r0, [r7, #4]
 800115c:	e002      	b.n	8001164 <chMtxLockS+0xa4>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800115e:	6898      	ldr	r0, [r3, #8]
 8001160:	4288      	cmp	r0, r1
 8001162:	d302      	bcc.n	800116a <chMtxLockS+0xaa>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001164:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001166:	429e      	cmp	r6, r3
 8001168:	d1f9      	bne.n	800115e <chMtxLockS+0x9e>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800116a:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800116c:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 800116e:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8001170:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001172:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8001174:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8001176:	68a1      	ldr	r1, [r4, #8]
 8001178:	6893      	ldr	r3, [r2, #8]
 800117a:	428b      	cmp	r3, r1
 800117c:	d3ae      	bcc.n	80010dc <chMtxLockS+0x1c>
 800117e:	e7b5      	b.n	80010ec <chMtxLockS+0x2c>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 8001180:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8001182:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 8001184:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 8001186:	63a0      	str	r0, [r4, #56]	; 0x38
 8001188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800118a:	bf00      	nop
 800118c:	f3af 8000 	nop.w

08001190 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001190:	b508      	push	{r3, lr}
 8001192:	2320      	movs	r3, #32
 8001194:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 8001198:	f7ff ff92 	bl	80010c0 <chMtxLockS>
 800119c:	2300      	movs	r3, #0
 800119e:	f383 8811 	msr	BASEPRI, r3
 80011a2:	bd08      	pop	{r3, pc}
 80011a4:	f3af 8000 	nop.w
 80011a8:	f3af 8000 	nop.w
 80011ac:	f3af 8000 	nop.w

080011b0 <thread1.9483>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 80011b0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 80011b2:	f640 046c 	movw	r4, #2156	; 0x86c
 80011b6:	f2c2 0400 	movt	r4, #8192	; 0x2000
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 80011ba:	4605      	mov	r5, r0

  chMtxLock(&m1);
 80011bc:	4620      	mov	r0, r4
 80011be:	f7ff ffe7 	bl	8001190 <chMtxLock>
  test_emit_token(*(char *)p);
 80011c2:	7828      	ldrb	r0, [r5, #0]
 80011c4:	f7ff f9f4 	bl	80005b0 <test_emit_token>
  chMtxUnlock(&m1);
 80011c8:	4620      	mov	r0, r4
}
 80011ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80011ce:	f7ff bf3f 	b.w	8001050 <chMtxUnlock>
 80011d2:	bf00      	nop
 80011d4:	f3af 8000 	nop.w
 80011d8:	f3af 8000 	nop.w
 80011dc:	f3af 8000 	nop.w

080011e0 <thread9.9474>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 80011e0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 80011e2:	f640 0400 	movw	r4, #2048	; 0x800
 80011e6:	f2c2 0400 	movt	r4, #8192	; 0x2000
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 80011ea:	4605      	mov	r5, r0

  chMtxLock(&m2);
 80011ec:	4620      	mov	r0, r4
 80011ee:	f7ff ffcf 	bl	8001190 <chMtxLock>
  test_emit_token(*(char *)p);
 80011f2:	7828      	ldrb	r0, [r5, #0]
 80011f4:	f7ff f9dc 	bl	80005b0 <test_emit_token>
  chMtxUnlock(&m2);
 80011f8:	4620      	mov	r0, r4
}
 80011fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread9, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 80011fe:	f7ff bf27 	b.w	8001050 <chMtxUnlock>
 8001202:	bf00      	nop
 8001204:	f3af 8000 	nop.w
 8001208:	f3af 8000 	nop.w
 800120c:	f3af 8000 	nop.w

08001210 <chHeapStatus>:
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 8001210:	f241 3338 	movw	r3, #4920	; 0x1338
 8001214:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8001218:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 800121c:	2800      	cmp	r0, #0
 800121e:	bf14      	ite	ne
 8001220:	4604      	movne	r4, r0
 8001222:	461c      	moveq	r4, r3
  }

  H_LOCK(heapp);
 8001224:	f104 0810 	add.w	r8, r4, #16
 8001228:	4640      	mov	r0, r8
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 800122a:	468a      	mov	sl, r1
 800122c:	4691      	mov	r9, r2

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 800122e:	f7ff ffaf 	bl	8001190 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8001232:	68a3      	ldr	r3, [r4, #8]
 8001234:	b1e3      	cbz	r3, 8001270 <chHeapStatus+0x60>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
 8001236:	2500      	movs	r5, #0
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
 8001238:	462f      	mov	r7, r5
  lpages = 0U;
  n = 0U;
 800123a:	462e      	mov	r6, r5
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800123c:	cb18      	ldmia	r3, {r3, r4}
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 800123e:	3601      	adds	r6, #1
    tpages += pages;
 8001240:	4427      	add	r7, r4
 8001242:	42a5      	cmp	r5, r4
 8001244:	bf38      	it	cc
 8001246:	4625      	movcc	r5, r4
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8001248:	2b00      	cmp	r3, #0
 800124a:	d1f7      	bne.n	800123c <chHeapStatus+0x2c>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 800124c:	f1ba 0f00 	cmp.w	sl, #0
 8001250:	d002      	beq.n	8001258 <chHeapStatus+0x48>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8001252:	00ff      	lsls	r7, r7, #3
 8001254:	f8ca 7000 	str.w	r7, [sl]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8001258:	f1b9 0f00 	cmp.w	r9, #0
 800125c:	d002      	beq.n	8001264 <chHeapStatus+0x54>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 800125e:	00ed      	lsls	r5, r5, #3
 8001260:	f8c9 5000 	str.w	r5, [r9]
  }
  H_UNLOCK(heapp);
 8001264:	4640      	mov	r0, r8
 8001266:	f7ff fef3 	bl	8001050 <chMtxUnlock>

  return n;
}
 800126a:	4630      	mov	r0, r6
 800126c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
 8001270:	461d      	mov	r5, r3
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
 8001272:	461f      	mov	r7, r3
  lpages = 0U;
  n = 0U;
 8001274:	461e      	mov	r6, r3
 8001276:	e7e9      	b.n	800124c <chHeapStatus+0x3c>
 8001278:	f3af 8000 	nop.w
 800127c:	f3af 8000 	nop.w

08001280 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001282:	f850 3c04 	ldr.w	r3, [r0, #-4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001286:	f850 4c08 	ldr.w	r4, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800128a:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800128c:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800128e:	f104 0610 	add.w	r6, r4, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001292:	f840 3c04 	str.w	r3, [r0, #-4]
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001296:	4605      	mov	r5, r0

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8001298:	3408      	adds	r4, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800129a:	4630      	mov	r0, r6
 800129c:	f7ff ff78 	bl	8001190 <chMtxLock>
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80012a0:	f1a5 0108 	sub.w	r1, r5, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80012a4:	4623      	mov	r3, r4
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80012a6:	42a3      	cmp	r3, r4
 80012a8:	d004      	beq.n	80012b4 <chHeapFree+0x34>
 80012aa:	428b      	cmp	r3, r1
 80012ac:	d302      	bcc.n	80012b4 <chHeapFree+0x34>
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	42a3      	cmp	r3, r4
 80012b2:	d1fa      	bne.n	80012aa <chHeapFree+0x2a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80012b4:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80012b6:	b11a      	cbz	r2, 80012c0 <chHeapFree+0x40>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80012b8:	4291      	cmp	r1, r2
 80012ba:	d301      	bcc.n	80012c0 <chHeapFree+0x40>
 80012bc:	4613      	mov	r3, r2
 80012be:	e7f2      	b.n	80012a6 <chHeapFree+0x26>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80012c0:	f855 0c04 	ldr.w	r0, [r5, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80012c4:	f845 2c08 	str.w	r2, [r5, #-8]
      H_NEXT(qp) = hp;
 80012c8:	6019      	str	r1, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80012ca:	1c42      	adds	r2, r0, #1
 80012cc:	f855 7c08 	ldr.w	r7, [r5, #-8]
 80012d0:	eb01 04c2 	add.w	r4, r1, r2, lsl #3
 80012d4:	42bc      	cmp	r4, r7
 80012d6:	d00a      	beq.n	80012ee <chHeapFree+0x6e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 80012d8:	685a      	ldr	r2, [r3, #4]
 80012da:	1c50      	adds	r0, r2, #1
 80012dc:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 80012e0:	4281      	cmp	r1, r0
 80012e2:	d013      	beq.n	800130c <chHeapFree+0x8c>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80012e4:	4630      	mov	r0, r6

  return;
}
 80012e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80012ea:	f7ff beb1 	b.w	8001050 <chMtxUnlock>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80012ee:	6864      	ldr	r4, [r4, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80012f0:	f851 2032 	ldr.w	r2, [r1, r2, lsl #3]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80012f4:	4420      	add	r0, r4
 80012f6:	3001      	adds	r0, #1
 80012f8:	f845 0c04 	str.w	r0, [r5, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80012fc:	f845 2c08 	str.w	r2, [r5, #-8]
      }
      if ((H_LIMIT(qp) == hp)) {
 8001300:	685a      	ldr	r2, [r3, #4]
 8001302:	1c50      	adds	r0, r2, #1
 8001304:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8001308:	4281      	cmp	r1, r0
 800130a:	d1eb      	bne.n	80012e4 <chHeapFree+0x64>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800130c:	f855 0c04 	ldr.w	r0, [r5, #-4]
        H_NEXT(qp) = H_NEXT(hp);
 8001310:	f855 1c08 	ldr.w	r1, [r5, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8001314:	4402      	add	r2, r0
 8001316:	3201      	adds	r2, #1
        H_NEXT(qp) = H_NEXT(hp);
 8001318:	e883 0006 	stmia.w	r3, {r1, r2}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800131c:	4630      	mov	r0, r6

  return;
}
 800131e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001322:	f7ff be95 	b.w	8001050 <chMtxUnlock>
 8001326:	bf00      	nop
 8001328:	f3af 8000 	nop.w
 800132c:	f3af 8000 	nop.w

08001330 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001330:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001332:	b410      	push	{r4}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001334:	3201      	adds	r2, #1
 8001336:	2a00      	cmp	r2, #0
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001338:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 800133a:	6082      	str	r2, [r0, #8]
 800133c:	dd02      	ble.n	8001344 <chSemSignalI+0x14>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 800133e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001342:	4770      	bx	lr
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001344:	6802      	ldr	r2, [r0, #0]

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8001346:	2400      	movs	r4, #0

  tqp->next             = tp->queue.next;
 8001348:	6811      	ldr	r1, [r2, #0]
    (void) chSchReadyI(tp);
 800134a:	4610      	mov	r0, r2
 800134c:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800134e:	604b      	str	r3, [r1, #4]

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8001350:	6254      	str	r4, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
  }
}
 8001352:	f85d 4b04 	ldr.w	r4, [sp], #4
  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 8001356:	f7ff bdd3 	b.w	8000f00 <chSchReadyI>
 800135a:	bf00      	nop
 800135c:	f3af 8000 	nop.w

08001360 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001360:	b570      	push	{r4, r5, r6, lr}
 8001362:	2320      	movs	r3, #32
 8001364:	4604      	mov	r4, r0
 8001366:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 800136a:	6885      	ldr	r5, [r0, #8]
  sp->cnt = n;
 800136c:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 800136e:	3501      	adds	r5, #1
 8001370:	2d00      	cmp	r5, #0
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8001372:	bfd8      	it	le
 8001374:	f06f 0601 	mvnle.w	r6, #1
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001378:	dc09      	bgt.n	800138e <chSemReset+0x2e>

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 800137a:	6860      	ldr	r0, [r4, #4]
 800137c:	3501      	adds	r5, #1

  tqp->prev             = tp->queue.prev;
 800137e:	6843      	ldr	r3, [r0, #4]
 8001380:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8001382:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8001384:	f7ff fdbc 	bl	8000f00 <chSchReadyI>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001388:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800138a:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 800138c:	d1f5      	bne.n	800137a <chSemReset+0x1a>
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
  chSchRescheduleS();
 800138e:	f7ff fc27 	bl	8000be0 <chSchRescheduleS>
 8001392:	2300      	movs	r3, #0
 8001394:	f383 8811 	msr	BASEPRI, r3
 8001398:	bd70      	pop	{r4, r5, r6, pc}
 800139a:	bf00      	nop
 800139c:	f3af 8000 	nop.w

080013a0 <test_005_001_execute.9275>:

static void test_005_001_teardown(void) {
  chSemReset(&sem1, 0);
}

static void test_005_001_execute(void) {
 80013a0:	b570      	push	{r4, r5, r6, lr}
     counter and the returned message are tested.*/
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80013a2:	f640 70c8 	movw	r0, #4040	; 0xfc8

static void test_005_001_execute(void) {

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 80013a6:	f241 3530 	movw	r5, #4912	; 0x1330
 80013aa:	2301      	movs	r3, #1
 80013ac:	f2c2 0500 	movt	r5, #8192	; 0x2000
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80013b0:	f2c2 0000 	movt	r0, #8192	; 0x2000

static void test_005_001_execute(void) {

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 80013b4:	602b      	str	r3, [r5, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80013b6:	f7ff fd43 	bl	8000e40 <chSemWait>
 80013ba:	2320      	movs	r3, #32
 80013bc:	4606      	mov	r6, r0
 80013be:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 80013c2:	f640 74c8 	movw	r4, #4040	; 0xfc8
 80013c6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80013ca:	68a0      	ldr	r0, [r4, #8]
 80013cc:	f247 01dc 	movw	r1, #28892	; 0x70dc
 80013d0:	f1d0 0001 	rsbs	r0, r0, #1
 80013d4:	bf38      	it	cc
 80013d6:	2000      	movcc	r0, #0
 80013d8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80013dc:	f7ff f990 	bl	8000700 <_test_assert>
 80013e0:	b118      	cbz	r0, 80013ea <test_005_001_execute.9275+0x4a>
 80013e2:	2300      	movs	r3, #0
 80013e4:	f383 8811 	msr	BASEPRI, r3
 80013e8:	bd70      	pop	{r4, r5, r6, pc}
 80013ea:	f380 8811 	msr	BASEPRI, r0
    test_assert(MSG_OK == msg, "wrong returned message");
 80013ee:	f247 01f0 	movw	r1, #28912	; 0x70f0
 80013f2:	f1d6 0001 	rsbs	r0, r6, #1
 80013f6:	bf38      	it	cc
 80013f8:	2000      	movcc	r0, #0
 80013fa:	f6c0 0100 	movt	r1, #2048	; 0x800
 80013fe:	f7ff f97f 	bl	8000700 <_test_assert>
 8001402:	b100      	cbz	r0, 8001406 <test_005_001_execute.9275+0x66>
 8001404:	bd70      	pop	{r4, r5, r6, pc}

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 8001406:	f640 70c8 	movw	r0, #4040	; 0xfc8
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 800140a:	2302      	movs	r3, #2
  {
    chSemSignal(&sem1);
 800140c:	f2c2 0000 	movt	r0, #8192	; 0x2000
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8001410:	602b      	str	r3, [r5, #0]
  {
    chSemSignal(&sem1);
 8001412:	f7ff fcbd 	bl	8000d90 <chSemSignal>
 8001416:	2320      	movs	r3, #32
 8001418:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 800141c:	68a0      	ldr	r0, [r4, #8]
 800141e:	f247 01dc 	movw	r1, #28892	; 0x70dc
 8001422:	1e46      	subs	r6, r0, #1
 8001424:	4270      	negs	r0, r6
 8001426:	4170      	adcs	r0, r6
 8001428:	f6c0 0100 	movt	r1, #2048	; 0x800
 800142c:	f7ff f968 	bl	8000700 <_test_assert>
 8001430:	2800      	cmp	r0, #0
 8001432:	d1d6      	bne.n	80013e2 <test_005_001_execute.9275+0x42>
 8001434:	f380 8811 	msr	BASEPRI, r0

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
  {
    chSemReset(&sem1, 2);
 8001438:	f640 70c8 	movw	r0, #4040	; 0xfc8
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 800143c:	2303      	movs	r3, #3
  {
    chSemReset(&sem1, 2);
 800143e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001442:	2102      	movs	r1, #2
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8001444:	602b      	str	r3, [r5, #0]
  {
    chSemReset(&sem1, 2);
 8001446:	f7ff ff8b 	bl	8001360 <chSemReset>
 800144a:	2320      	movs	r3, #32
 800144c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8001450:	68a0      	ldr	r0, [r4, #8]
 8001452:	f247 01dc 	movw	r1, #28892	; 0x70dc
 8001456:	1e84      	subs	r4, r0, #2
 8001458:	4260      	negs	r0, r4
 800145a:	4160      	adcs	r0, r4
 800145c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001460:	f7ff f94e 	bl	8000700 <_test_assert>
 8001464:	2800      	cmp	r0, #0
 8001466:	d1bc      	bne.n	80013e2 <test_005_001_execute.9275+0x42>
 8001468:	f380 8811 	msr	BASEPRI, r0
 800146c:	e7ca      	b.n	8001404 <test_005_001_execute.9275+0x64>
 800146e:	bf00      	nop

08001470 <test_005_001_teardown.9253>:
static void test_005_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_005_001_teardown(void) {
  chSemReset(&sem1, 0);
 8001470:	f640 70c8 	movw	r0, #4040	; 0xfc8
 8001474:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001478:	2100      	movs	r1, #0
 800147a:	f7ff bf71 	b.w	8001360 <chSemReset>
 800147e:	bf00      	nop

08001480 <chSysGetStatusAndLockX.part.1.4323>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001480:	f3ef 8305 	mrs	r3, IPSR
 8001484:	f3c3 0308 	ubfx	r3, r3, #0, #9
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8001488:	b91b      	cbnz	r3, 8001492 <chSysGetStatusAndLockX.part.1.4323+0x12>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800148a:	2320      	movs	r3, #32
 800148c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8001490:	4770      	bx	lr
 8001492:	2320      	movs	r3, #32
 8001494:	f383 8811 	msr	BASEPRI, r3
 8001498:	4770      	bx	lr
 800149a:	bf00      	nop
 800149c:	f3af 8000 	nop.w

080014a0 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 80014a0:	e7fe      	b.n	80014a0 <BusFault_Handler>
 80014a2:	bf00      	nop
 80014a4:	f3af 8000 	nop.w
 80014a8:	f3af 8000 	nop.w
 80014ac:	f3af 8000 	nop.w

080014b0 <test_006_009_setup.9496>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80014b0:	f640 0164 	movw	r1, #2148	; 0x864
 80014b4:	f640 026c 	movw	r2, #2156	; 0x86c
 80014b8:	f640 0300 	movw	r3, #2048	; 0x800
 80014bc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80014c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014c4:	f2c2 0100 	movt	r1, #8192	; 0x2000
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 80014c8:	2000      	movs	r0, #0
 80014ca:	6009      	str	r1, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 80014cc:	6049      	str	r1, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80014ce:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 80014d0:	6052      	str	r2, [r2, #4]
 80014d2:	6090      	str	r0, [r2, #8]
 80014d4:	6098      	str	r0, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80014d6:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80014d8:	605b      	str	r3, [r3, #4]
 80014da:	4770      	bx	lr
 80014dc:	f3af 8000 	nop.w

080014e0 <test_006_008_setup.9498>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80014e0:	f640 0264 	movw	r2, #2148	; 0x864
 80014e4:	f640 036c 	movw	r3, #2156	; 0x86c
 80014e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80014ec:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80014f0:	2100      	movs	r1, #0
 80014f2:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 80014f4:	6052      	str	r2, [r2, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80014f6:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80014f8:	605b      	str	r3, [r3, #4]
 80014fa:	6099      	str	r1, [r3, #8]
 80014fc:	4770      	bx	lr
 80014fe:	bf00      	nop

08001500 <test_006_007_setup.9500>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001500:	f640 0264 	movw	r2, #2148	; 0x864
 8001504:	f640 036c 	movw	r3, #2156	; 0x86c
 8001508:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800150c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001510:	2100      	movs	r1, #0
 8001512:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8001514:	6052      	str	r2, [r2, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001516:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001518:	605b      	str	r3, [r3, #4]
 800151a:	6099      	str	r1, [r3, #8]
 800151c:	4770      	bx	lr
 800151e:	bf00      	nop

08001520 <test_006_005_setup.9502>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001520:	f640 036c 	movw	r3, #2156	; 0x86c
 8001524:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001528:	2200      	movs	r2, #0
 800152a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800152c:	605b      	str	r3, [r3, #4]
 800152e:	609a      	str	r2, [r3, #8]
 8001530:	4770      	bx	lr
 8001532:	bf00      	nop
 8001534:	f3af 8000 	nop.w
 8001538:	f3af 8000 	nop.w
 800153c:	f3af 8000 	nop.w

08001540 <test_006_004_setup.9504>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001540:	f640 026c 	movw	r2, #2156	; 0x86c
 8001544:	f640 0300 	movw	r3, #2048	; 0x800
 8001548:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800154c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001550:	2100      	movs	r1, #0
 8001552:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8001554:	6052      	str	r2, [r2, #4]
 8001556:	6091      	str	r1, [r2, #8]
 8001558:	6099      	str	r1, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800155a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800155c:	605b      	str	r3, [r3, #4]
 800155e:	4770      	bx	lr

08001560 <test_006_001_setup.9506>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001560:	f640 036c 	movw	r3, #2156	; 0x86c
 8001564:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001568:	2200      	movs	r2, #0
 800156a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800156c:	605b      	str	r3, [r3, #4]
 800156e:	609a      	str	r2, [r3, #8]
 8001570:	4770      	bx	lr
 8001572:	bf00      	nop
 8001574:	f3af 8000 	nop.w
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <test_010_002_setup.10255>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8001580:	f640 031c 	movw	r3, #2076	; 0x81c
 8001584:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001588:	2200      	movs	r2, #0
  mp->object_size = size;
 800158a:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800158c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800158e:	605b      	str	r3, [r3, #4]
 8001590:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8001592:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 8001594:	615a      	str	r2, [r3, #20]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8001596:	609a      	str	r2, [r3, #8]
 8001598:	4770      	bx	lr
 800159a:	bf00      	nop
 800159c:	f3af 8000 	nop.w

080015a0 <test_013_010_setup.10707>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80015a0:	f640 1310 	movw	r3, #2320	; 0x910
 80015a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015a8:	2201      	movs	r2, #1
 80015aa:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80015ac:	605b      	str	r3, [r3, #4]
 80015ae:	609a      	str	r2, [r3, #8]
 80015b0:	4770      	bx	lr
 80015b2:	bf00      	nop
 80015b4:	f3af 8000 	nop.w
 80015b8:	f3af 8000 	nop.w
 80015bc:	f3af 8000 	nop.w

080015c0 <test_013_007_setup.10709>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80015c0:	f640 1310 	movw	r3, #2320	; 0x910
 80015c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015c8:	2200      	movs	r2, #0
 80015ca:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80015cc:	605b      	str	r3, [r3, #4]
 80015ce:	609a      	str	r2, [r3, #8]
 80015d0:	4770      	bx	lr
 80015d2:	bf00      	nop
 80015d4:	f3af 8000 	nop.w
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <test_005_005_setup.9243>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80015e0:	f640 73c8 	movw	r3, #4040	; 0xfc8
 80015e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015e8:	2200      	movs	r2, #0
 80015ea:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80015ec:	605b      	str	r3, [r3, #4]
 80015ee:	609a      	str	r2, [r3, #8]
 80015f0:	4770      	bx	lr
 80015f2:	bf00      	nop
 80015f4:	f3af 8000 	nop.w
 80015f8:	f3af 8000 	nop.w
 80015fc:	f3af 8000 	nop.w

08001600 <test_005_004_setup.9245>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001600:	f640 73c8 	movw	r3, #4040	; 0xfc8
 8001604:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001608:	2200      	movs	r2, #0
 800160a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800160c:	605b      	str	r3, [r3, #4]
 800160e:	609a      	str	r2, [r3, #8]
 8001610:	4770      	bx	lr
 8001612:	bf00      	nop
 8001614:	f3af 8000 	nop.w
 8001618:	f3af 8000 	nop.w
 800161c:	f3af 8000 	nop.w

08001620 <test_005_003_setup.9247>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001620:	f640 73c8 	movw	r3, #4040	; 0xfc8
 8001624:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001628:	2200      	movs	r2, #0
 800162a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800162c:	605b      	str	r3, [r3, #4]
 800162e:	609a      	str	r2, [r3, #8]
 8001630:	4770      	bx	lr
 8001632:	bf00      	nop
 8001634:	f3af 8000 	nop.w
 8001638:	f3af 8000 	nop.w
 800163c:	f3af 8000 	nop.w

08001640 <test_005_002_setup.9249>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001640:	f640 73c8 	movw	r3, #4040	; 0xfc8
 8001644:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001648:	2200      	movs	r2, #0
 800164a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800164c:	605b      	str	r3, [r3, #4]
 800164e:	609a      	str	r2, [r3, #8]
 8001650:	4770      	bx	lr
 8001652:	bf00      	nop
 8001654:	f3af 8000 	nop.w
 8001658:	f3af 8000 	nop.w
 800165c:	f3af 8000 	nop.w

08001660 <test_005_001_setup.9251>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001660:	f640 73c8 	movw	r3, #4040	; 0xfc8
 8001664:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001668:	2201      	movs	r2, #1
 800166a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800166c:	605b      	str	r3, [r3, #4]
 800166e:	609a      	str	r2, [r3, #8]
 8001670:	4770      	bx	lr
 8001672:	bf00      	nop
 8001674:	f3af 8000 	nop.w
 8001678:	f3af 8000 	nop.w
 800167c:	f3af 8000 	nop.w

08001680 <VectorB0.4130>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001680:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001684:	691a      	ldr	r2, [r3, #16]
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001686:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800168a:	0792      	lsls	r2, r2, #30
 800168c:	d403      	bmi.n	8001696 <VectorB0.4130+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800168e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001692:	f7ff b9ed 	b.w	8000a70 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8001696:	2200      	movs	r2, #0
 8001698:	611a      	str	r2, [r3, #16]
 800169a:	2320      	movs	r3, #32
 800169c:	f383 8811 	msr	BASEPRI, r3
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 80016a0:	f241 24c0 	movw	r4, #4800	; 0x12c0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80016a4:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 80016a8:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80016ac:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80016ae:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 80016b0:	69e3      	ldr	r3, [r4, #28]
 80016b2:	b292      	uxth	r2, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80016b4:	1a16      	subs	r6, r2, r0
 80016b6:	8919      	ldrh	r1, [r3, #8]
 80016b8:	b2b6      	uxth	r6, r6
 80016ba:	428e      	cmp	r6, r1
 80016bc:	f104 071c 	add.w	r7, r4, #28
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;
 80016c0:	bf24      	itt	cs
 80016c2:	f04f 0800 	movcs.w	r8, #0
 80016c6:	2620      	movcs	r6, #32

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80016c8:	d31c      	bcc.n	8001704 <VectorB0.4130+0x84>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80016ca:	681a      	ldr	r2, [r3, #0]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 80016cc:	4401      	add	r1, r0
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80016ce:	42ba      	cmp	r2, r7
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 80016d0:	84e1      	strh	r1, [r4, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 80016d2:	68d9      	ldr	r1, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80016d4:	6057      	str	r7, [r2, #4]
    ch.vtlist.next = vtp->next;
 80016d6:	61e2      	str	r2, [r4, #28]
    fn = vtp->func;
    vtp->func = NULL;
 80016d8:	f8c3 800c 	str.w	r8, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80016dc:	bf08      	it	eq
 80016de:	f8c5 800c 	streq.w	r8, [r5, #12]
 80016e2:	f388 8811 	msr	BASEPRI, r8
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 80016e6:	6918      	ldr	r0, [r3, #16]
 80016e8:	4788      	blx	r1
 80016ea:	f386 8811 	msr	BASEPRI, r6
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80016ee:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80016f0:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 80016f2:	69e3      	ldr	r3, [r4, #28]
 80016f4:	b292      	uxth	r2, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80016f6:	ebc0 0c02 	rsb	ip, r0, r2
 80016fa:	8919      	ldrh	r1, [r3, #8]
 80016fc:	fa1f fc8c 	uxth.w	ip, ip
 8001700:	4561      	cmp	r1, ip
 8001702:	d9e2      	bls.n	80016ca <VectorB0.4130+0x4a>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001704:	42bb      	cmp	r3, r7
 8001706:	d00a      	beq.n	800171e <VectorB0.4130+0x9e>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8001708:	4401      	add	r1, r0
 800170a:	1a89      	subs	r1, r1, r2
 800170c:	b289      	uxth	r1, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800170e:	2901      	cmp	r1, #1
 8001710:	bf98      	it	ls
 8001712:	2102      	movls	r1, #2
  }
  port_timer_set_alarm(now + delta);
 8001714:	440a      	add	r2, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001716:	b292      	uxth	r2, r2
 8001718:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800171c:	635a      	str	r2, [r3, #52]	; 0x34
 800171e:	2300      	movs	r3, #0
 8001720:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8001724:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001728:	f7ff b9a2 	b.w	8000a70 <_port_irq_epilogue>
 800172c:	f3af 8000 	nop.w

08001730 <thread8.9480>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8001730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001734:	4680      	mov	r8, r0

  chMtxLock(&m2);
 8001736:	f640 0000 	movw	r0, #2048	; 0x800
 800173a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800173e:	f7ff fd27 	bl	8001190 <chMtxLock>
  chMtxLock(&m1);
 8001742:	f640 006c 	movw	r0, #2156	; 0x86c
 8001746:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800174a:	f7ff fd21 	bl	8001190 <chMtxLock>
 800174e:	2320      	movs	r3, #32
 8001750:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001754:	f241 26c0 	movw	r6, #4800	; 0x12c0
 8001758:	f2c2 0600 	movt	r6, #8192	; 0x2000
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->mtxlist;
 800175c:	69b3      	ldr	r3, [r6, #24]
 800175e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8001760:	4638      	mov	r0, r7
 8001762:	f7ff fc4d 	bl	8001000 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8001766:	f640 0364 	movw	r3, #2148	; 0x864
 800176a:	69b4      	ldr	r4, [r6, #24]
 800176c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001770:	461d      	mov	r5, r3
 8001772:	6263      	str	r3, [r4, #36]	; 0x24
 8001774:	e003      	b.n	800177e <thread8.9480+0x4e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001776:	6899      	ldr	r1, [r3, #8]
 8001778:	68a2      	ldr	r2, [r4, #8]
 800177a:	4291      	cmp	r1, r2
 800177c:	d302      	bcc.n	8001784 <thread8.9480+0x54>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800177e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001780:	42ab      	cmp	r3, r5
 8001782:	d1f8      	bne.n	8001776 <thread8.9480+0x46>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001784:	685a      	ldr	r2, [r3, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001786:	2007      	movs	r0, #7

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001788:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 800178a:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 800178c:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800178e:	605c      	str	r4, [r3, #4]
 8001790:	f7ff fb1e 	bl	8000dd0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001794:	69b3      	ldr	r3, [r6, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 8001796:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001798:	3301      	adds	r3, #1
 800179a:	d002      	beq.n	80017a2 <thread8.9480+0x72>
    chMtxLockS(mp);
 800179c:	4638      	mov	r0, r7
 800179e:	f7ff fc8f 	bl	80010c0 <chMtxLockS>
 80017a2:	2300      	movs	r3, #0
 80017a4:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 80017a8:	f898 0000 	ldrb.w	r0, [r8]
 80017ac:	f7fe ff00 	bl	80005b0 <test_emit_token>
  chMtxUnlock(&m1);
 80017b0:	f640 006c 	movw	r0, #2156	; 0x86c
 80017b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80017b8:	f7ff fc4a 	bl	8001050 <chMtxUnlock>
  chMtxUnlock(&m2);
}
 80017bc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 80017c0:	f640 0000 	movw	r0, #2048	; 0x800
 80017c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80017c8:	f7ff bc42 	b.w	8001050 <chMtxUnlock>
 80017cc:	f3af 8000 	nop.w

080017d0 <test_001_002_execute.8617>:
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the configuration options settings.
 * .
 */

static void test_001_002_execute(void) {
 80017d0:	b538      	push	{r3, r4, r5, lr}

  /* [1.2.1] Prints the configuration options settings.*/
  test_set_step(1);
  {
    test_print("--- CH_CFG_ST_RESOLUTION:      ");
 80017d2:	f247 1008 	movw	r0, #28936	; 0x7108
 */

static void test_001_002_execute(void) {

  /* [1.2.1] Prints the configuration options settings.*/
  test_set_step(1);
 80017d6:	f241 3330 	movw	r3, #4912	; 0x1330
 80017da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017de:	2501      	movs	r5, #1
  {
    test_print("--- CH_CFG_ST_RESOLUTION:      ");
 80017e0:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(CH_CFG_ST_RESOLUTION);
    test_println("");
 80017e4:	f247 74e0 	movw	r4, #30688	; 0x77e0
 */

static void test_001_002_execute(void) {

  /* [1.2.1] Prints the configuration options settings.*/
  test_set_step(1);
 80017e8:	601d      	str	r5, [r3, #0]
  {
    test_print("--- CH_CFG_ST_RESOLUTION:      ");
    test_printn(CH_CFG_ST_RESOLUTION);
    test_println("");
 80017ea:	f6c0 0400 	movt	r4, #2048	; 0x800
static void test_001_002_execute(void) {

  /* [1.2.1] Prints the configuration options settings.*/
  test_set_step(1);
  {
    test_print("--- CH_CFG_ST_RESOLUTION:      ");
 80017ee:	f7fe ff3f 	bl	8000670 <test_print>
    test_printn(CH_CFG_ST_RESOLUTION);
 80017f2:	2010      	movs	r0, #16
 80017f4:	f7ff f814 	bl	8000820 <test_printn>
    test_println("");
 80017f8:	4620      	mov	r0, r4
 80017fa:	f7fe ff19 	bl	8000630 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:       ");
 80017fe:	f247 1028 	movw	r0, #28968	; 0x7128
 8001802:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001806:	f7fe ff33 	bl	8000670 <test_print>
    test_printn(CH_CFG_ST_FREQUENCY);
 800180a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800180e:	f7ff f807 	bl	8000820 <test_printn>
    test_println("");
 8001812:	4620      	mov	r0, r4
 8001814:	f7fe ff0c 	bl	8000630 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:       ");
 8001818:	f247 1048 	movw	r0, #29000	; 0x7148
 800181c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001820:	f7fe ff26 	bl	8000670 <test_print>
    test_printn(CH_CFG_ST_TIMEDELTA);
 8001824:	2002      	movs	r0, #2
 8001826:	f7fe fffb 	bl	8000820 <test_printn>
    test_println("");
 800182a:	4620      	mov	r0, r4
 800182c:	f7fe ff00 	bl	8000630 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:       ");
 8001830:	f247 1068 	movw	r0, #29032	; 0x7168
 8001834:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001838:	f7fe ff1a 	bl	8000670 <test_print>
 800183c:	f7fe ffe0 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_TIME_QUANTUM);
    test_println("");
 8001840:	4620      	mov	r0, r4
 8001842:	f7fe fef5 	bl	8000630 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:       ");
 8001846:	f247 1088 	movw	r0, #29064	; 0x7188
 800184a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800184e:	f7fe ff0f 	bl	8000670 <test_print>
 8001852:	f7fe ffd5 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_MEMCORE_SIZE);
    test_println("");
 8001856:	4620      	mov	r0, r4
 8001858:	f7fe feea 	bl	8000630 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:     ");
 800185c:	f247 10a8 	movw	r0, #29096	; 0x71a8
 8001860:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001864:	f7fe ff04 	bl	8000670 <test_print>
 8001868:	f7fe ffca 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_NO_IDLE_THREAD);
    test_println("");
 800186c:	4620      	mov	r0, r4
 800186e:	f7fe fedf 	bl	8000630 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:     ");
 8001872:	f247 10c8 	movw	r0, #29128	; 0x71c8
 8001876:	f6c0 0000 	movt	r0, #2048	; 0x800
 800187a:	f7fe fef9 	bl	8000670 <test_print>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
 800187e:	4628      	mov	r0, r5
 8001880:	f7fe ffce 	bl	8000820 <test_printn>
    test_println("");
 8001884:	4620      	mov	r0, r4
 8001886:	f7fe fed3 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_TM:             ");
 800188a:	f247 10e8 	movw	r0, #29160	; 0x71e8
 800188e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001892:	f7fe feed 	bl	8000670 <test_print>
 8001896:	f7fe ffb3 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_USE_TM);
    test_println("");
 800189a:	4620      	mov	r0, r4
 800189c:	f7fe fec8 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:       ");
 80018a0:	f247 2008 	movw	r0, #29192	; 0x7208
 80018a4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80018a8:	f7fe fee2 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_REGISTRY);
 80018ac:	4628      	mov	r0, r5
 80018ae:	f7fe ffb7 	bl	8000820 <test_printn>
    test_println("");
 80018b2:	4620      	mov	r0, r4
 80018b4:	f7fe febc 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:       ");
 80018b8:	f247 2028 	movw	r0, #29224	; 0x7228
 80018bc:	f6c0 0000 	movt	r0, #2048	; 0x800
 80018c0:	f7fe fed6 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_WAITEXIT);
 80018c4:	4628      	mov	r0, r5
 80018c6:	f7fe ffab 	bl	8000820 <test_printn>
    test_println("");
 80018ca:	4620      	mov	r0, r4
 80018cc:	f7fe feb0 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:     ");
 80018d0:	f247 2048 	movw	r0, #29256	; 0x7248
 80018d4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80018d8:	f7fe feca 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES);
 80018dc:	4628      	mov	r0, r5
 80018de:	f7fe ff9f 	bl	8000820 <test_printn>
    test_println("");
 80018e2:	4620      	mov	r0, r4
 80018e4:	f7fe fea4 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRI: ");
 80018e8:	f247 2068 	movw	r0, #29288	; 0x7268
 80018ec:	f6c0 0000 	movt	r0, #2048	; 0x800
 80018f0:	f7fe febe 	bl	8000670 <test_print>
 80018f4:	f7fe ff84 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
    test_println("");
 80018f8:	4620      	mov	r0, r4
 80018fa:	f7fe fe99 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:        ");
 80018fe:	f247 2088 	movw	r0, #29320	; 0x7288
 8001902:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001906:	f7fe feb3 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_MUTEXES);
 800190a:	4628      	mov	r0, r5
 800190c:	f7fe ff88 	bl	8000820 <test_printn>
    test_println("");
 8001910:	4620      	mov	r0, r4
 8001912:	f7fe fe8d 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURS: ");
 8001916:	f247 20a8 	movw	r0, #29352	; 0x72a8
 800191a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800191e:	f7fe fea7 	bl	8000670 <test_print>
 8001922:	f7fe ff6d 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
    test_println("");
 8001926:	4620      	mov	r0, r4
 8001928:	f7fe fe82 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:       ");
 800192c:	f247 20c8 	movw	r0, #29384	; 0x72c8
 8001930:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001934:	f7fe fe9c 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_CONDVARS);
 8001938:	4628      	mov	r0, r5
 800193a:	f7fe ff71 	bl	8000820 <test_printn>
    test_println("");
 800193e:	4620      	mov	r0, r4
 8001940:	f7fe fe76 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEO: ");
 8001944:	f247 20e8 	movw	r0, #29416	; 0x72e8
 8001948:	f6c0 0000 	movt	r0, #2048	; 0x800
 800194c:	f7fe fe90 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
 8001950:	4628      	mov	r0, r5
 8001952:	f7fe ff65 	bl	8000820 <test_printn>
    test_println("");
 8001956:	4620      	mov	r0, r4
 8001958:	f7fe fe6a 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:         ");
 800195c:	f247 3008 	movw	r0, #29448	; 0x7308
 8001960:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001964:	f7fe fe84 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_EVENTS);
 8001968:	4628      	mov	r0, r5
 800196a:	f7fe ff59 	bl	8000820 <test_printn>
    test_println("");
 800196e:	4620      	mov	r0, r4
 8001970:	f7fe fe5e 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT: ");
 8001974:	f247 3028 	movw	r0, #29480	; 0x7328
 8001978:	f6c0 0000 	movt	r0, #2048	; 0x800
 800197c:	f7fe fe78 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
 8001980:	4628      	mov	r0, r5
 8001982:	f7fe ff4d 	bl	8000820 <test_printn>
    test_println("");
 8001986:	4620      	mov	r0, r4
 8001988:	f7fe fe52 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:       ");
 800198c:	f247 3048 	movw	r0, #29512	; 0x7348
 8001990:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001994:	f7fe fe6c 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_MESSAGES);
 8001998:	4628      	mov	r0, r5
 800199a:	f7fe ff41 	bl	8000820 <test_printn>
    test_println("");
 800199e:	4620      	mov	r0, r4
 80019a0:	f7fe fe46 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRI:   ");
 80019a4:	f247 3068 	movw	r0, #29544	; 0x7368
 80019a8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80019ac:	f7fe fe60 	bl	8000670 <test_print>
 80019b0:	f7fe ff26 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
    test_println("");
 80019b4:	4620      	mov	r0, r4
 80019b6:	f7fe fe3b 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:      ");
 80019ba:	f247 3088 	movw	r0, #29576	; 0x7388
 80019be:	f6c0 0000 	movt	r0, #2048	; 0x800
 80019c2:	f7fe fe55 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_MAILBOXES);
 80019c6:	4628      	mov	r0, r5
 80019c8:	f7fe ff2a 	bl	8000820 <test_printn>
    test_println("");
 80019cc:	4620      	mov	r0, r4
 80019ce:	f7fe fe2f 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:        ");
 80019d2:	f247 30a8 	movw	r0, #29608	; 0x73a8
 80019d6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80019da:	f7fe fe49 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_MEMCORE);
 80019de:	4628      	mov	r0, r5
 80019e0:	f7fe ff1e 	bl	8000820 <test_printn>
    test_println("");
 80019e4:	4620      	mov	r0, r4
 80019e6:	f7fe fe23 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_HEAP:           ");
 80019ea:	f247 30c8 	movw	r0, #29640	; 0x73c8
 80019ee:	f6c0 0000 	movt	r0, #2048	; 0x800
 80019f2:	f7fe fe3d 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_HEAP);
 80019f6:	4628      	mov	r0, r5
 80019f8:	f7fe ff12 	bl	8000820 <test_printn>
    test_println("");
 80019fc:	4620      	mov	r0, r4
 80019fe:	f7fe fe17 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:       ");
 8001a02:	f247 30e8 	movw	r0, #29672	; 0x73e8
 8001a06:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a0a:	f7fe fe31 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_MEMPOOLS);
 8001a0e:	4628      	mov	r0, r5
 8001a10:	f7fe ff06 	bl	8000820 <test_printn>
    test_println("");
 8001a14:	4620      	mov	r0, r4
 8001a16:	f7fe fe0b 	bl	8000630 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:        ");
 8001a1a:	f247 4008 	movw	r0, #29704	; 0x7408
 8001a1e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a22:	f7fe fe25 	bl	8000670 <test_print>
    test_printn(CH_CFG_USE_DYNAMIC);
 8001a26:	4628      	mov	r0, r5
 8001a28:	f7fe fefa 	bl	8000820 <test_printn>
    test_println("");
 8001a2c:	4620      	mov	r0, r4
 8001a2e:	f7fe fdff 	bl	8000630 <test_println>
    test_print("--- CH_DBG_STATISTICS:         ");
 8001a32:	f247 4028 	movw	r0, #29736	; 0x7428
 8001a36:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a3a:	f7fe fe19 	bl	8000670 <test_print>
 8001a3e:	f7fe fedf 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_STATISTICS);
    test_println("");
 8001a42:	4620      	mov	r0, r4
 8001a44:	f7fe fdf4 	bl	8000630 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK: ");
 8001a48:	f247 4048 	movw	r0, #29768	; 0x7448
 8001a4c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a50:	f7fe fe0e 	bl	8000670 <test_print>
 8001a54:	f7fe fed4 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
    test_println("");
 8001a58:	4620      	mov	r0, r4
 8001a5a:	f7fe fde9 	bl	8000630 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:      ");
 8001a5e:	f247 4068 	movw	r0, #29800	; 0x7468
 8001a62:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a66:	f7fe fe03 	bl	8000670 <test_print>
 8001a6a:	f7fe fec9 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_ENABLE_CHECKS);
    test_println("");
 8001a6e:	4620      	mov	r0, r4
 8001a70:	f7fe fdde 	bl	8000630 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:     ");
 8001a74:	f247 4088 	movw	r0, #29832	; 0x7488
 8001a78:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a7c:	f7fe fdf8 	bl	8000670 <test_print>
 8001a80:	f7fe febe 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_ENABLE_ASSERTS);
    test_println("");
 8001a84:	4620      	mov	r0, r4
 8001a86:	f7fe fdd3 	bl	8000630 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:         ");
 8001a8a:	f247 40a8 	movw	r0, #29864	; 0x74a8
 8001a8e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a92:	f7fe fded 	bl	8000670 <test_print>
    test_printn(CH_DBG_TRACE_MASK);
 8001a96:	20ff      	movs	r0, #255	; 0xff
 8001a98:	f7fe fec2 	bl	8000820 <test_printn>
    test_println("");
 8001a9c:	4620      	mov	r0, r4
 8001a9e:	f7fe fdc7 	bl	8000630 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:  ");
 8001aa2:	f247 40c8 	movw	r0, #29896	; 0x74c8
 8001aa6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001aaa:	f7fe fde1 	bl	8000670 <test_print>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
 8001aae:	2080      	movs	r0, #128	; 0x80
 8001ab0:	f7fe feb6 	bl	8000820 <test_printn>
    test_println("");
 8001ab4:	4620      	mov	r0, r4
 8001ab6:	f7fe fdbb 	bl	8000630 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK: ");
 8001aba:	f247 40e8 	movw	r0, #29928	; 0x74e8
 8001abe:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001ac2:	f7fe fdd5 	bl	8000670 <test_print>
 8001ac6:	f7fe fe9b 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
    test_println("");
 8001aca:	4620      	mov	r0, r4
 8001acc:	f7fe fdb0 	bl	8000630 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:       ");
 8001ad0:	f247 5008 	movw	r0, #29960	; 0x7508
 8001ad4:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001ad8:	f7fe fdca 	bl	8000670 <test_print>
 8001adc:	f7fe fe90 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_FILL_THREADS);
    test_println("");
 8001ae0:	4620      	mov	r0, r4
 8001ae2:	f7fe fda5 	bl	8000630 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:  ");
 8001ae6:	f247 5028 	movw	r0, #29992	; 0x7528
 8001aea:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001aee:	f7fe fdbf 	bl	8000670 <test_print>
 8001af2:	f7fe fe85 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_DBG_THREADS_PROFILING);
    test_println("");
 8001af6:	4620      	mov	r0, r4
  }
}
 8001af8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_print("--- CH_DBG_FILL_THREADS:       ");
    test_printn(CH_DBG_FILL_THREADS);
    test_println("");
    test_print("--- CH_DBG_THREADS_PROFILING:  ");
    test_printn(CH_DBG_THREADS_PROFILING);
    test_println("");
 8001afc:	f7fe bd98 	b.w	8000630 <test_println>

08001b00 <test_001_001_execute.8619>:
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void test_001_001_execute(void) {
 8001b00:	b538      	push	{r3, r4, r5, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
  {
    test_println("--- Product:                   ChibiOS/RT");
 8001b02:	f247 5048 	movw	r0, #30024	; 0x7548
 */

static void test_001_001_execute(void) {

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8001b06:	f241 3330 	movw	r3, #4912	; 0x1330
 8001b0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b0e:	2501      	movs	r5, #1
  {
    test_println("--- Product:                   ChibiOS/RT");
 8001b10:	f6c0 0000 	movt	r0, #2048	; 0x800
 */

static void test_001_001_execute(void) {

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8001b14:	601d      	str	r5, [r3, #0]
  {
    test_println("--- Product:                   ChibiOS/RT");
 8001b16:	f7fe fd8b 	bl	8000630 <test_println>
    test_print("--- Stable Flag:               ");
 8001b1a:	f247 5074 	movw	r0, #30068	; 0x7574
 8001b1e:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_printn(CH_KERNEL_STABLE);
    test_println("");
 8001b22:	f247 74e0 	movw	r4, #30688	; 0x77e0
 8001b26:	f6c0 0400 	movt	r4, #2048	; 0x800

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
  {
    test_println("--- Product:                   ChibiOS/RT");
    test_print("--- Stable Flag:               ");
 8001b2a:	f7fe fda1 	bl	8000670 <test_print>
    test_printn(CH_KERNEL_STABLE);
 8001b2e:	4628      	mov	r0, r5
 8001b30:	f7fe fe76 	bl	8000820 <test_printn>
    test_println("");
 8001b34:	4620      	mov	r0, r4
 8001b36:	f7fe fd7b 	bl	8000630 <test_println>
    test_print("--- Version String:            ");
 8001b3a:	f247 5094 	movw	r0, #30100	; 0x7594
 8001b3e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001b42:	f7fe fd95 	bl	8000670 <test_print>
    test_println(CH_KERNEL_VERSION);
 8001b46:	f247 50b4 	movw	r0, #30132	; 0x75b4
 8001b4a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001b4e:	f7fe fd6f 	bl	8000630 <test_println>
    test_print("--- Major Number:              ");
 8001b52:	f247 50bc 	movw	r0, #30140	; 0x75bc
 8001b56:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001b5a:	f7fe fd89 	bl	8000670 <test_print>
    test_printn(CH_KERNEL_MAJOR);
 8001b5e:	2004      	movs	r0, #4
 8001b60:	f7fe fe5e 	bl	8000820 <test_printn>
    test_println("");
 8001b64:	4620      	mov	r0, r4
 8001b66:	f7fe fd63 	bl	8000630 <test_println>
    test_print("--- Minor Number:              ");
 8001b6a:	f247 50dc 	movw	r0, #30172	; 0x75dc
 8001b6e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001b72:	f7fe fd7d 	bl	8000670 <test_print>
 8001b76:	f7fe fe43 	bl	8000800 <test_printn.part.0.8336>
    test_printn(CH_KERNEL_MINOR);
    test_println("");
 8001b7a:	4620      	mov	r0, r4
 8001b7c:	f7fe fd58 	bl	8000630 <test_println>
    test_print("--- Patch Number:              ");
 8001b80:	f247 50fc 	movw	r0, #30204	; 0x75fc
 8001b84:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001b88:	f7fe fd72 	bl	8000670 <test_print>
    test_printn(CH_KERNEL_PATCH);
 8001b8c:	2002      	movs	r0, #2
 8001b8e:	f7fe fe47 	bl	8000820 <test_printn>
    test_println("");
 8001b92:	4620      	mov	r0, r4
  }
}
 8001b94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_print("--- Minor Number:              ");
    test_printn(CH_KERNEL_MINOR);
    test_println("");
    test_print("--- Patch Number:              ");
    test_printn(CH_KERNEL_PATCH);
    test_println("");
 8001b98:	f7fe bd4a 	b.w	8000630 <test_println>
 8001b9c:	f3af 8000 	nop.w

08001ba0 <test_013_009_execute.10711>:
 *   one-second time window.
 * - [13.9.2] The score is printed.
 * .
 */

static void test_013_009_execute(void) {
 8001ba0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;

  /* [13.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8001ba4:	f241 3830 	movw	r8, #4912	; 0x1330
 8001ba8:	2301      	movs	r3, #1
 8001baa:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8001bae:	f8c8 3000 	str.w	r3, [r8]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8001bb2:	f003 f9dd 	bl	8004f70 <test_wait_tick>
     one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8001bb6:	2400      	movs	r4, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8001bb8:	4627      	mov	r7, r4
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8001bba:	4606      	mov	r6, r0
 8001bbc:	2520      	movs	r5, #32
 8001bbe:	f385 8811 	msr	BASEPRI, r5
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8001bc2:	f640 00cc 	movw	r0, #2252	; 0x8cc
 8001bc6:	f240 2281 	movw	r2, #641	; 0x281
 8001bca:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001bce:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001bd2:	2101      	movs	r1, #1
 8001bd4:	2300      	movs	r3, #0
 8001bd6:	f003 f8cb 	bl	8004d70 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8001bda:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8001bde:	f240 2281 	movw	r2, #641	; 0x281
 8001be2:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001be6:	f242 7110 	movw	r1, #10000	; 0x2710
 8001bea:	2300      	movs	r3, #0
 8001bec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001bf0:	f003 f8be 	bl	8004d70 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8001bf4:	f640 00cc 	movw	r0, #2252	; 0x8cc
 8001bf8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001bfc:	f7fe fef8 	bl	80009f0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8001c00:	f640 00b8 	movw	r0, #2232	; 0x8b8
 8001c04:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001c08:	f7fe fef2 	bl	80009f0 <chVTDoResetI>
 8001c0c:	f387 8811 	msr	BASEPRI, r7
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001c10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001c14:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      chSysUnlock();
      n++;
 8001c16:	3401      	adds	r4, #1
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001c18:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8001c1a:	b29b      	uxth	r3, r3
 8001c1c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8001c20:	d3cd      	bcc.n	8001bbe <test_013_009_execute.10711+0x1e>
  }

  /* [13.9.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
 8001c22:	f247 601c 	movw	r0, #30236	; 0x761c
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.9.2] The score is printed.*/
  test_set_step(2);
 8001c26:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8001c28:	f6c0 0000 	movt	r0, #2048	; 0x800
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.9.2] The score is printed.*/
  test_set_step(2);
 8001c2c:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 8001c30:	f7fe fd1e 	bl	8000670 <test_print>
    test_printn(n * 2);
 8001c34:	0060      	lsls	r0, r4, #1
 8001c36:	f7fe fdf3 	bl	8000820 <test_printn>
    test_println(" timers/S");
  }
}
 8001c3a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [13.9.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" timers/S");
 8001c3e:	f247 602c 	movw	r0, #30252	; 0x762c
 8001c42:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001c46:	f7fe bcf3 	b.w	8000630 <test_println>
 8001c4a:	bf00      	nop
 8001c4c:	f3af 8000 	nop.w

08001c50 <Thread2.11005>:

/*
 * Blinker thread #2.
 */
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
 8001c50:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8001c52:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8001c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c5a:	699a      	ldr	r2, [r3, #24]
 8001c5c:	f247 6338 	movw	r3, #30264	; 0x7638
 8001c60:	f6c0 0300 	movt	r3, #2048	; 0x800

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOC, GPIOC_LED3);
 8001c64:	f44f 5480 	mov.w	r4, #4096	; 0x1000
 8001c68:	f44f 7500 	mov.w	r5, #512	; 0x200
 8001c6c:	6193      	str	r3, [r2, #24]
 8001c6e:	f2c4 0401 	movt	r4, #16385	; 0x4001
 8001c72:	462e      	mov	r6, r5
 8001c74:	6126      	str	r6, [r4, #16]
    chThdSleepMilliseconds(500);
 8001c76:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001c7a:	f003 f8f9 	bl	8004e70 <chThdSleep>
    palClearPad(GPIOC, GPIOC_LED3);
 8001c7e:	6165      	str	r5, [r4, #20]
    chThdSleepMilliseconds(500);
 8001c80:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001c84:	f003 f8f4 	bl	8004e70 <chThdSleep>
 8001c88:	e7f4      	b.n	8001c74 <Thread2.11005+0x24>
 8001c8a:	bf00      	nop
 8001c8c:	f3af 8000 	nop.w

08001c90 <Thread1.11008>:

/*
 * Blinker thread #1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8001c90:	b508      	push	{r3, lr}
 8001c92:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8001c96:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c9a:	699a      	ldr	r2, [r3, #24]
 8001c9c:	f247 6338 	movw	r3, #30264	; 0x7638
 8001ca0:	f6c0 0300 	movt	r3, #2048	; 0x800

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOC, GPIOC_LED4);
 8001ca4:	f44f 5480 	mov.w	r4, #4096	; 0x1000
 8001ca8:	f44f 7580 	mov.w	r5, #256	; 0x100
 8001cac:	6193      	str	r3, [r2, #24]
 8001cae:	f2c4 0401 	movt	r4, #16385	; 0x4001
 8001cb2:	462e      	mov	r6, r5
 8001cb4:	6126      	str	r6, [r4, #16]
    chThdSleepMilliseconds(250);
 8001cb6:	20fa      	movs	r0, #250	; 0xfa
 8001cb8:	f003 f8da 	bl	8004e70 <chThdSleep>
    palClearPad(GPIOC, GPIOC_LED4);
 8001cbc:	6165      	str	r5, [r4, #20]
    chThdSleepMilliseconds(250);
 8001cbe:	20fa      	movs	r0, #250	; 0xfa
 8001cc0:	f003 f8d6 	bl	8004e70 <chThdSleep>
 8001cc4:	e7f6      	b.n	8001cb4 <Thread1.11008+0x24>
 8001cc6:	bf00      	nop
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <thread4A.9489.4247>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 8001cd0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
 8001cd2:	f640 046c 	movw	r4, #2156	; 0x86c
 8001cd6:	f2c2 0400 	movt	r4, #8192	; 0x2000
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8001cda:	2032      	movs	r0, #50	; 0x32
 8001cdc:	f003 f8c8 	bl	8004e70 <chThdSleep>
  chMtxLock(&m1);
 8001ce0:	4620      	mov	r0, r4
 8001ce2:	f7ff fa55 	bl	8001190 <chMtxLock>
  chMtxUnlock(&m1);
 8001ce6:	4620      	mov	r0, r4
}
 8001ce8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 8001cec:	f7ff b9b0 	b.w	8001050 <chMtxUnlock>

08001cf0 <evt_thread3.9844>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 8001cf0:	b510      	push	{r4, lr}
 8001cf2:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8001cf4:	2032      	movs	r0, #50	; 0x32
 8001cf6:	f003 f8bb 	bl	8004e70 <chThdSleep>
 8001cfa:	2320      	movs	r3, #32
 8001cfc:	f383 8811 	msr	BASEPRI, r3
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8001d00:	2101      	movs	r1, #1
 8001d02:	4620      	mov	r0, r4
 8001d04:	f7ff f94c 	bl	8000fa0 <chEvtSignalI>
  chSchRescheduleS();
 8001d08:	f7fe ff6a 	bl	8000be0 <chSchRescheduleS>
 8001d0c:	2300      	movs	r3, #0
 8001d0e:	f383 8811 	msr	BASEPRI, r3
 8001d12:	bd10      	pop	{r4, pc}
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <thread4B.9486.4250>:
}

static THD_FUNCTION(thread4B, p) {
 8001d20:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 8001d22:	2096      	movs	r0, #150	; 0x96
 8001d24:	f003 f8a4 	bl	8004e70 <chThdSleep>
 8001d28:	2320      	movs	r3, #32
 8001d2a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8001d2e:	f640 0400 	movw	r4, #2048	; 0x800
 8001d32:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001d36:	4620      	mov	r0, r4
 8001d38:	f7ff f9c2 	bl	80010c0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8001d3c:	4620      	mov	r0, r4
 8001d3e:	f7ff f95f 	bl	8001000 <chMtxUnlockS>
  chSchRescheduleS();
 8001d42:	f7fe ff4d 	bl	8000be0 <chSchRescheduleS>
 8001d46:	2300      	movs	r3, #0
 8001d48:	f383 8811 	msr	BASEPRI, r3
 8001d4c:	bd10      	pop	{r4, pc}
 8001d4e:	bf00      	nop

08001d50 <test_006_004_execute.9516>:

static void test_006_004_teardown(void) {
  test_wait_threads();
}

static void test_006_004_execute(void) {
 8001d50:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001d54:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8001d58:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001d5c:	69a3      	ldr	r3, [r4, #24]
    pa = p + 1;
    pb = p + 2;
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8001d5e:	f241 3530 	movw	r5, #4912	; 0x1330
 8001d62:	689f      	ldr	r7, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8001d64:	f640 1050 	movw	r0, #2384	; 0x950
  /* [6.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
 8001d68:	f107 0801 	add.w	r8, r7, #1
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8001d6c:	f641 42d1 	movw	r2, #7377	; 0x1cd1
 8001d70:	f247 6340 	movw	r3, #30272	; 0x7640
 8001d74:	4641      	mov	r1, r8
    pa = p + 1;
    pb = p + 2;
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8001d76:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8001d7a:	2602      	movs	r6, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8001d7c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001d80:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001d84:	f2c2 0000 	movt	r0, #8192	; 0x2000
    pa = p + 1;
    pb = p + 2;
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8001d88:	602e      	str	r6, [r5, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8001d8a:	f003 fdc1 	bl	8005910 <chThdCreateStatic.constprop.52>
 8001d8e:	f640 76d4 	movw	r6, #4052	; 0xfd4
 8001d92:	f2c2 0600 	movt	r6, #8192	; 0x2000
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
    pb = p + 2;
 8001d96:	f107 0902 	add.w	r9, r7, #2

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8001d9a:	f641 5221 	movw	r2, #7457	; 0x1d21
 8001d9e:	f247 6344 	movw	r3, #30276	; 0x7644
 8001da2:	4649      	mov	r1, r9
 8001da4:	f6c0 0200 	movt	r2, #2048	; 0x800
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8001da8:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8001daa:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001dae:	4842      	ldr	r0, [pc, #264]	; (8001eb8 <test_006_004_execute.9516+0x168>)
 8001db0:	f003 fdae 	bl	8005910 <chThdCreateStatic.constprop.52>
 8001db4:	6070      	str	r0, [r6, #4]
  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
  {
    chMtxLock(&m1);
 8001db6:	f640 006c 	movw	r0, #2156	; 0x86c
  }

  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8001dba:	2303      	movs	r3, #3
  {
    chMtxLock(&m1);
 8001dbc:	f2c2 0000 	movt	r0, #8192	; 0x2000
  }

  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8001dc0:	602b      	str	r3, [r5, #0]
  {
    chMtxLock(&m1);
 8001dc2:	f7ff f9e5 	bl	8001190 <chMtxLock>
 8001dc6:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8001dc8:	f247 6148 	movw	r1, #30280	; 0x7648
 8001dcc:	6898      	ldr	r0, [r3, #8]
 8001dce:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001dd2:	1a3a      	subs	r2, r7, r0
 8001dd4:	4250      	negs	r0, r2
 8001dd6:	4150      	adcs	r0, r2
 8001dd8:	f7fe fc92 	bl	8000700 <_test_assert>
 8001ddc:	b108      	cbz	r0, 8001de2 <test_006_004_execute.9516+0x92>
 8001dde:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8001de2:	2304      	movs	r3, #4
  {
    chThdSleepMilliseconds(100);
 8001de4:	2064      	movs	r0, #100	; 0x64
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 8001de6:	602b      	str	r3, [r5, #0]
  {
    chThdSleepMilliseconds(100);
 8001de8:	f003 f842 	bl	8004e70 <chThdSleep>
 8001dec:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8001dee:	f247 6148 	movw	r1, #30280	; 0x7648
 8001df2:	6898      	ldr	r0, [r3, #8]
 8001df4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001df8:	ebb8 0300 	subs.w	r3, r8, r0
 8001dfc:	4258      	negs	r0, r3
 8001dfe:	4158      	adcs	r0, r3
 8001e00:	f7fe fc7e 	bl	8000700 <_test_assert>
 8001e04:	2800      	cmp	r0, #0
 8001e06:	d1ea      	bne.n	8001dde <test_006_004_execute.9516+0x8e>
  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
  {
    chMtxLock(&m2);
 8001e08:	f640 0000 	movw	r0, #2048	; 0x800
  }

  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 8001e0c:	2305      	movs	r3, #5
  {
    chMtxLock(&m2);
 8001e0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
  }

  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 8001e12:	602b      	str	r3, [r5, #0]
  {
    chMtxLock(&m2);
 8001e14:	f7ff f9bc 	bl	8001190 <chMtxLock>
 8001e18:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8001e1a:	f247 6148 	movw	r1, #30280	; 0x7648
 8001e1e:	6898      	ldr	r0, [r3, #8]
 8001e20:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001e24:	ebb8 0c00 	subs.w	ip, r8, r0
 8001e28:	f1dc 0000 	rsbs	r0, ip, #0
 8001e2c:	eb50 000c 	adcs.w	r0, r0, ip
 8001e30:	f7fe fc66 	bl	8000700 <_test_assert>
 8001e34:	2800      	cmp	r0, #0
 8001e36:	d1d2      	bne.n	8001dde <test_006_004_execute.9516+0x8e>
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8001e38:	2306      	movs	r3, #6
  {
    chThdSleepMilliseconds(100);
 8001e3a:	2064      	movs	r0, #100	; 0x64
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8001e3c:	602b      	str	r3, [r5, #0]
  {
    chThdSleepMilliseconds(100);
 8001e3e:	f003 f817 	bl	8004e70 <chThdSleep>
 8001e42:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8001e44:	f247 6148 	movw	r1, #30280	; 0x7648
 8001e48:	6898      	ldr	r0, [r3, #8]
 8001e4a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001e4e:	ebb9 0e00 	subs.w	lr, r9, r0
 8001e52:	f1de 0000 	rsbs	r0, lr, #0
 8001e56:	eb50 000e 	adcs.w	r0, r0, lr
 8001e5a:	f7fe fc51 	bl	8000700 <_test_assert>
 8001e5e:	2800      	cmp	r0, #0
 8001e60:	d1bd      	bne.n	8001dde <test_006_004_execute.9516+0x8e>
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
  {
    chMtxUnlock(&m2);
 8001e62:	f640 0000 	movw	r0, #2048	; 0x800
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8001e66:	2307      	movs	r3, #7
  {
    chMtxUnlock(&m2);
 8001e68:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8001e6c:	602b      	str	r3, [r5, #0]
  {
    chMtxUnlock(&m2);
 8001e6e:	f7ff f8ef 	bl	8001050 <chMtxUnlock>
 8001e72:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8001e74:	f247 6148 	movw	r1, #30280	; 0x7648
 8001e78:	6898      	ldr	r0, [r3, #8]
 8001e7a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001e7e:	ebb8 0600 	subs.w	r6, r8, r0
 8001e82:	4270      	negs	r0, r6
 8001e84:	4170      	adcs	r0, r6
 8001e86:	f7fe fc3b 	bl	8000700 <_test_assert>
 8001e8a:	2800      	cmp	r0, #0
 8001e8c:	d1a7      	bne.n	8001dde <test_006_004_execute.9516+0x8e>
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
  {
    chMtxUnlock(&m1);
 8001e8e:	f640 006c 	movw	r0, #2156	; 0x86c
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8001e92:	2308      	movs	r3, #8
  {
    chMtxUnlock(&m1);
 8001e94:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8001e98:	602b      	str	r3, [r5, #0]
  {
    chMtxUnlock(&m1);
 8001e9a:	f7ff f8d9 	bl	8001050 <chMtxUnlock>
 8001e9e:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8001ea0:	f247 6148 	movw	r1, #30280	; 0x7648
 8001ea4:	6898      	ldr	r0, [r3, #8]
 8001ea6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001eaa:	1a3c      	subs	r4, r7, r0
 8001eac:	4260      	negs	r0, r4
 8001eae:	4160      	adcs	r0, r4
  }
}
 8001eb0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
  {
    chMtxUnlock(&m1);
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8001eb4:	f7fe bc24 	b.w	8000700 <_test_assert>
 8001eb8:	20000a98 	.word	0x20000a98
 8001ebc:	f3af 8000 	nop.w

08001ec0 <thread2.9240>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {
 8001ec0:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8001ec2:	2032      	movs	r0, #50	; 0x32
 8001ec4:	f002 ffd4 	bl	8004e70 <chThdSleep>
 8001ec8:	2320      	movs	r3, #32
 8001eca:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8001ece:	f640 70c8 	movw	r0, #4040	; 0xfc8
 8001ed2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ed6:	f7ff fa2b 	bl	8001330 <chSemSignalI>
  chSchRescheduleS();
 8001eda:	f7fe fe81 	bl	8000be0 <chSchRescheduleS>
 8001ede:	2300      	movs	r3, #0
 8001ee0:	f383 8811 	msr	BASEPRI, r3
 8001ee4:	bd08      	pop	{r3, pc}
 8001ee6:	bf00      	nop
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <chSemWaitTimeoutS.part.1.5425>:
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8001ef0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8001ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ef8:	699b      	ldr	r3, [r3, #24]
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001efa:	b410      	push	{r4}
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8001efc:	6258      	str	r0, [r3, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8001efe:	6844      	ldr	r4, [r0, #4]
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001f00:	4602      	mov	r2, r0
 8001f02:	e883 0014 	stmia.w	r3, {r2, r4}
      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001f06:	2005      	movs	r0, #5
  tp->queue.prev->queue.next = tp;
 8001f08:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8001f0a:	6053      	str	r3, [r2, #4]
  }

  return MSG_OK;
}
 8001f0c:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001f10:	f002 bf7e 	b.w	8004e10 <chSchGoSleepTimeoutS>
 8001f14:	f3af 8000 	nop.w
 8001f18:	f3af 8000 	nop.w
 8001f1c:	f3af 8000 	nop.w

08001f20 <chGuardedPoolAllocTimeout.constprop.11>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 8001f20:	b510      	push	{r4, lr}
 8001f22:	2320      	movs	r3, #32
 8001f24:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8001f28:	f640 041c 	movw	r4, #2076	; 0x81c
 8001f2c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8001f30:	68a2      	ldr	r2, [r4, #8]
 8001f32:	1e53      	subs	r3, r2, #1
 8001f34:	2b00      	cmp	r3, #0
 8001f36:	60a3      	str	r3, [r4, #8]
 8001f38:	db0b      	blt.n	8001f52 <chGuardedPoolAllocTimeout.constprop.11+0x32>
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 8001f3a:	68e0      	ldr	r0, [r4, #12]
 8001f3c:	f640 031c 	movw	r3, #2076	; 0x81c
 8001f40:	f2c2 0300 	movt	r3, #8192	; 0x2000
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8001f44:	b188      	cbz	r0, 8001f6a <chGuardedPoolAllocTimeout.constprop.11+0x4a>
    mp->next = mp->next->next;
 8001f46:	6802      	ldr	r2, [r0, #0]
 8001f48:	60da      	str	r2, [r3, #12]
 8001f4a:	2300      	movs	r3, #0
 8001f4c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8001f50:	bd10      	pop	{r4, pc}
    if (TIME_IMMEDIATE == time) {
 8001f52:	b188      	cbz	r0, 8001f78 <chGuardedPoolAllocTimeout.constprop.11+0x58>
 8001f54:	4601      	mov	r1, r0
 8001f56:	4620      	mov	r0, r4
 8001f58:	f7ff ffca 	bl	8001ef0 <chSemWaitTimeoutS.part.1.5425>
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
 8001f5c:	2800      	cmp	r0, #0
 8001f5e:	d0ec      	beq.n	8001f3a <chGuardedPoolAllocTimeout.constprop.11+0x1a>
    return NULL;
 8001f60:	2000      	movs	r0, #0
 8001f62:	2300      	movs	r3, #0
 8001f64:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8001f68:	bd10      	pop	{r4, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 8001f6a:	695a      	ldr	r2, [r3, #20]
 8001f6c:	2a00      	cmp	r2, #0
 8001f6e:	d0f7      	beq.n	8001f60 <chGuardedPoolAllocTimeout.constprop.11+0x40>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8001f70:	6918      	ldr	r0, [r3, #16]
 8001f72:	2104      	movs	r1, #4
 8001f74:	4790      	blx	r2
 8001f76:	e7e8      	b.n	8001f4a <chGuardedPoolAllocTimeout.constprop.11+0x2a>
      sp->cnt++;
 8001f78:	60a2      	str	r2, [r4, #8]
 8001f7a:	e7e6      	b.n	8001f4a <chGuardedPoolAllocTimeout.constprop.11+0x2a>
 8001f7c:	f3af 8000 	nop.w

08001f80 <test_010_003_execute.10251>:

static void test_010_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_010_003_execute(void) {
 8001f80:	b508      	push	{r3, lr}

  /* [10.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8001f82:	f241 3330 	movw	r3, #4912	; 0x1330
 8001f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f8a:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8001f8c:	2064      	movs	r0, #100	; 0x64

static void test_010_003_execute(void) {

  /* [10.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8001f8e:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8001f90:	f7ff ffc6 	bl	8001f20 <chGuardedPoolAllocTimeout.constprop.11>
  }
}
 8001f94:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  /* [10.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8001f98:	f247 6160 	movw	r1, #30304	; 0x7660
 8001f9c:	f1d0 0001 	rsbs	r0, r0, #1
 8001fa0:	bf38      	it	cc
 8001fa2:	2000      	movcc	r0, #0
 8001fa4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001fa8:	f7fe bbaa 	b.w	8000700 <_test_assert>
 8001fac:	f3af 8000 	nop.w

08001fb0 <chMtxTryLock.constprop.44.4272>:
 8001fb0:	2320      	movs	r3, #32
 8001fb2:	f383 8811 	msr	BASEPRI, r3
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8001fb6:	f640 036c 	movw	r3, #2156	; 0x86c
 8001fba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fbe:	689a      	ldr	r2, [r3, #8]
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 8001fc0:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8001fc2:	b11a      	cbz	r2, 8001fcc <chMtxTryLock.constprop.44.4272+0x1c>
 8001fc4:	2300      	movs	r3, #0
 8001fc6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001fca:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8001fcc:	f241 22c0 	movw	r2, #4800	; 0x12c0
 8001fd0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001fd4:	6992      	ldr	r2, [r2, #24]
  mp->next = currp->mtxlist;
  currp->mtxlist = mp;
 8001fd6:	2001      	movs	r0, #1
  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
  mp->next = currp->mtxlist;
 8001fd8:	6b91      	ldr	r1, [r2, #56]	; 0x38

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8001fda:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 8001fdc:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 8001fde:	6393      	str	r3, [r2, #56]	; 0x38
 8001fe0:	2300      	movs	r3, #0
 8001fe2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8001fe6:	4770      	bx	lr
 8001fe8:	f3af 8000 	nop.w
 8001fec:	f3af 8000 	nop.w

08001ff0 <test_009_001_setup.10103>:
 * - [9.1.8] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_009_001_setup(void) {
 8001ff0:	b430      	push	{r4, r5}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8001ff2:	f640 0338 	movw	r3, #2104	; 0x838
 8001ff6:	f640 72b8 	movw	r2, #4024	; 0xfb8
 8001ffa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ffe:	f2c2 0200 	movt	r2, #8192	; 0x2000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002002:	f103 0418 	add.w	r4, r3, #24
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8002006:	f102 0510 	add.w	r5, r2, #16
 800200a:	f103 0020 	add.w	r0, r3, #32
  mbp->cnt    = (cnt_t)0;
 800200e:	2100      	movs	r1, #0
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8002010:	605d      	str	r5, [r3, #4]
 8002012:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8002014:	61dc      	str	r4, [r3, #28]
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8002016:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 8002018:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 800201a:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800201c:	6218      	str	r0, [r3, #32]
  tqp->prev = (thread_t *)tqp;
 800201e:	6258      	str	r0, [r3, #36]	; 0x24
  mbp->top    = &buf[n];
  mbp->cnt    = (cnt_t)0;
 8002020:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8002022:	7519      	strb	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8002024:	bc30      	pop	{r4, r5}
 8002026:	4770      	bx	lr
 8002028:	f3af 8000 	nop.w
 800202c:	f3af 8000 	nop.w

08002030 <test_011_001_setup.10391>:
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8002030:	f640 1250 	movw	r2, #2384	; 0x950
 * - [11.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void test_011_001_setup(void) {
 8002034:	b410      	push	{r4}

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8002036:	2100      	movs	r1, #0
  H_NEXT(&heapp->header) = hp;
 8002038:	f2c2 0200 	movt	r2, #8192	; 0x2000
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 800203c:	24cc      	movs	r4, #204	; 0xcc

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 800203e:	f640 03e0 	movw	r3, #2272	; 0x8e0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8002042:	e882 0012 	stmia.w	r2, {r1, r4}

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8002046:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800204a:	f103 0010 	add.w	r0, r3, #16
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
 800204e:	60d9      	str	r1, [r3, #12]
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8002050:	609a      	str	r2, [r3, #8]
 8002052:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8002054:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8002056:	6019      	str	r1, [r3, #0]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8002058:	6199      	str	r1, [r3, #24]
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}
 800205a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800205e:	4770      	bx	lr

08002060 <test_010_003_setup.10253>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8002060:	f640 031c 	movw	r3, #2076	; 0x81c
 8002064:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002068:	2200      	movs	r2, #0
  mp->object_size = size;
 800206a:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800206c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800206e:	605b      	str	r3, [r3, #4]
 8002070:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8002072:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 8002074:	615a      	str	r2, [r3, #20]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8002076:	609a      	str	r2, [r3, #8]
 8002078:	4770      	bx	lr
 800207a:	bf00      	nop
 800207c:	f3af 8000 	nop.w

08002080 <bmk_thread4.10693>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002080:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002084:	f2c2 0300 	movt	r3, #8192	; 0x2000
static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
}

static THD_FUNCTION(bmk_thread4, p) {
 8002088:	b510      	push	{r4, lr}
 800208a:	699c      	ldr	r4, [r3, #24]
 800208c:	2320      	movs	r3, #32
 800208e:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8002092:	2003      	movs	r0, #3
 8002094:	f7fe fe9c 	bl	8000dd0 <chSchGoSleepS>
    msg = self->u.rdymsg;
  } while (msg == MSG_OK);
 8002098:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800209a:	2b00      	cmp	r3, #0
 800209c:	d0f9      	beq.n	8002092 <bmk_thread4.10693+0x12>
 800209e:	2300      	movs	r3, #0
 80020a0:	f383 8811 	msr	BASEPRI, r3
 80020a4:	bd10      	pop	{r4, pc}
 80020a6:	bf00      	nop
 80020a8:	f3af 8000 	nop.w
 80020ac:	f3af 8000 	nop.w

080020b0 <test_006_005_execute.9514>:

static void test_006_005_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_006_005_execute(void) {
 80020b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80020b4:	f241 25c0 	movw	r5, #4800	; 0x12c0
 80020b8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80020bc:	69ab      	ldr	r3, [r5, #24]
    prio = chThdGetPriorityX();
  }

  /* [6.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 80020be:	f241 3430 	movw	r4, #4912	; 0x1330
 80020c2:	2202      	movs	r2, #2
 80020c4:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80020c8:	689e      	ldr	r6, [r3, #8]
 80020ca:	6022      	str	r2, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 80020cc:	f7ff ff70 	bl	8001fb0 <chMtxTryLock.constprop.44.4272>
    test_assert(b, "already locked");
 80020d0:	f247 6170 	movw	r1, #30320	; 0x7670
 80020d4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80020d8:	f7fe fb12 	bl	8000700 <_test_assert>
 80020dc:	b108      	cbz	r0, 80020e2 <test_006_005_execute.9514+0x32>
 80020de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [6.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 80020e2:	2303      	movs	r3, #3
 80020e4:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 80020e6:	f7ff ff63 	bl	8001fb0 <chMtxTryLock.constprop.44.4272>
    test_assert(!b, "not locked");
 80020ea:	f247 6180 	movw	r1, #30336	; 0x7680
 80020ee:	f080 0001 	eor.w	r0, r0, #1
 80020f2:	b2c0      	uxtb	r0, r0
 80020f4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80020f8:	f7fe fb02 	bl	8000700 <_test_assert>
 80020fc:	2800      	cmp	r0, #0
 80020fe:	d1ee      	bne.n	80020de <test_006_005_execute.9514+0x2e>

  /* [6.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 8002100:	f640 076c 	movw	r7, #2156	; 0x86c
 8002104:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8002108:	4638      	mov	r0, r7
    test_assert(!b, "not locked");
  }

  /* [6.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 800210a:	2304      	movs	r3, #4
 800210c:	6023      	str	r3, [r4, #0]
  {
    chMtxUnlock(&m1);
 800210e:	f7fe ff9f 	bl	8001050 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8002112:	68b8      	ldr	r0, [r7, #8]
 8002114:	f247 618c 	movw	r1, #30348	; 0x768c
 8002118:	f1d0 0001 	rsbs	r0, r0, #1
 800211c:	bf38      	it	cc
 800211e:	2000      	movcc	r0, #0
 8002120:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002124:	f7fe faec 	bl	8000700 <_test_assert>
 8002128:	2800      	cmp	r0, #0
 800212a:	d1d8      	bne.n	80020de <test_006_005_execute.9514+0x2e>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 800212c:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800212e:	f247 6198 	movw	r1, #30360	; 0x7698
 8002132:	ebb0 0c07 	subs.w	ip, r0, r7
 8002136:	f1dc 0000 	rsbs	r0, ip, #0
 800213a:	eb50 000c 	adcs.w	r0, r0, ip
 800213e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002142:	f7fe fadd 	bl	8000700 <_test_assert>
 8002146:	2800      	cmp	r0, #0
 8002148:	d1c9      	bne.n	80020de <test_006_005_execute.9514+0x2e>
 800214a:	69ab      	ldr	r3, [r5, #24]
  }

  /* [6.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800214c:	f247 6148 	movw	r1, #30280	; 0x7648
 8002150:	6898      	ldr	r0, [r3, #8]
 8002152:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002156:	ebb6 0e00 	subs.w	lr, r6, r0
 800215a:	f1de 0000 	rsbs	r0, lr, #0
 800215e:	eb50 000e 	adcs.w	r0, r0, lr
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [6.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8002162:	2305      	movs	r3, #5
 8002164:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8002166:	f7fe facb 	bl	8000700 <_test_assert>
 800216a:	2800      	cmp	r0, #0
 800216c:	d1b7      	bne.n	80020de <test_006_005_execute.9514+0x2e>
  }

  /* [6.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 800216e:	2306      	movs	r3, #6
 8002170:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8002172:	f7ff ff1d 	bl	8001fb0 <chMtxTryLock.constprop.44.4272>
    test_assert(b, "already locked");
 8002176:	f247 6170 	movw	r1, #30320	; 0x7670
 800217a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800217e:	f7fe fabf 	bl	8000700 <_test_assert>
 8002182:	2800      	cmp	r0, #0
 8002184:	d1ab      	bne.n	80020de <test_006_005_execute.9514+0x2e>
    b = chMtxTryLock(&m1);
 8002186:	f7ff ff13 	bl	8001fb0 <chMtxTryLock.constprop.44.4272>
    test_assert(!b, "not locked");
 800218a:	f247 6180 	movw	r1, #30336	; 0x7680
 800218e:	f080 0001 	eor.w	r0, r0, #1
 8002192:	b2c0      	uxtb	r0, r0
 8002194:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002198:	f7fe fab2 	bl	8000700 <_test_assert>
 800219c:	2800      	cmp	r0, #0
 800219e:	d19e      	bne.n	80020de <test_006_005_execute.9514+0x2e>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 80021a0:	f8d5 9018 	ldr.w	r9, [r5, #24]
 80021a4:	2320      	movs	r3, #32
 80021a6:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->mtxlist != NULL) {
 80021aa:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
 80021ae:	b303      	cbz	r3, 80021f2 <test_006_005_execute.9514+0x142>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 80021b0:	f04f 0800 	mov.w	r8, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80021b4:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 80021b6:	68d9      	ldr	r1, [r3, #12]
      if (chMtxQueueNotEmptyS(mp)) {
 80021b8:	4293      	cmp	r3, r2

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 80021ba:	f8c9 1038 	str.w	r1, [r9, #56]	; 0x38
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 80021be:	bf08      	it	eq
 80021c0:	f8c3 8008 	streq.w	r8, [r3, #8]
  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
      if (chMtxQueueNotEmptyS(mp)) {
 80021c4:	d00b      	beq.n	80021de <test_006_005_execute.9514+0x12e>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 80021c6:	f8d2 e038 	ldr.w	lr, [r2, #56]	; 0x38
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80021ca:	6811      	ldr	r1, [r2, #0]
        tp->mtxlist = mp;
        (void) chSchReadyI(tp);
 80021cc:	4610      	mov	r0, r2
 80021ce:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80021d0:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 80021d2:	609a      	str	r2, [r3, #8]
        mp->next = tp->mtxlist;
 80021d4:	f8c3 e00c 	str.w	lr, [r3, #12]
        tp->mtxlist = mp;
 80021d8:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 80021da:	f7fe fe91 	bl	8000f00 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 80021de:	f8d9 3038 	ldr.w	r3, [r9, #56]	; 0x38
 80021e2:	2b00      	cmp	r3, #0
 80021e4:	d1e6      	bne.n	80021b4 <test_006_005_execute.9514+0x104>
    ctp->prio = ctp->realprio;
 80021e6:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 80021ea:	f8c9 3008 	str.w	r3, [r9, #8]
    chSchRescheduleS();
 80021ee:	f7fe fcf7 	bl	8000be0 <chSchRescheduleS>
 80021f2:	2300      	movs	r3, #0
 80021f4:	f383 8811 	msr	BASEPRI, r3

    chMtxUnlockAll();
    test_assert(m1.owner == NULL, "still owned");
 80021f8:	68b8      	ldr	r0, [r7, #8]
 80021fa:	f247 618c 	movw	r1, #30348	; 0x768c
 80021fe:	f1d0 0001 	rsbs	r0, r0, #1
 8002202:	bf38      	it	cc
 8002204:	2000      	movcc	r0, #0
 8002206:	f640 076c 	movw	r7, #2156	; 0x86c
 800220a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800220e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8002212:	f7fe fa75 	bl	8000700 <_test_assert>
 8002216:	2800      	cmp	r0, #0
 8002218:	f47f af61 	bne.w	80020de <test_006_005_execute.9514+0x2e>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 800221c:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 800221e:	f247 6198 	movw	r1, #30360	; 0x7698
 8002222:	1bc2      	subs	r2, r0, r7
 8002224:	4250      	negs	r0, r2
 8002226:	4150      	adcs	r0, r2
 8002228:	f6c0 0100 	movt	r1, #2048	; 0x800
 800222c:	f7fe fa68 	bl	8000700 <_test_assert>
 8002230:	2800      	cmp	r0, #0
 8002232:	f47f af54 	bne.w	80020de <test_006_005_execute.9514+0x2e>
 8002236:	69ab      	ldr	r3, [r5, #24]
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8002238:	f247 6148 	movw	r1, #30280	; 0x7648
 800223c:	6898      	ldr	r0, [r3, #8]
 800223e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002242:	1a33      	subs	r3, r6, r0
 8002244:	4258      	negs	r0, r3
 8002246:	4158      	adcs	r0, r3
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8002248:	2307      	movs	r3, #7
 800224a:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  }
}
 800224c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8002250:	f7fe ba56 	b.w	8000700 <_test_assert>
 8002254:	f3af 8000 	nop.w
 8002258:	f3af 8000 	nop.w
 800225c:	f3af 8000 	nop.w

08002260 <chHeapAllocAligned.constprop.25.4351>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8002260:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 8002264:	f241 3938 	movw	r9, #4920	; 0x1338
 8002268:	f2c2 0900 	movt	r9, #8192	; 0x2000
 800226c:	2800      	cmp	r0, #0
 800226e:	bf18      	it	ne
 8002270:	4681      	movne	r9, r0

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002272:	f109 0b10 	add.w	fp, r9, #16
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002276:	f101 0a07 	add.w	sl, r1, #7
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 800227a:	b083      	sub	sp, #12

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800227c:	4658      	mov	r0, fp
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 800227e:	4688      	mov	r8, r1
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002280:	ea4f 0ada 	mov.w	sl, sl, lsr #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002284:	f7fe ff84 	bl	8001190 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8002288:	f109 0608 	add.w	r6, r9, #8
 800228c:	e00d      	b.n	80022aa <chHeapAllocAligned.constprop.25.4351+0x4a>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800228e:	6859      	ldr	r1, [r3, #4]
 8002290:	1c4c      	adds	r4, r1, #1
 8002292:	00e4      	lsls	r4, r4, #3
 8002294:	f1a4 0008 	sub.w	r0, r4, #8
 8002298:	441c      	add	r4, r3
 800229a:	4407      	add	r7, r0
 800229c:	42a2      	cmp	r2, r4
 800229e:	ea4f 07e7 	mov.w	r7, r7, asr #3
 80022a2:	d201      	bcs.n	80022a8 <chHeapAllocAligned.constprop.25.4351+0x48>
 80022a4:	45ba      	cmp	sl, r7
 80022a6:	d921      	bls.n	80022ec <chHeapAllocAligned.constprop.25.4351+0x8c>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 80022a8:	461e      	mov	r6, r3
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80022aa:	6833      	ldr	r3, [r6, #0]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80022ac:	f103 050f 	add.w	r5, r3, #15
 80022b0:	f025 0507 	bic.w	r5, r5, #7
 80022b4:	f1a5 0208 	sub.w	r2, r5, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80022b8:	1a9f      	subs	r7, r3, r2

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80022ba:	f103 0c08 	add.w	ip, r3, #8
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80022be:	2b00      	cmp	r3, #0
 80022c0:	d1e5      	bne.n	800228e <chHeapAllocAligned.constprop.25.4351+0x2e>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80022c2:	4658      	mov	r0, fp
 80022c4:	f7fe fec4 	bl	8001050 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 80022c8:	f8d9 3000 	ldr.w	r3, [r9]
 80022cc:	2b00      	cmp	r3, #0
 80022ce:	d049      	beq.n	8002364 <chHeapAllocAligned.constprop.25.4351+0x104>
    ahp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT,
 80022d0:	f10a 0001 	add.w	r0, sl, #1
 80022d4:	2108      	movs	r1, #8
 80022d6:	00c0      	lsls	r0, r0, #3
 80022d8:	460a      	mov	r2, r1
 80022da:	4798      	blx	r3
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 80022dc:	b118      	cbz	r0, 80022e6 <chHeapAllocAligned.constprop.25.4351+0x86>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
 80022de:	f840 9c08 	str.w	r9, [r0, #-8]
      H_SIZE(hp) = size;
 80022e2:	f840 8c04 	str.w	r8, [r0, #-4]
      /*lint -restore*/
    }
  }

  return NULL;
}
 80022e6:	b003      	add	sp, #12
 80022e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 80022ec:	429a      	cmp	r2, r3
 80022ee:	d821      	bhi.n	8002334 <chHeapAllocAligned.constprop.25.4351+0xd4>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 80022f0:	458a      	cmp	sl, r1
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 80022f2:	bf1d      	ittte	ne
 80022f4:	f10a 0a01 	addne.w	sl, sl, #1
          H_NEXT(fp) = H_NEXT(hp);
 80022f8:	681a      	ldrne	r2, [r3, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80022fa:	eba0 00ca 	subne.w	r0, r0, sl, lsl #3
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 80022fe:	6819      	ldreq	r1, [r3, #0]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8002300:	bf1d      	ittte	ne
 8002302:	eb03 01ca 	addne.w	r1, r3, sl, lsl #3
 8002306:	10c0      	asrne	r0, r0, #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 8002308:	f843 203a 	strne.w	r2, [r3, sl, lsl #3]
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 800230c:	461a      	moveq	r2, r3
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 800230e:	bf1c      	itt	ne
 8002310:	6048      	strne	r0, [r1, #4]
          H_NEXT(qp) = fp;
 8002312:	461a      	movne	r2, r3
 8002314:	6031      	str	r1, [r6, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8002316:	f8c2 8004 	str.w	r8, [r2, #4]
      H_HEAP(hp) = heapp;
 800231a:	f8c2 9000 	str.w	r9, [r2]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800231e:	4658      	mov	r0, fp
 8002320:	f8cd c004 	str.w	ip, [sp, #4]
 8002324:	f7fe fe94 	bl	8001050 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8002328:	f8dd c004 	ldr.w	ip, [sp, #4]
 800232c:	4660      	mov	r0, ip
      /*lint -restore*/
    }
  }

  return NULL;
}
 800232e:	b003      	add	sp, #12
 8002330:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
        if (bpages > pages) {
 8002334:	45ba      	cmp	sl, r7
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8002336:	ebcc 0102 	rsb	r1, ip, r2
 800233a:	ea4f 01e1 	mov.w	r1, r1, asr #3
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800233e:	bf3e      	ittt	cc
 8002340:	f10a 0001 	addcc.w	r0, sl, #1
          H_PAGES(fp) = (bpages - pages) - 1U;

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8002344:	681c      	ldrcc	r4, [r3, #0]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
 8002346:	ea6f 0a0a 	mvncc.w	sl, sl
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800234a:	6059      	str	r1, [r3, #4]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
 800234c:	bf3d      	ittte	cc
 800234e:	4457      	addcc	r7, sl
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 8002350:	eb02 01c0 	addcc.w	r1, r2, r0, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8002354:	604f      	strcc	r7, [r1, #4]
 8002356:	46ac      	movcs	ip, r5

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8002358:	bf3e      	ittt	cc
 800235a:	f842 4030 	strcc.w	r4, [r2, r0, lsl #3]
 800235e:	46ac      	movcc	ip, r5
          H_NEXT(hp) = fp;
 8002360:	6019      	strcc	r1, [r3, #0]
 8002362:	e7d8      	b.n	8002316 <chHeapAllocAligned.constprop.25.4351+0xb6>
      return (void *)ahp;
      /*lint -restore*/
    }
  }

  return NULL;
 8002364:	4618      	mov	r0, r3
 8002366:	e7be      	b.n	80022e6 <chHeapAllocAligned.constprop.25.4351+0x86>
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <thread6.9477>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8002370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002372:	4606      	mov	r6, r0

  chMtxLock(&m1);
 8002374:	f640 006c 	movw	r0, #2156	; 0x86c
 8002378:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800237c:	f7fe ff08 	bl	8001190 <chMtxLock>
 8002380:	2320      	movs	r3, #32
 8002382:	f383 8811 	msr	BASEPRI, r3
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8002386:	f241 23c0 	movw	r3, #4800	; 0x12c0
 800238a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800238e:	699c      	ldr	r4, [r3, #24]
 8002390:	6ba7      	ldr	r7, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8002392:	4638      	mov	r0, r7
 8002394:	f7fe fe34 	bl	8001000 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8002398:	f640 0364 	movw	r3, #2148	; 0x864
 800239c:	f2c2 0300 	movt	r3, #8192	; 0x2000
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80023a0:	461d      	mov	r5, r3
 80023a2:	6263      	str	r3, [r4, #36]	; 0x24
 80023a4:	e003      	b.n	80023ae <thread6.9477+0x3e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80023a6:	6899      	ldr	r1, [r3, #8]
 80023a8:	68a2      	ldr	r2, [r4, #8]
 80023aa:	4291      	cmp	r1, r2
 80023ac:	d302      	bcc.n	80023b4 <thread6.9477+0x44>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80023ae:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80023b0:	42ab      	cmp	r3, r5
 80023b2:	d1f8      	bne.n	80023a6 <thread6.9477+0x36>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80023b4:	685a      	ldr	r2, [r3, #4]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 80023b6:	2007      	movs	r0, #7

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80023b8:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80023ba:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80023bc:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80023be:	605c      	str	r4, [r3, #4]
 80023c0:	f7fe fd06 	bl	8000dd0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 80023c4:	4638      	mov	r0, r7
 80023c6:	f7fe fe7b 	bl	80010c0 <chMtxLockS>
 80023ca:	2300      	movs	r3, #0
 80023cc:	f383 8811 	msr	BASEPRI, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 80023d0:	7830      	ldrb	r0, [r6, #0]
 80023d2:	f7fe f8ed 	bl	80005b0 <test_emit_token>
  chMtxUnlock(&m1);
}
 80023d6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
static THD_FUNCTION(thread6, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80023da:	f640 006c 	movw	r0, #2156	; 0x86c
 80023de:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80023e2:	f7fe be35 	b.w	8001050 <chMtxUnlock>
 80023e6:	bf00      	nop
 80023e8:	f3af 8000 	nop.w
 80023ec:	f3af 8000 	nop.w

080023f0 <test_008_002_execute.9863>:

static void test_008_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_008_002_execute(void) {
 80023f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 80023f2:	f241 3330 	movw	r3, #4912	; 0x1330
 80023f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023fa:	2701      	movs	r7, #1
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 80023fc:	f247 7668 	movw	r6, #30568	; 0x7768
 8002400:	601f      	str	r7, [r3, #0]
 8002402:	f6c0 0600 	movt	r6, #2048	; 0x800
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8002406:	2400      	movs	r4, #0
 8002408:	2507      	movs	r5, #7
 800240a:	e001      	b.n	8002410 <test_008_002_execute.9863+0x20>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 800240c:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800240e:	b175      	cbz	r5, 800242e <test_008_002_execute.9863+0x3e>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002410:	fa25 f304 	lsr.w	r3, r5, r4
 8002414:	07db      	lsls	r3, r3, #31
 8002416:	d5f9      	bpl.n	800240c <test_008_002_execute.9863+0x1c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002418:	fa07 f204 	lsl.w	r2, r7, r4
      handlers[eid](eid);
 800241c:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8002420:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002422:	ea25 0502 	bic.w	r5, r5, r2
      handlers[eid](eid);
    }
    eid++;
 8002426:	3401      	adds	r4, #1
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8002428:	4798      	blx	r3
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800242a:	2d00      	cmp	r5, #0
 800242c:	d1f0      	bne.n	8002410 <test_008_002_execute.9863+0x20>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 800242e:	f247 60a8 	movw	r0, #30376	; 0x76a8
 8002432:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8002436:	f6c0 0000 	movt	r0, #2048	; 0x800
 800243a:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 800243e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8002442:	f7fe b92d 	b.w	80006a0 <_test_assert_sequence>
 8002446:	bf00      	nop
 8002448:	f3af 8000 	nop.w
 800244c:	f3af 8000 	nop.w

08002450 <test_011_001_execute.10389>:

static void test_011_001_execute(void) {
 8002450:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* [11.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8002454:	f640 00e0 	movw	r0, #2272	; 0x8e0

static void test_011_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_011_001_execute(void) {
 8002458:	b084      	sub	sp, #16
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [11.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 800245a:	f241 3430 	movw	r4, #4912	; 0x1330
 800245e:	2301      	movs	r3, #1
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8002460:	a901      	add	r1, sp, #4
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [11.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8002462:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8002466:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800246a:	2200      	movs	r2, #0
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [11.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 800246c:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800246e:	f7fe fecf 	bl	8001210 <chHeapStatus>
 8002472:	1e47      	subs	r7, r0, #1
 8002474:	4278      	negs	r0, r7
 8002476:	f247 61c0 	movw	r1, #30400	; 0x76c0
 800247a:	4178      	adcs	r0, r7
 800247c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002480:	f7fe f93e 	bl	8000700 <_test_assert>
 8002484:	b110      	cbz	r0, 800248c <test_011_001_execute.10389+0x3c>
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
    test_assert(n == sz, "size changed");
  }
}
 8002486:	b004      	add	sp, #16
 8002488:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 800248c:	f640 00e0 	movw	r0, #2272	; 0x8e0
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  }

  /* [11.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 8002490:	2302      	movs	r3, #2
 8002492:	f44f 614d 	mov.w	r1, #3280	; 0xcd0
 8002496:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800249a:	6023      	str	r3, [r4, #0]
 800249c:	f7ff fee0 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
    test_assert(p1 == NULL, "allocation not failed");
 80024a0:	f247 61d0 	movw	r1, #30416	; 0x76d0
 80024a4:	f1d0 0001 	rsbs	r0, r0, #1
 80024a8:	bf38      	it	cc
 80024aa:	2000      	movcc	r0, #0
 80024ac:	f6c0 0100 	movt	r1, #2048	; 0x800
 80024b0:	f7fe f926 	bl	8000700 <_test_assert>
 80024b4:	2800      	cmp	r0, #0
 80024b6:	d1e6      	bne.n	8002486 <test_011_001_execute.10389+0x36>
 80024b8:	f640 00e0 	movw	r0, #2272	; 0x8e0
  }

  /* [11.1.3] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 80024bc:	2303      	movs	r3, #3
 80024be:	2110      	movs	r1, #16
 80024c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80024c4:	6023      	str	r3, [r4, #0]
 80024c6:	f7ff fecb 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 80024ca:	f247 61e8 	movw	r1, #30440	; 0x76e8
 80024ce:	4605      	mov	r5, r0
 80024d0:	3000      	adds	r0, #0
 80024d2:	bf18      	it	ne
 80024d4:	2001      	movne	r0, #1
 80024d6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80024da:	f7fe f911 	bl	8000700 <_test_assert>
 80024de:	2800      	cmp	r0, #0
 80024e0:	d1d1      	bne.n	8002486 <test_011_001_execute.10389+0x36>
    chHeapFree(p1);
 80024e2:	4628      	mov	r0, r5
 80024e4:	f7fe fecc 	bl	8001280 <chHeapFree>
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 80024e8:	f640 00e0 	movw	r0, #2272	; 0x8e0
    chHeapFree(p1);
  }

  /* [11.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 80024ec:	2304      	movs	r3, #4
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 80024ee:	a902      	add	r1, sp, #8
 80024f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80024f4:	aa03      	add	r2, sp, #12
    chHeapFree(p1);
  }

  /* [11.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 80024f6:	6023      	str	r3, [r4, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 80024f8:	f7fe fe8a 	bl	8001210 <chHeapStatus>
    test_assert(n == 1, "missing free block");
 80024fc:	1e46      	subs	r6, r0, #1
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 80024fe:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8002500:	f247 61fc 	movw	r1, #30460	; 0x76fc
 8002504:	4270      	negs	r0, r6
 8002506:	4170      	adcs	r0, r6
 8002508:	f6c0 0100 	movt	r1, #2048	; 0x800
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800250c:	9300      	str	r3, [sp, #0]
    test_assert(n == 1, "missing free block");
 800250e:	f7fe f8f7 	bl	8000700 <_test_assert>
 8002512:	2800      	cmp	r0, #0
 8002514:	d1b7      	bne.n	8002486 <test_011_001_execute.10389+0x36>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8002516:	9802      	ldr	r0, [sp, #8]
 8002518:	f247 7110 	movw	r1, #30480	; 0x7710
 800251c:	280f      	cmp	r0, #15
 800251e:	bf94      	ite	ls
 8002520:	2000      	movls	r0, #0
 8002522:	2001      	movhi	r0, #1
 8002524:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002528:	f7fe f8ea 	bl	8000700 <_test_assert>
 800252c:	2800      	cmp	r0, #0
 800252e:	d1aa      	bne.n	8002486 <test_011_001_execute.10389+0x36>
    test_assert(total_size == largest_size, "unexpected heap state");
 8002530:	9802      	ldr	r0, [sp, #8]
 8002532:	9b03      	ldr	r3, [sp, #12]
 8002534:	f247 7110 	movw	r1, #30480	; 0x7710
 8002538:	1ac5      	subs	r5, r0, r3
 800253a:	4268      	negs	r0, r5
 800253c:	4168      	adcs	r0, r5
 800253e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002542:	f7fe f8dd 	bl	8000700 <_test_assert>
 8002546:	4605      	mov	r5, r0
 8002548:	2800      	cmp	r0, #0
 800254a:	d19c      	bne.n	8002486 <test_011_001_execute.10389+0x36>
 800254c:	f640 00e0 	movw	r0, #2272	; 0x8e0
  }

  /* [11.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 8002550:	2305      	movs	r3, #5
 8002552:	2110      	movs	r1, #16
 8002554:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002558:	6023      	str	r3, [r4, #0]
 800255a:	f7ff fe81 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 800255e:	4607      	mov	r7, r0
 8002560:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002564:	2110      	movs	r1, #16
 8002566:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800256a:	f7ff fe79 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 800256e:	4606      	mov	r6, r0
 8002570:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002574:	2110      	movs	r1, #16
 8002576:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800257a:	f7ff fe71 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 800257e:	4680      	mov	r8, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);                                 /* Does not merge.*/
 8002580:	4638      	mov	r0, r7
 8002582:	f7fe fe7d 	bl	8001280 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 8002586:	4630      	mov	r0, r6
 8002588:	f7fe fe7a 	bl	8001280 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 800258c:	4640      	mov	r0, r8
 800258e:	f7fe fe77 	bl	8001280 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8002592:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002596:	462a      	mov	r2, r5
 8002598:	4669      	mov	r1, sp
 800259a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800259e:	f7fe fe37 	bl	8001210 <chHeapStatus>
 80025a2:	1e42      	subs	r2, r0, #1
 80025a4:	4250      	negs	r0, r2
 80025a6:	f247 61c0 	movw	r1, #30400	; 0x76c0
 80025aa:	4150      	adcs	r0, r2
 80025ac:	f6c0 0100 	movt	r1, #2048	; 0x800
 80025b0:	f7fe f8a6 	bl	8000700 <_test_assert>
 80025b4:	4605      	mov	r5, r0
 80025b6:	2800      	cmp	r0, #0
 80025b8:	f47f af65 	bne.w	8002486 <test_011_001_execute.10389+0x36>
 80025bc:	f640 00e0 	movw	r0, #2272	; 0x8e0
  }

  /* [11.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 80025c0:	2306      	movs	r3, #6
 80025c2:	2110      	movs	r1, #16
 80025c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025c8:	6023      	str	r3, [r4, #0]
 80025ca:	f7ff fe49 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 80025ce:	4606      	mov	r6, r0
 80025d0:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80025d4:	2110      	movs	r1, #16
 80025d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025da:	f7ff fe41 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 80025de:	4607      	mov	r7, r0
 80025e0:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80025e4:	2110      	movs	r1, #16
 80025e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80025ea:	f7ff fe39 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p3);                                 /* Merges forward.*/
 80025ee:	f7fe fe47 	bl	8001280 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 80025f2:	4638      	mov	r0, r7
 80025f4:	f7fe fe44 	bl	8001280 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 80025f8:	4630      	mov	r0, r6
 80025fa:	f7fe fe41 	bl	8001280 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80025fe:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002602:	462a      	mov	r2, r5
 8002604:	4669      	mov	r1, sp
 8002606:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800260a:	f7fe fe01 	bl	8001210 <chHeapStatus>
 800260e:	1e43      	subs	r3, r0, #1
 8002610:	4258      	negs	r0, r3
 8002612:	f247 61c0 	movw	r1, #30400	; 0x76c0
 8002616:	4158      	adcs	r0, r3
 8002618:	f6c0 0100 	movt	r1, #2048	; 0x800
 800261c:	f7fe f870 	bl	8000700 <_test_assert>
 8002620:	4605      	mov	r5, r0
 8002622:	2800      	cmp	r0, #0
 8002624:	f47f af2f 	bne.w	8002486 <test_011_001_execute.10389+0x36>
 8002628:	f640 00e0 	movw	r0, #2272	; 0x8e0
  }

  /* [11.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 800262c:	2307      	movs	r3, #7
 800262e:	2111      	movs	r1, #17
 8002630:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002634:	6023      	str	r3, [r4, #0]
 8002636:	f7ff fe13 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 800263a:	4606      	mov	r6, r0
 800263c:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002640:	2110      	movs	r1, #16
 8002642:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002646:	f7ff fe0b 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 800264a:	4607      	mov	r7, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 800264c:	4630      	mov	r0, r6
 800264e:	f7fe fe17 	bl	8001280 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8002652:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002656:	462a      	mov	r2, r5
 8002658:	4669      	mov	r1, sp
 800265a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800265e:	f7fe fdd7 	bl	8001210 <chHeapStatus>
 8002662:	f1b0 0802 	subs.w	r8, r0, #2
 8002666:	f1d8 0000 	rsbs	r0, r8, #0
 800266a:	f247 7128 	movw	r1, #30504	; 0x7728
 800266e:	eb50 0008 	adcs.w	r0, r0, r8
 8002672:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002676:	f7fe f843 	bl	8000700 <_test_assert>
 800267a:	4605      	mov	r5, r0
 800267c:	2800      	cmp	r0, #0
 800267e:	f47f af02 	bne.w	8002486 <test_011_001_execute.10389+0x36>
 8002682:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002686:	2110      	movs	r1, #16
 8002688:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800268c:	f7ff fde8 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 8002690:	4606      	mov	r6, r0
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8002692:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002696:	462a      	mov	r2, r5
 8002698:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800269c:	4669      	mov	r1, sp
 800269e:	f7fe fdb7 	bl	8001210 <chHeapStatus>
 80026a2:	2801      	cmp	r0, #1
 80026a4:	f000 80dd 	beq.w	8002862 <test_011_001_execute.10389+0x412>
 80026a8:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80026ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026b0:	4669      	mov	r1, sp
 80026b2:	2200      	movs	r2, #0
 80026b4:	f7fe fdac 	bl	8001210 <chHeapStatus>
 80026b8:	f1b0 0c02 	subs.w	ip, r0, #2
 80026bc:	f1dc 0000 	rsbs	r0, ip, #0
 80026c0:	eb50 000c 	adcs.w	r0, r0, ip
 80026c4:	f247 61c0 	movw	r1, #30400	; 0x76c0
 80026c8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80026cc:	f7fe f818 	bl	8000700 <_test_assert>
 80026d0:	4605      	mov	r5, r0
 80026d2:	2800      	cmp	r0, #0
 80026d4:	f47f aed7 	bne.w	8002486 <test_011_001_execute.10389+0x36>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 80026d8:	4638      	mov	r0, r7
 80026da:	f7fe fdd1 	bl	8001280 <chHeapFree>
    chHeapFree(p1);
 80026de:	4630      	mov	r0, r6
 80026e0:	f7fe fdce 	bl	8001280 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80026e4:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80026e8:	462a      	mov	r2, r5
 80026ea:	4669      	mov	r1, sp
 80026ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80026f0:	f7fe fd8e 	bl	8001210 <chHeapStatus>
 80026f4:	f1b0 0e01 	subs.w	lr, r0, #1
 80026f8:	f1de 0000 	rsbs	r0, lr, #0
 80026fc:	f247 61c0 	movw	r1, #30400	; 0x76c0
 8002700:	eb50 000e 	adcs.w	r0, r0, lr
 8002704:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002708:	f7fd fffa 	bl	8000700 <_test_assert>
 800270c:	4605      	mov	r5, r0
 800270e:	2800      	cmp	r0, #0
 8002710:	f47f aeb9 	bne.w	8002486 <test_011_001_execute.10389+0x36>
 8002714:	f640 00e0 	movw	r0, #2272	; 0x8e0
  }

  /* [11.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 8002718:	2308      	movs	r3, #8
 800271a:	2110      	movs	r1, #16
 800271c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002720:	6023      	str	r3, [r4, #0]
 8002722:	f7ff fd9d 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 8002726:	4604      	mov	r4, r0
 8002728:	f640 00e0 	movw	r0, #2272	; 0x8e0
 800272c:	2110      	movs	r1, #16
 800272e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002732:	f7ff fd95 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
 8002736:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 8002738:	4620      	mov	r0, r4
 800273a:	f7fe fda1 	bl	8001280 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800273e:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002742:	462a      	mov	r2, r5
 8002744:	4669      	mov	r1, sp
 8002746:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800274a:	f7fe fd61 	bl	8001210 <chHeapStatus>
 800274e:	1e87      	subs	r7, r0, #2
 8002750:	4278      	negs	r0, r7
 8002752:	f247 7128 	movw	r1, #30504	; 0x7728
 8002756:	4178      	adcs	r0, r7
 8002758:	f6c0 0100 	movt	r1, #2048	; 0x800
 800275c:	f7fd ffd0 	bl	8000700 <_test_assert>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [11.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 8002760:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8002764:	4605      	mov	r5, r0
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [11.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 8002766:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800276a:	2800      	cmp	r0, #0
 800276c:	f47f ae8b 	bne.w	8002486 <test_011_001_execute.10389+0x36>
 8002770:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002774:	2120      	movs	r1, #32
 8002776:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800277a:	f7ff fd71 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
    chHeapFree(p1);
 800277e:	f7fe fd7f 	bl	8001280 <chHeapFree>
    chHeapFree(p2);
 8002782:	4630      	mov	r0, r6
 8002784:	f7fe fd7c 	bl	8001280 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8002788:	f640 00e0 	movw	r0, #2272	; 0x8e0
 800278c:	462a      	mov	r2, r5
 800278e:	4669      	mov	r1, sp
 8002790:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002794:	f7fe fd3c 	bl	8001210 <chHeapStatus>
 8002798:	1e45      	subs	r5, r0, #1
 800279a:	4268      	negs	r0, r5
 800279c:	f247 61c0 	movw	r1, #30400	; 0x76c0
 80027a0:	4168      	adcs	r0, r5
 80027a2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80027a6:	f7fd ffab 	bl	8000700 <_test_assert>
 80027aa:	4602      	mov	r2, r0
 80027ac:	2800      	cmp	r0, #0
 80027ae:	f47f ae6a 	bne.w	8002486 <test_011_001_execute.10389+0x36>
  }

  /* [11.1.9] Allocating the whole available space.*/
  test_set_step(9);
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 80027b2:	f640 00e0 	movw	r0, #2272	; 0x8e0
    chHeapFree(p2);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [11.1.9] Allocating the whole available space.*/
  test_set_step(9);
 80027b6:	2309      	movs	r3, #9
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 80027b8:	4669      	mov	r1, sp
 80027ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chHeapFree(p2);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [11.1.9] Allocating the whole available space.*/
  test_set_step(9);
 80027be:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 80027c0:	f7fe fd26 	bl	8001210 <chHeapStatus>
 80027c4:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80027c8:	9900      	ldr	r1, [sp, #0]
 80027ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80027ce:	f7ff fd47 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
    p1 = chHeapAlloc(&test_heap, n);
    test_assert(p1 != NULL, "allocation failed");
 80027d2:	f247 61e8 	movw	r1, #30440	; 0x76e8
 80027d6:	4606      	mov	r6, r0
 80027d8:	3000      	adds	r0, #0
 80027da:	f6c0 0100 	movt	r1, #2048	; 0x800
 80027de:	bf18      	it	ne
 80027e0:	2001      	movne	r0, #1
 80027e2:	f7fd ff8d 	bl	8000700 <_test_assert>
 80027e6:	4601      	mov	r1, r0
 80027e8:	2800      	cmp	r0, #0
 80027ea:	f47f ae4c 	bne.w	8002486 <test_011_001_execute.10389+0x36>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 80027ee:	f640 00e0 	movw	r0, #2272	; 0x8e0
 80027f2:	460a      	mov	r2, r1
 80027f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80027f8:	f7fe fd0a 	bl	8001210 <chHeapStatus>
 80027fc:	f247 7138 	movw	r1, #30520	; 0x7738
 8002800:	f1d0 0001 	rsbs	r0, r0, #1
 8002804:	bf38      	it	cc
 8002806:	2000      	movcc	r0, #0
 8002808:	f6c0 0100 	movt	r1, #2048	; 0x800
 800280c:	f7fd ff78 	bl	8000700 <_test_assert>
 8002810:	4605      	mov	r5, r0
 8002812:	2800      	cmp	r0, #0
 8002814:	f47f ae37 	bne.w	8002486 <test_011_001_execute.10389+0x36>
    chHeapFree(p1);
 8002818:	4630      	mov	r0, r6
 800281a:	f7fe fd31 	bl	8001280 <chHeapFree>

  /* [11.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800281e:	f640 00e0 	movw	r0, #2272	; 0x8e0
 8002822:	4669      	mov	r1, sp
    chHeapFree(p1);
  }

  /* [11.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8002824:	230a      	movs	r3, #10
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8002826:	462a      	mov	r2, r5
 8002828:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chHeapFree(p1);
  }

  /* [11.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 800282c:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 800282e:	f7fe fcef 	bl	8001210 <chHeapStatus>
 8002832:	1e44      	subs	r4, r0, #1
 8002834:	4260      	negs	r0, r4
 8002836:	f247 61c0 	movw	r1, #30400	; 0x76c0
 800283a:	4160      	adcs	r0, r4
 800283c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002840:	f7fd ff5e 	bl	8000700 <_test_assert>
 8002844:	2800      	cmp	r0, #0
 8002846:	f47f ae1e 	bne.w	8002486 <test_011_001_execute.10389+0x36>
    test_assert(n == sz, "size changed");
 800284a:	e89d 0009 	ldmia.w	sp, {r0, r3}
 800284e:	1ac2      	subs	r2, r0, r3
 8002850:	4250      	negs	r0, r2
 8002852:	f247 7144 	movw	r1, #30532	; 0x7744
 8002856:	4150      	adcs	r0, r2
 8002858:	f6c0 0100 	movt	r1, #2048	; 0x800
 800285c:	f7fd ff50 	bl	8000700 <_test_assert>
 8002860:	e611      	b.n	8002486 <test_011_001_execute.10389+0x36>
    chHeapFree(p1);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8002862:	2001      	movs	r0, #1
 8002864:	e72e      	b.n	80026c4 <test_011_001_execute.10389+0x274>
 8002866:	bf00      	nop
 8002868:	f3af 8000 	nop.w
 800286c:	f3af 8000 	nop.w

08002870 <test_011_002_execute.10387>:
 *   block is freed using chHeapFree(), must not fail.
 * - [11.2.2] Testing allocation failure.
 * .
 */

static void test_011_002_execute(void) {
 8002870:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [11.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8002872:	f241 3430 	movw	r4, #4912	; 0x1330
 *   block is freed using chHeapFree(), must not fail.
 * - [11.2.2] Testing allocation failure.
 * .
 */

static void test_011_002_execute(void) {
 8002876:	b082      	sub	sp, #8
  void *p1;
  size_t total_size, largest_size;

  /* [11.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8002878:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 800287a:	aa01      	add	r2, sp, #4
 800287c:	4669      	mov	r1, sp
  void *p1;
  size_t total_size, largest_size;

  /* [11.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 800287e:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8002882:	2000      	movs	r0, #0
  void *p1;
  size_t total_size, largest_size;

  /* [11.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8002884:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8002886:	f7fe fcc3 	bl	8001210 <chHeapStatus>
 800288a:	f640 00e0 	movw	r0, #2272	; 0x8e0
 800288e:	2110      	movs	r1, #16
 8002890:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002894:	f7ff fce4 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8002898:	f247 61e8 	movw	r1, #30440	; 0x76e8
 800289c:	4606      	mov	r6, r0
 800289e:	3000      	adds	r0, #0
 80028a0:	bf18      	it	ne
 80028a2:	2001      	movne	r0, #1
 80028a4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80028a8:	f7fd ff2a 	bl	8000700 <_test_assert>
 80028ac:	4605      	mov	r5, r0
 80028ae:	b108      	cbz	r0, 80028b4 <test_011_002_execute.10387+0x44>
  test_set_step(2);
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  }
}
 80028b0:	b002      	add	sp, #8
 80028b2:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(1);
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
    chHeapFree(p1);
 80028b4:	4630      	mov	r0, r6
 80028b6:	f7fe fce3 	bl	8001280 <chHeapFree>
  }

  /* [11.2.2] Testing allocation failure.*/
  test_set_step(2);
 80028ba:	2302      	movs	r3, #2
 80028bc:	4628      	mov	r0, r5
 80028be:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 80028c2:	6023      	str	r3, [r4, #0]
 80028c4:	f7ff fccc 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 80028c8:	f247 61d0 	movw	r1, #30416	; 0x76d0
 80028cc:	f1d0 0001 	rsbs	r0, r0, #1
 80028d0:	bf38      	it	cc
 80028d2:	2000      	movcc	r0, #0
 80028d4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80028d8:	f7fd ff12 	bl	8000700 <_test_assert>
  }
}
 80028dc:	b002      	add	sp, #8
 80028de:	bd70      	pop	{r4, r5, r6, pc}

080028e0 <chThdDequeueNextI.constprop.49>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80028e0:	6802      	ldr	r2, [r0, #0]
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80028e2:	b410      	push	{r4}

  if (queue_notempty(tqp)) {
 80028e4:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80028e6:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 80028e8:	d009      	beq.n	80028fe <chThdDequeueNextI.constprop.49+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80028ea:	6811      	ldr	r1, [r2, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80028ec:	2400      	movs	r4, #0
 80028ee:	6001      	str	r1, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80028f0:	604b      	str	r3, [r1, #4]
 80028f2:	6254      	str	r4, [r2, #36]	; 0x24
  (void) chSchReadyI(tp);
 80028f4:	4610      	mov	r0, r2
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80028f6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80028fa:	f7fe bb01 	b.w	8000f00 <chSchReadyI>
 80028fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002902:	4770      	bx	lr
 8002904:	f3af 8000 	nop.w
 8002908:	f3af 8000 	nop.w
 800290c:	f3af 8000 	nop.w

08002910 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8002910:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8002914:	f241 0520 	movw	r5, #4128	; 0x1020
 8002918:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800291c:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 800291e:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 8002922:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002924:	05d9      	lsls	r1, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8002926:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8002928:	f100 8086 	bmi.w	8002a38 <VectorD4+0x128>
 800292c:	2320      	movs	r3, #32
 800292e:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002932:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8002936:	d049      	beq.n	80029cc <VectorD4+0xbc>
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8002938:	f241 0820 	movw	r8, #4128	; 0x1020
 800293c:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8002940:	e009      	b.n	8002956 <VectorD4+0x46>
    if (sr & USART_SR_RXNE)
 8002942:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8002944:	6877      	ldr	r7, [r6, #4]
 8002946:	f895 a078 	ldrb.w	sl, [r5, #120]	; 0x78
    if (sr & USART_SR_RXNE)
 800294a:	d41f      	bmi.n	800298c <VectorD4+0x7c>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800294c:	6834      	ldr	r4, [r6, #0]
 800294e:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8002950:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8002954:	d03a      	beq.n	80029cc <VectorD4+0xbc>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8002956:	0722      	lsls	r2, r4, #28
 8002958:	d0f3      	beq.n	8002942 <VectorD4+0x32>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;
 800295a:	f014 0f08 	tst.w	r4, #8
 800295e:	bf14      	ite	ne
 8002960:	2180      	movne	r1, #128	; 0x80
 8002962:	2100      	moveq	r1, #0

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (sr & USART_SR_PE)
 8002964:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8002966:	bf48      	it	mi
 8002968:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 800296c:	07a7      	lsls	r7, r4, #30
    sts |= SD_FRAMING_ERROR;
 800296e:	bf48      	it	mi
 8002970:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8002974:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 8002976:	bf48      	it	mi
 8002978:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800297c:	4852      	ldr	r0, [pc, #328]	; (8002ac8 <VectorD4+0x1b8>)
 800297e:	f7fe fb27 	bl	8000fd0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 8002982:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8002984:	6877      	ldr	r7, [r6, #4]
 8002986:	f895 a078 	ldrb.w	sl, [r5, #120]	; 0x78
    if (sr & USART_SR_RXNE)
 800298a:	d5df      	bpl.n	800294c <VectorD4+0x3c>
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800298c:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8002990:	2b00      	cmp	r3, #0
 8002992:	d03f      	beq.n	8002a14 <VectorD4+0x104>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8002994:	6a2b      	ldr	r3, [r5, #32]
 8002996:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002998:	4293      	cmp	r3, r2
 800299a:	d043      	beq.n	8002a24 <VectorD4+0x114>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800299c:	6969      	ldr	r1, [r5, #20]
  *iqp->q_wrptr++ = b;
 800299e:	1c5a      	adds	r2, r3, #1
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 80029a0:	ea0a 0707 	and.w	r7, sl, r7

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 80029a4:	3101      	adds	r1, #1
  *iqp->q_wrptr++ = b;
 80029a6:	622a      	str	r2, [r5, #32]

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 80029a8:	6169      	str	r1, [r5, #20]
  *iqp->q_wrptr++ = b;
 80029aa:	701f      	strb	r7, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80029ac:	6a2a      	ldr	r2, [r5, #32]
 80029ae:	69eb      	ldr	r3, [r5, #28]
 80029b0:	429a      	cmp	r2, r3
 80029b2:	d303      	bcc.n	80029bc <VectorD4+0xac>
    iqp->q_wrptr = iqp->q_buffer;
 80029b4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80029b8:	f8c8 3020 	str.w	r3, [r8, #32]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 80029bc:	4843      	ldr	r0, [pc, #268]	; (8002acc <VectorD4+0x1bc>)
 80029be:	f7ff ff8f 	bl	80028e0 <chThdDequeueNextI.constprop.49>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80029c2:	6834      	ldr	r4, [r6, #0]
 80029c4:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80029c6:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80029ca:	d1c4      	bne.n	8002956 <VectorD4+0x46>
 80029cc:	2300      	movs	r3, #0
 80029ce:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80029d2:	f019 0f80 	tst.w	r9, #128	; 0x80
 80029d6:	d001      	beq.n	80029dc <VectorD4+0xcc>
 80029d8:	0622      	lsls	r2, r4, #24
 80029da:	d43c      	bmi.n	8002a56 <VectorD4+0x146>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 80029dc:	0663      	lsls	r3, r4, #25
 80029de:	d515      	bpl.n	8002a0c <VectorD4+0xfc>
 80029e0:	2320      	movs	r3, #32
 80029e2:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 80029e6:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80029e8:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80029ea:	f241 0020 	movw	r0, #4128	; 0x1020
 80029ee:	429a      	cmp	r2, r3
 80029f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029f4:	d051      	beq.n	8002a9a <VectorD4+0x18a>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80029f6:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 80029fa:	ea09 0303 	and.w	r3, r9, r3
    u->SR = ~USART_SR_TC;
 80029fe:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002a02:	60f3      	str	r3, [r6, #12]
 8002a04:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8002a06:	6032      	str	r2, [r6, #0]
 8002a08:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8002a0c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8002a10:	f7fe b82e 	b.w	8000a70 <_port_irq_epilogue>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8002a14:	482c      	ldr	r0, [pc, #176]	; (8002ac8 <VectorD4+0x1b8>)
 8002a16:	2104      	movs	r1, #4
 8002a18:	f7fe fada 	bl	8000fd0 <chEvtBroadcastFlagsI>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8002a1c:	6a2b      	ldr	r3, [r5, #32]
 8002a1e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002a20:	4293      	cmp	r3, r2
 8002a22:	d1bb      	bne.n	800299c <VectorD4+0x8c>
 8002a24:	f8d8 2014 	ldr.w	r2, [r8, #20]
 8002a28:	2a00      	cmp	r2, #0
 8002a2a:	d0b7      	beq.n	800299c <VectorD4+0x8c>
 8002a2c:	4826      	ldr	r0, [pc, #152]	; (8002ac8 <VectorD4+0x1b8>)
 8002a2e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8002a32:	f7fe facd 	bl	8000fd0 <chEvtBroadcastFlagsI>
 8002a36:	e789      	b.n	800294c <VectorD4+0x3c>
 8002a38:	2320      	movs	r3, #32
 8002a3a:	f383 8811 	msr	BASEPRI, r3
 8002a3e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002a42:	1d28      	adds	r0, r5, #4
 8002a44:	f7fe fac4 	bl	8000fd0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8002a48:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8002a4c:	6033      	str	r3, [r6, #0]
 8002a4e:	2300      	movs	r3, #0
 8002a50:	f383 8811 	msr	BASEPRI, r3
 8002a54:	e76a      	b.n	800292c <VectorD4+0x1c>
 8002a56:	2320      	movs	r3, #32
 8002a58:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8002a5c:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8002a5e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8002a60:	f241 0020 	movw	r0, #4128	; 0x1020
 8002a64:	429a      	cmp	r2, r3
 8002a66:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a6a:	d01e      	beq.n	8002aaa <VectorD4+0x19a>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8002a6c:	6baa      	ldr	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a6e:	6c28      	ldr	r0, [r5, #64]	; 0x40
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002a70:	1c59      	adds	r1, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8002a72:	3201      	adds	r2, #1
 8002a74:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8002a76:	64a9      	str	r1, [r5, #72]	; 0x48

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8002a78:	f241 0220 	movw	r2, #4128	; 0x1020
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a7c:	4281      	cmp	r1, r0
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8002a7e:	781f      	ldrb	r7, [r3, #0]

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8002a80:	f2c2 0200 	movt	r2, #8192	; 0x2000
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8002a84:	d301      	bcc.n	8002a8a <VectorD4+0x17a>
    oqp->q_rdptr = oqp->q_buffer;
 8002a86:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8002a88:	6493      	str	r3, [r2, #72]	; 0x48
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8002a8a:	4811      	ldr	r0, [pc, #68]	; (8002ad0 <VectorD4+0x1c0>)
 8002a8c:	f7ff ff28 	bl	80028e0 <chThdDequeueNextI.constprop.49>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8002a90:	6077      	str	r7, [r6, #4]
 8002a92:	2300      	movs	r3, #0
 8002a94:	f383 8811 	msr	BASEPRI, r3
 8002a98:	e7a0      	b.n	80029dc <VectorD4+0xcc>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8002a9a:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002a9c:	2b00      	cmp	r3, #0
 8002a9e:	d0aa      	beq.n	80029f6 <VectorD4+0xe6>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8002aa0:	3004      	adds	r0, #4
 8002aa2:	2110      	movs	r1, #16
 8002aa4:	f7fe fa94 	bl	8000fd0 <chEvtBroadcastFlagsI>
 8002aa8:	e7a5      	b.n	80029f6 <VectorD4+0xe6>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8002aaa:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8002aac:	2a00      	cmp	r2, #0
 8002aae:	d0dd      	beq.n	8002a6c <VectorD4+0x15c>
 8002ab0:	3004      	adds	r0, #4
 8002ab2:	2108      	movs	r1, #8
 8002ab4:	f7fe fa8c 	bl	8000fd0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8002ab8:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8002abc:	ea09 0303 	and.w	r3, r9, r3
 8002ac0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002ac4:	60f3      	str	r3, [r6, #12]
 8002ac6:	e7e4      	b.n	8002a92 <VectorD4+0x182>
 8002ac8:	20001024 	.word	0x20001024
 8002acc:	2000102c 	.word	0x2000102c
 8002ad0:	20001050 	.word	0x20001050
 8002ad4:	f3af 8000 	nop.w
 8002ad8:	f3af 8000 	nop.w
 8002adc:	f3af 8000 	nop.w

08002ae0 <chMBFetchI.constprop.15>:

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002ae0:	f640 0338 	movw	r3, #2104	; 0x838
 8002ae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ae8:	7d1a      	ldrb	r2, [r3, #20]
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002aea:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002aec:	b9aa      	cbnz	r2, 8002b1a <chMBFetchI.constprop.15+0x3a>
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8002aee:	691a      	ldr	r2, [r3, #16]
 8002af0:	2a00      	cmp	r2, #0
 8002af2:	dd15      	ble.n	8002b20 <chMBFetchI.constprop.15+0x40>
    *msgp = *mbp->rdptr++;
 8002af4:	68da      	ldr	r2, [r3, #12]
    if (mbp->rdptr >= mbp->top) {
 8002af6:	6859      	ldr	r1, [r3, #4]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
    *msgp = *mbp->rdptr++;
 8002af8:	6814      	ldr	r4, [r2, #0]
 8002afa:	3204      	adds	r2, #4
    if (mbp->rdptr >= mbp->top) {
 8002afc:	428a      	cmp	r2, r1
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
    *msgp = *mbp->rdptr++;
 8002afe:	60da      	str	r2, [r3, #12]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
 8002b00:	bf28      	it	cs
 8002b02:	681a      	ldrcs	r2, [r3, #0]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
    *msgp = *mbp->rdptr++;
 8002b04:	6004      	str	r4, [r0, #0]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
 8002b06:	bf28      	it	cs
 8002b08:	60da      	strcs	r2, [r3, #12]
    }
    mbp->cnt--;
 8002b0a:	691a      	ldr	r2, [r3, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8002b0c:	4806      	ldr	r0, [pc, #24]	; (8002b28 <chMBFetchI.constprop.15+0x48>)
  if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
    *msgp = *mbp->rdptr++;
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
    }
    mbp->cnt--;
 8002b0e:	3a01      	subs	r2, #1
 8002b10:	611a      	str	r2, [r3, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8002b12:	f7ff fee5 	bl	80028e0 <chThdDequeueNextI.constprop.49>

    return MSG_OK;
 8002b16:	2000      	movs	r0, #0
 8002b18:	bd10      	pop	{r4, pc}
  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
    return MSG_RESET;
 8002b1a:	f06f 0001 	mvn.w	r0, #1
 8002b1e:	bd10      	pop	{r4, pc}

    return MSG_OK;
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
 8002b20:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002b24:	bd10      	pop	{r4, pc}
 8002b26:	bf00      	nop
 8002b28:	20000850 	.word	0x20000850
 8002b2c:	f3af 8000 	nop.w

08002b30 <chMBPostAheadI.constprop.17>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002b30:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002b32:	f640 0338 	movw	r3, #2104	; 0x838
 8002b36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b3a:	7d1a      	ldrb	r2, [r3, #20]
 8002b3c:	b9b2      	cbnz	r2, 8002b6c <chMBPostAheadI.constprop.17+0x3c>
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8002b3e:	691a      	ldr	r2, [r3, #16]
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8002b40:	e893 0012 	ldmia.w	r3, {r1, r4}
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8002b44:	1a65      	subs	r5, r4, r1
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8002b46:	ebc2 02a5 	rsb	r2, r2, r5, asr #2
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8002b4a:	2a00      	cmp	r2, #0
 8002b4c:	dd11      	ble.n	8002b72 <chMBPostAheadI.constprop.17+0x42>
    if (--mbp->rdptr < mbp->buffer) {
 8002b4e:	68da      	ldr	r2, [r3, #12]
 8002b50:	3a04      	subs	r2, #4
 8002b52:	4291      	cmp	r1, r2
      mbp->rdptr = mbp->top - 1;
 8002b54:	bf88      	it	hi
 8002b56:	1f22      	subhi	r2, r4, #4
 8002b58:	60da      	str	r2, [r3, #12]
    }
    *mbp->rdptr = msg;
 8002b5a:	6010      	str	r0, [r2, #0]
    mbp->cnt++;
 8002b5c:	691a      	ldr	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002b5e:	4806      	ldr	r0, [pc, #24]	; (8002b78 <chMBPostAheadI.constprop.17+0x48>)
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
    if (--mbp->rdptr < mbp->buffer) {
      mbp->rdptr = mbp->top - 1;
    }
    *mbp->rdptr = msg;
    mbp->cnt++;
 8002b60:	3201      	adds	r2, #1
 8002b62:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002b64:	f7ff febc 	bl	80028e0 <chThdDequeueNextI.constprop.49>

    return MSG_OK;
 8002b68:	2000      	movs	r0, #0
 8002b6a:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
    return MSG_RESET;
 8002b6c:	f06f 0001 	mvn.w	r0, #1
 8002b70:	bd38      	pop	{r3, r4, r5, pc}

    return MSG_OK;
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8002b72:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002b76:	bd38      	pop	{r3, r4, r5, pc}
 8002b78:	20000858 	.word	0x20000858
 8002b7c:	f3af 8000 	nop.w

08002b80 <chMBPostI.constprop.19>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002b80:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002b82:	f640 0338 	movw	r3, #2104	; 0x838
 8002b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b8a:	7d1a      	ldrb	r2, [r3, #20]
 8002b8c:	b9ba      	cbnz	r2, 8002bbe <chMBPostI.constprop.19+0x3e>
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8002b8e:	681d      	ldr	r5, [r3, #0]
 8002b90:	685a      	ldr	r2, [r3, #4]

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8002b92:	6919      	ldr	r1, [r3, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8002b94:	1b54      	subs	r4, r2, r5
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8002b96:	ebc1 01a4 	rsb	r1, r1, r4, asr #2
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 8002b9a:	2900      	cmp	r1, #0
 8002b9c:	dd12      	ble.n	8002bc4 <chMBPostI.constprop.19+0x44>
    *mbp->wrptr++ = msg;
 8002b9e:	689c      	ldr	r4, [r3, #8]
 8002ba0:	1d21      	adds	r1, r4, #4
 8002ba2:	6099      	str	r1, [r3, #8]
 8002ba4:	6020      	str	r0, [r4, #0]
    if (mbp->wrptr >= mbp->top) {
 8002ba6:	428a      	cmp	r2, r1
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8002ba8:	691a      	ldr	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002baa:	4808      	ldr	r0, [pc, #32]	; (8002bcc <chMBPostI.constprop.19+0x4c>)
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
    *mbp->wrptr++ = msg;
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8002bac:	f102 0201 	add.w	r2, r2, #1

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
    *mbp->wrptr++ = msg;
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
 8002bb0:	bf98      	it	ls
 8002bb2:	609d      	strls	r5, [r3, #8]
    }
    mbp->cnt++;
 8002bb4:	611a      	str	r2, [r3, #16]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002bb6:	f7ff fe93 	bl	80028e0 <chThdDequeueNextI.constprop.49>

    return MSG_OK;
 8002bba:	2000      	movs	r0, #0
 8002bbc:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
    return MSG_RESET;
 8002bbe:	f06f 0001 	mvn.w	r0, #1
 8002bc2:	bd38      	pop	{r3, r4, r5, pc}

    return MSG_OK;
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
 8002bc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002bc8:	bd38      	pop	{r3, r4, r5, pc}
 8002bca:	bf00      	nop
 8002bcc:	20000858 	.word	0x20000858

08002bd0 <chThdDequeueAllI.constprop.48>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8002bd0:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002bd2:	6803      	ldr	r3, [r0, #0]
 8002bd4:	4604      	mov	r4, r0

  while (queue_notempty(tqp)) {
 8002bd6:	4283      	cmp	r3, r0
 8002bd8:	d00b      	beq.n	8002bf2 <chThdDequeueAllI.constprop.48+0x22>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8002bda:	f06f 0501 	mvn.w	r5, #1
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002bde:	681a      	ldr	r2, [r3, #0]
  (void) chSchReadyI(tp);
 8002be0:	4618      	mov	r0, r3
 8002be2:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002be4:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8002be6:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8002be8:	f7fe f98a 	bl	8000f00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002bec:	6823      	ldr	r3, [r4, #0]
 8002bee:	42a3      	cmp	r3, r4
 8002bf0:	d1f5      	bne.n	8002bde <chThdDequeueAllI.constprop.48+0xe>
 8002bf2:	bd38      	pop	{r3, r4, r5, pc}
 8002bf4:	f3af 8000 	nop.w
 8002bf8:	f3af 8000 	nop.w
 8002bfc:	f3af 8000 	nop.w

08002c00 <chSemSignalWait.constprop.45>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8002c00:	b510      	push	{r4, lr}
 8002c02:	2320      	movs	r3, #32
 8002c04:	f383 8811 	msr	BASEPRI, r3
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 8002c08:	f640 74c8 	movw	r4, #4040	; 0xfc8
 8002c0c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8002c10:	68a3      	ldr	r3, [r4, #8]
 8002c12:	3301      	adds	r3, #1
 8002c14:	2b00      	cmp	r3, #0
 8002c16:	60a3      	str	r3, [r4, #8]
 8002c18:	dd21      	ble.n	8002c5e <chSemSignalWait.constprop.45+0x5e>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8002c1a:	3b01      	subs	r3, #1
 8002c1c:	f640 72c8 	movw	r2, #4040	; 0xfc8
 8002c20:	2b00      	cmp	r3, #0
 8002c22:	60a3      	str	r3, [r4, #8]
 8002c24:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002c28:	db06      	blt.n	8002c38 <chSemSignalWait.constprop.45+0x38>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8002c2a:	f7fd ffd9 	bl	8000be0 <chSchRescheduleS>
    msg = MSG_OK;
 8002c2e:	2000      	movs	r0, #0
 8002c30:	2300      	movs	r3, #0
 8002c32:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 8002c36:	bd10      	pop	{r4, pc}
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8002c38:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002c3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c40:	699c      	ldr	r4, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8002c42:	6853      	ldr	r3, [r2, #4]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8002c44:	2005      	movs	r0, #5
 8002c46:	e884 000c 	stmia.w	r4, {r2, r3}
  tp->queue.prev->queue.next = tp;
 8002c4a:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 8002c4c:	6262      	str	r2, [r4, #36]	; 0x24
  tqp->prev                  = tp;
 8002c4e:	6054      	str	r4, [r2, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8002c50:	f7fe f8be 	bl	8000dd0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8002c54:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002c56:	2300      	movs	r3, #0
 8002c58:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 8002c5c:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002c5e:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 8002c60:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002c62:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002c64:	6023      	str	r3, [r4, #0]
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8002c66:	f7fe f94b 	bl	8000f00 <chSchReadyI>
 8002c6a:	2300      	movs	r3, #0
 8002c6c:	6243      	str	r3, [r0, #36]	; 0x24
 8002c6e:	68a3      	ldr	r3, [r4, #8]
 8002c70:	e7d3      	b.n	8002c1a <chSemSignalWait.constprop.45+0x1a>
 8002c72:	bf00      	nop
 8002c74:	f3af 8000 	nop.w
 8002c78:	f3af 8000 	nop.w
 8002c7c:	f3af 8000 	nop.w

08002c80 <chCondSignal.constprop.42>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002c80:	b508      	push	{r3, lr}
 8002c82:	2320      	movs	r3, #32
 8002c84:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002c88:	f640 0364 	movw	r3, #2148	; 0x864
 8002c8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002c90:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->queue)) {
 8002c92:	4298      	cmp	r0, r3
 8002c94:	d005      	beq.n	8002ca2 <chCondSignal.constprop.42+0x22>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002c96:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 8002c98:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8002c9a:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002c9c:	601a      	str	r2, [r3, #0]
 8002c9e:	f7fe f83f 	bl	8000d20 <chSchWakeupS>
 8002ca2:	2300      	movs	r3, #0
 8002ca4:	f383 8811 	msr	BASEPRI, r3
 8002ca8:	bd08      	pop	{r3, pc}
 8002caa:	bf00      	nop
 8002cac:	f3af 8000 	nop.w

08002cb0 <chCondSignalI.constprop.41>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8002cb0:	f640 0364 	movw	r3, #2148	; 0x864
 8002cb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cb8:	681a      	ldr	r2, [r3, #0]
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8002cba:	b410      	push	{r4}

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8002cbc:	429a      	cmp	r2, r3
 8002cbe:	d009      	beq.n	8002cd4 <chCondSignalI.constprop.41+0x24>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002cc0:	6811      	ldr	r1, [r2, #0]
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 8002cc2:	2400      	movs	r4, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8002cc4:	604b      	str	r3, [r1, #4]
 8002cc6:	6254      	str	r4, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002cc8:	4610      	mov	r0, r2
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002cca:	6019      	str	r1, [r3, #0]
  }
}
 8002ccc:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 8002cd0:	f7fe b916 	b.w	8000f00 <chSchReadyI>
  }
}
 8002cd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002cd8:	4770      	bx	lr
 8002cda:	bf00      	nop
 8002cdc:	f3af 8000 	nop.w

08002ce0 <chEvtGetAndClearEvents.constprop.35>:
 8002ce0:	2320      	movs	r3, #32
 8002ce2:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8002ce6:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002cea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cee:	699a      	ldr	r2, [r3, #24]
  currp->epending &= ~events;
 8002cf0:	2300      	movs	r3, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8002cf2:	6b50      	ldr	r0, [r2, #52]	; 0x34
  currp->epending &= ~events;
 8002cf4:	6353      	str	r3, [r2, #52]	; 0x34
 8002cf6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002cfa:	4770      	bx	lr
 8002cfc:	f3af 8000 	nop.w

08002d00 <test_008_002_setup.9857>:
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void test_008_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d00:	f7ff bfee 	b.w	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 8002d04:	f3af 8000 	nop.w
 8002d08:	f3af 8000 	nop.w
 8002d0c:	f3af 8000 	nop.w

08002d10 <test_008_003_setup.9855>:
 *   emptied.
 * .
 */

static void test_008_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d10:	f7ff bfe6 	b.w	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 8002d14:	f3af 8000 	nop.w
 8002d18:	f3af 8000 	nop.w
 8002d1c:	f3af 8000 	nop.w

08002d20 <test_008_004_setup.9853>:
 *   emptied.
 * .
 */

static void test_008_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d20:	f7ff bfde 	b.w	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 8002d24:	f3af 8000 	nop.w
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <test_008_005_setup.9851>:
 *   has been emptied.
 * .
 */

static void test_008_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d30:	f7ff bfd6 	b.w	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 8002d34:	f3af 8000 	nop.w
 8002d38:	f3af 8000 	nop.w
 8002d3c:	f3af 8000 	nop.w

08002d40 <test_008_006_setup.9849>:
 *   timeout condition is tested.
 * .
 */

static void test_008_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d40:	f7ff bfce 	b.w	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 8002d44:	f3af 8000 	nop.w
 8002d48:	f3af 8000 	nop.w
 8002d4c:	f3af 8000 	nop.w

08002d50 <test_008_007_setup.9847>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_008_007_setup(void) {
 8002d50:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002d52:	f7ff ffc5 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8002d56:	f640 0260 	movw	r2, #2144	; 0x860
 8002d5a:	f640 0334 	movw	r3, #2100	; 0x834
 8002d5e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d66:	6012      	str	r2, [r2, #0]
 8002d68:	601b      	str	r3, [r3, #0]
 8002d6a:	bd08      	pop	{r3, pc}
 8002d6c:	f3af 8000 	nop.w

08002d70 <chEvtWaitOne.constprop.31>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 8002d70:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002d74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002d78:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8002d7a:	699c      	ldr	r4, [r3, #24]
 8002d7c:	2320      	movs	r3, #32
 8002d7e:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002d82:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002d84:	b933      	cbnz	r3, 8002d94 <chEvtWaitOne.constprop.31+0x24>
    ctp->u.ewmask = events;
 8002d86:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002d8a:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002d8c:	200a      	movs	r0, #10
 8002d8e:	f7fe f81f 	bl	8000dd0 <chSchGoSleepS>
    m = ctp->epending & events;
 8002d92:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8002d94:	4258      	negs	r0, r3
 8002d96:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8002d98:	ea23 0300 	bic.w	r3, r3, r0
 8002d9c:	6363      	str	r3, [r4, #52]	; 0x34
 8002d9e:	2300      	movs	r3, #0
 8002da0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002da4:	bd10      	pop	{r4, pc}
 8002da6:	bf00      	nop
 8002da8:	f3af 8000 	nop.w
 8002dac:	f3af 8000 	nop.w

08002db0 <chEvtWaitAny.constprop.30>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8002db0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002db4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8002db8:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8002dba:	699c      	ldr	r4, [r3, #24]
 8002dbc:	2320      	movs	r3, #32
 8002dbe:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002dc2:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002dc4:	b930      	cbnz	r0, 8002dd4 <chEvtWaitAny.constprop.30+0x24>
    ctp->u.ewmask = events;
 8002dc6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002dca:	200a      	movs	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
    ctp->u.ewmask = events;
 8002dcc:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002dce:	f7fd ffff 	bl	8000dd0 <chSchGoSleepS>
    m = ctp->epending & events;
 8002dd2:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 8002dd4:	2300      	movs	r3, #0
 8002dd6:	6363      	str	r3, [r4, #52]	; 0x34
 8002dd8:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002ddc:	bd10      	pop	{r4, pc}
 8002dde:	bf00      	nop

08002de0 <chEvtWaitAll.constprop.29>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8002de0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8002de4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002de8:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8002dea:	699c      	ldr	r4, [r3, #24]
 8002dec:	2320      	movs	r3, #32
 8002dee:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 8002df2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002df4:	f003 0205 	and.w	r2, r3, #5
 8002df8:	2a05      	cmp	r2, #5
 8002dfa:	d005      	beq.n	8002e08 <chEvtWaitAll.constprop.29+0x28>
    ctp->u.ewmask = events;
 8002dfc:	2305      	movs	r3, #5
 8002dfe:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002e00:	200b      	movs	r0, #11
 8002e02:	f7fd ffe5 	bl	8000dd0 <chSchGoSleepS>
 8002e06:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 8002e08:	f023 0305 	bic.w	r3, r3, #5
 8002e0c:	6363      	str	r3, [r4, #52]	; 0x34
 8002e0e:	2300      	movs	r3, #0
 8002e10:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 8002e14:	2005      	movs	r0, #5
 8002e16:	bd10      	pop	{r4, pc}
 8002e18:	f3af 8000 	nop.w
 8002e1c:	f3af 8000 	nop.w

08002e20 <chThdCreateFromHeap.constprop.24>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8002e20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002e24:	4605      	mov	r5, r0
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002e26:	f640 1020 	movw	r0, #2336	; 0x920
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8002e2a:	b086      	sub	sp, #24
 8002e2c:	460e      	mov	r6, r1
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002e2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002e32:	4629      	mov	r1, r5
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8002e34:	4690      	mov	r8, r2
 8002e36:	461f      	mov	r7, r3
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002e38:	f7ff fa12 	bl	8002260 <chHeapAllocAligned.constprop.25.4351>
  if (wsp == NULL) {
 8002e3c:	b1e0      	cbz	r0, 8002e78 <chThdCreateFromHeap.constprop.24+0x58>
    return NULL;
  }

  thread_descriptor_t td = {
 8002e3e:	f240 54e1 	movw	r4, #1505	; 0x5e1
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 8002e42:	4405      	add	r5, r0
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8002e44:	f6c0 0400 	movt	r4, #2048	; 0x800
 8002e48:	9502      	str	r5, [sp, #8]
 8002e4a:	9600      	str	r6, [sp, #0]
 8002e4c:	9001      	str	r0, [sp, #4]
 8002e4e:	f8cd 800c 	str.w	r8, [sp, #12]
 8002e52:	9705      	str	r7, [sp, #20]
 8002e54:	9404      	str	r4, [sp, #16]
 8002e56:	2320      	movs	r3, #32
 8002e58:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002e5c:	4668      	mov	r0, sp
 8002e5e:	f7fd fe77 	bl	8000b50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8002e62:	2301      	movs	r3, #1
 8002e64:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8002e68:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002e6a:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8002e6c:	f7fd ff58 	bl	8000d20 <chSchWakeupS>
 8002e70:	2300      	movs	r3, #0
 8002e72:	f383 8811 	msr	BASEPRI, r3
 8002e76:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 8002e78:	b006      	add	sp, #24
 8002e7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002e7e:	bf00      	nop

08002e80 <chThdCreateFromMemoryPool.constprop.23>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8002e80:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002e82:	f640 1440 	movw	r4, #2368	; 0x940
 8002e86:	f2c2 0400 	movt	r4, #8192	; 0x2000
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8002e8a:	b087      	sub	sp, #28
 8002e8c:	4605      	mov	r5, r0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002e8e:	4620      	mov	r0, r4
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8002e90:	460f      	mov	r7, r1
 8002e92:	4616      	mov	r6, r2
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8002e94:	f7fd fe1c 	bl	8000ad0 <chPoolAlloc>
  if (wsp == NULL) {
 8002e98:	b1e8      	cbz	r0, 8002ed6 <chThdCreateFromMemoryPool.constprop.23+0x56>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8002e9a:	6862      	ldr	r2, [r4, #4]
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8002e9c:	f240 53e1 	movw	r3, #1505	; 0x5e1
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8002ea0:	4402      	add	r2, r0
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8002ea2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002ea6:	9304      	str	r3, [sp, #16]
 8002ea8:	9500      	str	r5, [sp, #0]
 8002eaa:	9001      	str	r0, [sp, #4]
 8002eac:	9703      	str	r7, [sp, #12]
 8002eae:	9605      	str	r6, [sp, #20]
 8002eb0:	9202      	str	r2, [sp, #8]
 8002eb2:	2320      	movs	r3, #32
 8002eb4:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002eb8:	4668      	mov	r0, sp
 8002eba:	f7fd fe49 	bl	8000b50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8002ebe:	2302      	movs	r3, #2
 8002ec0:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 8002ec4:	6404      	str	r4, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8002ec6:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002ec8:	4605      	mov	r5, r0
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8002eca:	f7fd ff29 	bl	8000d20 <chSchWakeupS>
 8002ece:	2300      	movs	r3, #0
 8002ed0:	f383 8811 	msr	BASEPRI, r3
 8002ed4:	4628      	mov	r0, r5
  chSysUnlock();

  return tp;
}
 8002ed6:	b007      	add	sp, #28
 8002ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002eda:	bf00      	nop
 8002edc:	f3af 8000 	nop.w

08002ee0 <_test_assert_time_window.constprop.2>:
 8002ee0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ee4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002ee6:	1a09      	subs	r1, r1, r0
 8002ee8:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8002eea:	b289      	uxth	r1, r1
 8002eec:	b29b      	uxth	r3, r3
 8002eee:	428b      	cmp	r3, r1
  clear_tokens();

  return false;
}

bool _test_assert_time_window(systime_t start,
 8002ef0:	b410      	push	{r4}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 8002ef2:	bf38      	it	cc
 8002ef4:	2000      	movcc	r0, #0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8002ef6:	d313      	bcc.n	8002f20 <_test_assert_time_window.constprop.2+0x40>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8002ef8:	f241 0414 	movw	r4, #4116	; 0x1014
  test_global_fail     = true;
 8002efc:	f241 011c 	movw	r1, #4124	; 0x101c
  test_failure_message = msg;
 8002f00:	f241 0318 	movw	r3, #4120	; 0x1018
 8002f04:	f247 7254 	movw	r2, #30548	; 0x7754
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8002f08:	2001      	movs	r0, #1
 8002f0a:	f2c2 0400 	movt	r4, #8192	; 0x2000
  test_global_fail     = true;
 8002f0e:	f2c2 0100 	movt	r1, #8192	; 0x2000
  test_failure_message = msg;
 8002f12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f16:	f6c0 0200 	movt	r2, #2048	; 0x800
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8002f1a:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8002f1c:	7008      	strb	r0, [r1, #0]
  test_failure_message = msg;
 8002f1e:	601a      	str	r2, [r3, #0]
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 8002f20:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002f24:	4770      	bx	lr
 8002f26:	bf00      	nop
 8002f28:	f3af 8000 	nop.w
 8002f2c:	f3af 8000 	nop.w

08002f30 <test_008_001_execute.9861>:
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_008_001_execute(void) {
 8002f30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f32:	f640 0360 	movw	r3, #2144	; 0x860
    chEvtObjectInit(&es1);
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8002f36:	f241 3530 	movw	r5, #4912	; 0x1330
 8002f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002f3e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8002f42:	2202      	movs	r2, #2
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_008_001_execute(void) {
 8002f44:	b08b      	sub	sp, #44	; 0x2c
 8002f46:	601b      	str	r3, [r3, #0]
    chEvtObjectInit(&es1);
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8002f48:	602a      	str	r2, [r5, #0]
 8002f4a:	2320      	movs	r3, #32
 8002f4c:	f383 8811 	msr	BASEPRI, r3
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f50:	f640 0360 	movw	r3, #2144	; 0x860
 8002f54:	f2c2 0300 	movt	r3, #8192	; 0x2000
  esp->next     = elp;
  elp->listener = currp;
 8002f58:	f241 22c0 	movw	r2, #4800	; 0x12c0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f5c:	6818      	ldr	r0, [r3, #0]
  esp->next     = elp;
  elp->listener = currp;
 8002f5e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002f62:	6991      	ldr	r1, [r2, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f64:	ae0a      	add	r6, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8002f66:	2701      	movs	r7, #1
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002f68:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f6c:	f846 0d28 	str.w	r0, [r6, #-40]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002f70:	2200      	movs	r2, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8002f72:	9101      	str	r1, [sp, #4]
  elp->events   = events;
 8002f74:	9702      	str	r7, [sp, #8]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002f76:	9404      	str	r4, [sp, #16]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8002f78:	601e      	str	r6, [r3, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002f7a:	9203      	str	r2, [sp, #12]
 8002f7c:	f382 8811 	msr	BASEPRI, r2
 8002f80:	2320      	movs	r3, #32
 8002f82:	f383 8811 	msr	BASEPRI, r3
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f86:	f640 0360 	movw	r3, #2144	; 0x860
  esp->next     = elp;
  elp->listener = currp;
 8002f8a:	f241 22c0 	movw	r2, #4800	; 0x12c0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
  esp->next     = elp;
  elp->listener = currp;
 8002f92:	f2c2 0200 	movt	r2, #8192	; 0x2000
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f96:	6818      	ldr	r0, [r3, #0]
  esp->next     = elp;
  elp->listener = currp;
 8002f98:	6992      	ldr	r2, [r2, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002f9a:	af0a      	add	r7, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
 8002f9c:	9206      	str	r2, [sp, #24]
  elp->events   = events;
 8002f9e:	2102      	movs	r1, #2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002fa0:	f847 0d14 	str.w	r0, [r7, #-20]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002fa4:	2200      	movs	r2, #0

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8002fa6:	9107      	str	r1, [sp, #28]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002fa8:	9409      	str	r4, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8002faa:	601f      	str	r7, [r3, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002fac:	9208      	str	r2, [sp, #32]
 8002fae:	f382 8811 	msr	BASEPRI, r2
 8002fb2:	2320      	movs	r3, #32
 8002fb4:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8002fb8:	f640 0460 	movw	r4, #2144	; 0x860
 8002fbc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8002fc0:	6820      	ldr	r0, [r4, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
    chEvtRegisterMask(&es1, &el2, 2);
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8002fc2:	f247 7174 	movw	r1, #30580	; 0x7774
 8002fc6:	1b00      	subs	r0, r0, r4
 8002fc8:	bf18      	it	ne
 8002fca:	2001      	movne	r0, #1
 8002fcc:	f6c0 0100 	movt	r1, #2048	; 0x800
 8002fd0:	f7fd fb96 	bl	8000700 <_test_assert>
 8002fd4:	b120      	cbz	r0, 8002fe0 <test_008_001_execute.9861+0xb0>
 8002fd6:	2300      	movs	r3, #0
 8002fd8:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 8002fdc:	b00b      	add	sp, #44	; 0x2c
 8002fde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fe0:	f380 8811 	msr	BASEPRI, r0

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
  {
    chEvtUnregister(&es1, &el1);
 8002fe4:	f640 0060 	movw	r0, #2144	; 0x860
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8002fe8:	2303      	movs	r3, #3
  {
    chEvtUnregister(&es1, &el1);
 8002fea:	4669      	mov	r1, sp
 8002fec:	f2c2 0000 	movt	r0, #8192	; 0x2000
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8002ff0:	602b      	str	r3, [r5, #0]
  {
    chEvtUnregister(&es1, &el1);
 8002ff2:	f7fd fd95 	bl	8000b20 <chEvtUnregister>
 8002ff6:	2320      	movs	r3, #32
 8002ff8:	f383 8811 	msr	BASEPRI, r3
 8002ffc:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8002ffe:	f247 7174 	movw	r1, #30580	; 0x7774
 8003002:	1b00      	subs	r0, r0, r4
 8003004:	bf18      	it	ne
 8003006:	2001      	movne	r0, #1
 8003008:	f6c0 0100 	movt	r1, #2048	; 0x800
 800300c:	f7fd fb78 	bl	8000700 <_test_assert>
 8003010:	2800      	cmp	r0, #0
 8003012:	d1e0      	bne.n	8002fd6 <test_008_001_execute.9861+0xa6>
 8003014:	f380 8811 	msr	BASEPRI, r0

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
 8003018:	f640 0060 	movw	r0, #2144	; 0x860
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 800301c:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el2);
 800301e:	4639      	mov	r1, r7
 8003020:	f2c2 0000 	movt	r0, #8192	; 0x2000
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8003024:	602b      	str	r3, [r5, #0]
  {
    chEvtUnregister(&es1, &el2);
 8003026:	f7fd fd7b 	bl	8000b20 <chEvtUnregister>
 800302a:	2320      	movs	r3, #32
 800302c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8003030:	6820      	ldr	r0, [r4, #0]
 8003032:	f247 7180 	movw	r1, #30592	; 0x7780
 8003036:	1b03      	subs	r3, r0, r4
 8003038:	4258      	negs	r0, r3
 800303a:	4158      	adcs	r0, r3
 800303c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003040:	f7fd fb5e 	bl	8000700 <_test_assert>
 8003044:	2800      	cmp	r0, #0
 8003046:	d1c6      	bne.n	8002fd6 <test_008_001_execute.9861+0xa6>
 8003048:	f380 8811 	msr	BASEPRI, r0
 800304c:	e7c6      	b.n	8002fdc <test_008_001_execute.9861+0xac>
 800304e:	bf00      	nop

08003050 <test_010_002_execute.10261>:

static void test_010_002_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_010_002_execute(void) {
 8003050:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  unsigned i;

  /* [10.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 8003054:	f241 3830 	movw	r8, #4912	; 0x1330
 8003058:	f640 041c 	movw	r4, #2076	; 0x81c
 800305c:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8003060:	2301      	movs	r3, #1
 8003062:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003066:	f640 1500 	movw	r5, #2304	; 0x900
 800306a:	f8c8 3000 	str.w	r3, [r8]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 800306e:	46a2      	mov	sl, r4
 8003070:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003074:	2604      	movs	r6, #4
 8003076:	f04f 0920 	mov.w	r9, #32
 800307a:	2700      	movs	r7, #0
 800307c:	f389 8811 	msr	BASEPRI, r9
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003080:	68e3      	ldr	r3, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003082:	f640 001c 	movw	r0, #2076	; 0x81c
 8003086:	f2c2 0000 	movt	r0, #8192	; 0x2000
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800308a:	602b      	str	r3, [r5, #0]
  mp->next = php;
 800308c:	60e5      	str	r5, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 800308e:	f7fe f94f 	bl	8001330 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8003092:	f7fd fda5 	bl	8000be0 <chSchRescheduleS>
 8003096:	f387 8811 	msr	BASEPRI, r7
  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 800309a:	f8da 3010 	ldr.w	r3, [sl, #16]
 800309e:	f640 041c 	movw	r4, #2076	; 0x81c
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 80030a2:	3e01      	subs	r6, #1
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 80030a4:	441d      	add	r5, r3
 80030a6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 80030aa:	d1e7      	bne.n	800307c <test_010_002_execute.10261+0x2c>
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
  }

  /* [10.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 80030ac:	2302      	movs	r3, #2
 80030ae:	f8c8 3000 	str.w	r3, [r8]
 80030b2:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 80030b4:	2000      	movs	r0, #0
 80030b6:	f7fe ff33 	bl	8001f20 <chGuardedPoolAllocTimeout.constprop.11>
 80030ba:	f247 7190 	movw	r1, #30608	; 0x7790
 80030be:	3000      	adds	r0, #0
 80030c0:	bf18      	it	ne
 80030c2:	2001      	movne	r0, #1
 80030c4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80030c8:	f7fd fb1a 	bl	8000700 <_test_assert>
 80030cc:	2800      	cmp	r0, #0
 80030ce:	d156      	bne.n	800317e <test_010_002_execute.10261+0x12e>
  }

  /* [10.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80030d0:	3d01      	subs	r5, #1
 80030d2:	d1ef      	bne.n	80030b4 <test_010_002_execute.10261+0x64>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.3] Now must be empty.*/
  test_set_step(3);
 80030d4:	2303      	movs	r3, #3
 80030d6:	f8c8 3000 	str.w	r3, [r8]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80030da:	f7fe ff21 	bl	8001f20 <chGuardedPoolAllocTimeout.constprop.11>
 80030de:	f247 6160 	movw	r1, #30304	; 0x7660
 80030e2:	f1d0 0001 	rsbs	r0, r0, #1
 80030e6:	bf38      	it	cc
 80030e8:	2000      	movcc	r0, #0
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.3] Now must be empty.*/
  test_set_step(3);
 80030ea:	f241 3730 	movw	r7, #4912	; 0x1330
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80030ee:	f6c0 0100 	movt	r1, #2048	; 0x800
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.3] Now must be empty.*/
  test_set_step(3);
 80030f2:	f2c2 0700 	movt	r7, #8192	; 0x2000
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80030f6:	f7fd fb03 	bl	8000700 <_test_assert>
 80030fa:	2800      	cmp	r0, #0
 80030fc:	d13f      	bne.n	800317e <test_010_002_execute.10261+0x12e>
 80030fe:	f640 1600 	movw	r6, #2304	; 0x900
 8003102:	f2c2 0600 	movt	r6, #8192	; 0x2000
  }

  /* [10.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 8003106:	2304      	movs	r3, #4
 8003108:	603b      	str	r3, [r7, #0]
 800310a:	f106 0910 	add.w	r9, r6, #16
 800310e:	2720      	movs	r7, #32
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      chGuardedPoolFree(&gmp1, &objects[i]);
 8003110:	4632      	mov	r2, r6
 8003112:	f387 8811 	msr	BASEPRI, r7
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003116:	68e3      	ldr	r3, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003118:	f640 001c 	movw	r0, #2076	; 0x81c
 800311c:	f2c2 0000 	movt	r0, #8192	; 0x2000
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003120:	f846 3b04 	str.w	r3, [r6], #4
  mp->next = php;
 8003124:	60e2      	str	r2, [r4, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8003126:	f7fe f903 	bl	8001330 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 800312a:	f7fd fd59 	bl	8000be0 <chSchRescheduleS>
 800312e:	f385 8811 	msr	BASEPRI, r5

  /* [10.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8003132:	454e      	cmp	r6, r9
 8003134:	d1ec      	bne.n	8003110 <test_010_002_execute.10261+0xc0>
      chGuardedPoolFree(&gmp1, &objects[i]);
  }

  /* [10.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 8003136:	2305      	movs	r3, #5
 8003138:	f8c8 3000 	str.w	r3, [r8]
 800313c:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800313e:	2000      	movs	r0, #0
 8003140:	f7fe feee 	bl	8001f20 <chGuardedPoolAllocTimeout.constprop.11>
 8003144:	f247 7190 	movw	r1, #30608	; 0x7790
 8003148:	3000      	adds	r0, #0
 800314a:	bf18      	it	ne
 800314c:	2001      	movne	r0, #1
 800314e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003152:	f7fd fad5 	bl	8000700 <_test_assert>
 8003156:	b990      	cbnz	r0, 800317e <test_010_002_execute.10261+0x12e>

  /* [10.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8003158:	3c01      	subs	r4, #1
 800315a:	d1f0      	bne.n	800313e <test_010_002_execute.10261+0xee>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [10.2.6] Now must be empty again.*/
  test_set_step(6);
 800315c:	2306      	movs	r3, #6
 800315e:	f8c8 3000 	str.w	r3, [r8]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8003162:	f7fe fedd 	bl	8001f20 <chGuardedPoolAllocTimeout.constprop.11>
  }
}
 8003166:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  }

  /* [10.2.6] Now must be empty again.*/
  test_set_step(6);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800316a:	f247 6160 	movw	r1, #30304	; 0x7660
 800316e:	f1d0 0001 	rsbs	r0, r0, #1
 8003172:	bf38      	it	cc
 8003174:	2000      	movcc	r0, #0
 8003176:	f6c0 0100 	movt	r1, #2048	; 0x800
 800317a:	f7fd bac1 	b.w	8000700 <_test_assert>
 800317e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003182:	bf00      	nop
 8003184:	f3af 8000 	nop.w
 8003188:	f3af 8000 	nop.w
 800318c:	f3af 8000 	nop.w

08003190 <bmk_thread1.10696.4193>:
#endif

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 8003190:	b570      	push	{r4, r5, r6, lr}
 8003192:	2620      	movs	r6, #32
 8003194:	2500      	movs	r5, #0
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8003196:	f7fd fe33 	bl	8000e00 <chMsgWait>

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
  thread_t *tp;
 800319a:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800319c:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 80031a0:	4621      	mov	r1, r4
 80031a2:	f7fd fdbd 	bl	8000d20 <chSchWakeupS>
 80031a6:	f385 8811 	msr	BASEPRI, r5
  (void)p;
  do {
    tp = chMsgWait();
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 80031aa:	2c00      	cmp	r4, #0
 80031ac:	d1f3      	bne.n	8003196 <bmk_thread1.10696.4193+0x6>
}
 80031ae:	bd70      	pop	{r4, r5, r6, pc}

080031b0 <vtcb.8639>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 80031b0:	b508      	push	{r3, lr}
 80031b2:	2320      	movs	r3, #32
 80031b4:	f383 8811 	msr	BASEPRI, r3
 80031b8:	2300      	movs	r3, #0
 80031ba:	f383 8811 	msr	BASEPRI, r3
 80031be:	2320      	movs	r3, #32
 80031c0:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80031c4:	f3ef 8311 	mrs	r3, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 80031c8:	b91b      	cbnz	r3, 80031d2 <vtcb.8639+0x22>
 80031ca:	f7fe f959 	bl	8001480 <chSysGetStatusAndLockX.part.1.4323>
 80031ce:	f7fd fd97 	bl	8000d00 <chSysRestoreStatusX.part.2.4326>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80031d2:	2300      	movs	r3, #0
 80031d4:	f383 8811 	msr	BASEPRI, r3
 80031d8:	bd08      	pop	{r3, pc}
 80031da:	bf00      	nop
 80031dc:	f3af 8000 	nop.w

080031e0 <test_010_001_execute.10265>:

static void test_010_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}

static void test_010_001_execute(void) {
 80031e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;

  /* [10.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 80031e2:	f241 3630 	movw	r6, #4912	; 0x1330
 80031e6:	f640 0410 	movw	r4, #2064	; 0x810
 80031ea:	2201      	movs	r2, #1
 80031ec:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80031f0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80031f4:	f640 1300 	movw	r3, #2304	; 0x900
 80031f8:	6032      	str	r2, [r6, #0]
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80031fa:	4627      	mov	r7, r4
 80031fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003200:	2204      	movs	r2, #4
 8003202:	2520      	movs	r5, #32
 8003204:	2000      	movs	r0, #0
 8003206:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800320a:	6821      	ldr	r1, [r4, #0]
  mp->next = php;
 800320c:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800320e:	6019      	str	r1, [r3, #0]
 8003210:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8003214:	6879      	ldr	r1, [r7, #4]
 8003216:	f640 0410 	movw	r4, #2064	; 0x810
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 800321a:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 800321c:	440b      	add	r3, r1
 800321e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003222:	d1f0      	bne.n	8003206 <test_010_001_execute.10265+0x26>
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
  }

  /* [10.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 8003224:	2302      	movs	r3, #2
 8003226:	6033      	str	r3, [r6, #0]
 8003228:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800322a:	f640 0010 	movw	r0, #2064	; 0x810
 800322e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003232:	f7fd fc4d 	bl	8000ad0 <chPoolAlloc>
 8003236:	f247 7190 	movw	r1, #30608	; 0x7790
 800323a:	3000      	adds	r0, #0
 800323c:	bf18      	it	ne
 800323e:	2001      	movne	r0, #1
 8003240:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003244:	f7fd fa5c 	bl	8000700 <_test_assert>
 8003248:	2800      	cmp	r0, #0
 800324a:	d156      	bne.n	80032fa <test_010_001_execute.10265+0x11a>
  }

  /* [10.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 800324c:	3d01      	subs	r5, #1
 800324e:	d1ec      	bne.n	800322a <test_010_001_execute.10265+0x4a>
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8003250:	f640 0010 	movw	r0, #2064	; 0x810
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
 8003254:	2303      	movs	r3, #3
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8003256:	f2c2 0000 	movt	r0, #8192	; 0x2000
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
 800325a:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800325c:	f7fd fc38 	bl	8000ad0 <chPoolAlloc>
 8003260:	f247 6160 	movw	r1, #30304	; 0x7660
 8003264:	f1d0 0001 	rsbs	r0, r0, #1
 8003268:	bf38      	it	cc
 800326a:	2000      	movcc	r0, #0
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
 800326c:	f241 3730 	movw	r7, #4912	; 0x1330
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8003270:	f6c0 0100 	movt	r1, #2048	; 0x800
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.3] Now must be empty.*/
  test_set_step(3);
 8003274:	f2c2 0700 	movt	r7, #8192	; 0x2000
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8003278:	f7fd fa42 	bl	8000700 <_test_assert>
 800327c:	2800      	cmp	r0, #0
 800327e:	d13c      	bne.n	80032fa <test_010_001_execute.10265+0x11a>
 8003280:	f640 1300 	movw	r3, #2304	; 0x900
 8003284:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [10.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 8003288:	2204      	movs	r2, #4
 800328a:	f103 0e10 	add.w	lr, r3, #16
 800328e:	603a      	str	r2, [r7, #0]
 8003290:	2020      	movs	r0, #32
 8003292:	f380 8811 	msr	BASEPRI, r0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003296:	6822      	ldr	r2, [r4, #0]
  mp->next = php;
 8003298:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800329a:	f843 2b04 	str.w	r2, [r3], #4
 800329e:	f385 8811 	msr	BASEPRI, r5
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80032a2:	4573      	cmp	r3, lr
 80032a4:	d1f5      	bne.n	8003292 <test_010_001_execute.10265+0xb2>
      chPoolFree(&mp1, &objects[i]);
  }

  /* [10.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 80032a6:	2305      	movs	r3, #5
 80032a8:	6033      	str	r3, [r6, #0]
 80032aa:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80032ac:	f640 0410 	movw	r4, #2064	; 0x810
 80032b0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80032b4:	4620      	mov	r0, r4
 80032b6:	f7fd fc0b 	bl	8000ad0 <chPoolAlloc>
 80032ba:	f247 7190 	movw	r1, #30608	; 0x7790
 80032be:	3000      	adds	r0, #0
 80032c0:	bf18      	it	ne
 80032c2:	2001      	movne	r0, #1
 80032c4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80032c8:	f7fd fa1a 	bl	8000700 <_test_assert>
 80032cc:	b9a8      	cbnz	r0, 80032fa <test_010_001_execute.10265+0x11a>
  }

  /* [10.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80032ce:	3d01      	subs	r5, #1
 80032d0:	d1ec      	bne.n	80032ac <test_010_001_execute.10265+0xcc>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.6] Now must be empty again.*/
  test_set_step(6);
 80032d2:	2306      	movs	r3, #6
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80032d4:	4620      	mov	r0, r4
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.6] Now must be empty again.*/
  test_set_step(6);
 80032d6:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80032d8:	f7fd fbfa 	bl	8000ad0 <chPoolAlloc>
 80032dc:	f247 6160 	movw	r1, #30304	; 0x7660
 80032e0:	f1d0 0001 	rsbs	r0, r0, #1
 80032e4:	bf38      	it	cc
 80032e6:	2000      	movcc	r0, #0
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.6] Now must be empty again.*/
  test_set_step(6);
 80032e8:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80032ec:	f6c0 0100 	movt	r1, #2048	; 0x800
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [10.1.6] Now must be empty again.*/
  test_set_step(6);
 80032f0:	f2c2 0600 	movt	r6, #8192	; 0x2000
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80032f4:	f7fd fa04 	bl	8000700 <_test_assert>
 80032f8:	b100      	cbz	r0, 80032fc <test_010_001_execute.10265+0x11c>
 80032fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
  mp->provider = provider;
 80032fc:	f240 23b1 	movw	r3, #689	; 0x2b1
 8003300:	f6c0 0300 	movt	r3, #2048	; 0x800
  }

  /* [10.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 8003304:	2107      	movs	r1, #7
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 8003306:	2204      	movs	r2, #4
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8003308:	4620      	mov	r0, r4
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
  }

  /* [10.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 800330a:	6031      	str	r1, [r6, #0]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 800330c:	6025      	str	r5, [r4, #0]
  mp->object_size = size;
  mp->provider = provider;
 800330e:	60a3      	str	r3, [r4, #8]
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 8003310:	6062      	str	r2, [r4, #4]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8003312:	f7fd fbdd 	bl	8000ad0 <chPoolAlloc>
  }
}
 8003316:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [10.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800331a:	f247 719c 	movw	r1, #30620	; 0x779c
 800331e:	f1d0 0001 	rsbs	r0, r0, #1
 8003322:	bf38      	it	cc
 8003324:	2000      	movcc	r0, #0
 8003326:	f6c0 0100 	movt	r1, #2048	; 0x800
 800332a:	f7fd b9e9 	b.w	8000700 <_test_assert>
 800332e:	bf00      	nop

08003330 <test_013_006_execute.10717>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003330:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8003334:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003338:	699b      	ldr	r3, [r3, #24]
 *   one-second time window.
 * - [13.6.2] Score is printed.
 * .
 */

static void test_013_006_execute(void) {
 800333a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 800333e:	689f      	ldr	r7, [r3, #8]
  systime_t start, end;

  /* [13.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8003340:	f241 3830 	movw	r8, #4912	; 0x1330
 8003344:	2301      	movs	r3, #1
 8003346:	f2c2 0800 	movt	r8, #8192	; 0x2000
 * .
 */

static void test_013_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 800334a:	441f      	add	r7, r3
  systime_t start, end;

  /* [13.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800334c:	f8c8 3000 	str.w	r3, [r8]
  {
    n = 0;
    start = test_wait_tick();
 8003350:	f001 fe0e 	bl	8004f70 <test_wait_tick>
  /* [13.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 8003354:	2400      	movs	r4, #0
    start = test_wait_tick();
 8003356:	4606      	mov	r6, r0
 8003358:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800335c:	f640 1050 	movw	r0, #2384	; 0x950
 8003360:	f646 62d1 	movw	r2, #28369	; 0x6ed1
 8003364:	2300      	movs	r3, #0
 8003366:	f6c0 0200 	movt	r2, #2048	; 0x800
 800336a:	4639      	mov	r1, r7
 800336c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003370:	f002 face 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003374:	f002 fbec 	bl	8005b50 <chThdRelease>
 8003378:	6a6b      	ldr	r3, [r5, #36]	; 0x24
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 800337a:	3401      	adds	r4, #1
 800337c:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800337e:	b29b      	uxth	r3, r3
 8003380:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8003384:	d3ea      	bcc.n	800335c <test_013_006_execute.10717+0x2c>
  }

  /* [13.6.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
 8003386:	f247 601c 	movw	r0, #30236	; 0x761c
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.6.2] Score is printed.*/
  test_set_step(2);
 800338a:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800338c:	f6c0 0000 	movt	r0, #2048	; 0x800
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.6.2] Score is printed.*/
  test_set_step(2);
 8003390:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 8003394:	f7fd f96c 	bl	8000670 <test_print>
    test_printn(n);
 8003398:	4620      	mov	r0, r4
 800339a:	f7fd fa41 	bl	8000820 <test_printn>
    test_println(" threads/S");
  }
}
 800339e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [13.6.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 80033a2:	f247 70b8 	movw	r0, #30648	; 0x77b8
 80033a6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80033aa:	f7fd b941 	b.w	8000630 <test_println>
 80033ae:	bf00      	nop

080033b0 <test_013_005_execute.10719>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80033b0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80033b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80033b8:	699b      	ldr	r3, [r3, #24]
 *   repeated continuously in a one-second time window.
 * - [13.5.2] Score is printed.
 * .
 */

static void test_013_005_execute(void) {
 80033ba:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  systime_t start, end;

  /* [13.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80033be:	f241 3830 	movw	r8, #4912	; 0x1330
 * .
 */

static void test_013_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 80033c2:	689f      	ldr	r7, [r3, #8]
  systime_t start, end;

  /* [13.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80033c4:	f2c2 0800 	movt	r8, #8192	; 0x2000
 80033c8:	2301      	movs	r3, #1
 80033ca:	f8c8 3000 	str.w	r3, [r8]
  {
    n = 0;
    start = test_wait_tick();
 80033ce:	f001 fdcf 	bl	8004f70 <test_wait_tick>
 * .
 */

static void test_013_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 80033d2:	3f01      	subs	r7, #1
  /* [13.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 80033d4:	2400      	movs	r4, #0
    start = test_wait_tick();
 80033d6:	4606      	mov	r6, r0
 80033d8:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80033dc:	f640 1050 	movw	r0, #2384	; 0x950
 80033e0:	f646 62d1 	movw	r2, #28369	; 0x6ed1
 80033e4:	2300      	movs	r3, #0
 80033e6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80033ea:	4639      	mov	r1, r7
 80033ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80033f0:	f002 fa8e 	bl	8005910 <chThdCreateStatic.constprop.52>
 80033f4:	f002 fbe4 	bl	8005bc0 <chThdWait>
 80033f8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
 80033fa:	3401      	adds	r4, #1
 80033fc:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80033fe:	b29b      	uxth	r3, r3
 8003400:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8003404:	d3ea      	bcc.n	80033dc <test_013_005_execute.10719+0x2c>
  }

  /* [13.5.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
 8003406:	f247 601c 	movw	r0, #30236	; 0x761c
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.5.2] Score is printed.*/
  test_set_step(2);
 800340a:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800340c:	f6c0 0000 	movt	r0, #2048	; 0x800
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.5.2] Score is printed.*/
  test_set_step(2);
 8003410:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 8003414:	f7fd f92c 	bl	8000670 <test_print>
    test_printn(n);
 8003418:	4620      	mov	r0, r4
 800341a:	f7fd fa01 	bl	8000820 <test_printn>
    test_println(" threads/S");
  }
}
 800341e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [13.5.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 8003422:	f247 70b8 	movw	r0, #30648	; 0x77b8
 8003426:	f6c0 0000 	movt	r0, #2048	; 0x800
 800342a:	f7fd b901 	b.w	8000630 <test_println>
 800342e:	bf00      	nop

08003430 <test_013_004_execute.10721>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003430:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8003434:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003438:	699b      	ldr	r3, [r3, #24]
 * - [13.4.3] Stopping the target thread.
 * - [13.4.4] Score is printed.
 * .
 */

static void test_013_004_execute(void) {
 800343a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800343e:	6899      	ldr	r1, [r3, #8]
static void test_013_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8003440:	f241 3a30 	movw	sl, #4912	; 0x1330
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003444:	f640 1050 	movw	r0, #2384	; 0x950
 8003448:	f242 0281 	movw	r2, #8321	; 0x2081
 800344c:	3101      	adds	r1, #1
static void test_013_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800344e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8003452:	2401      	movs	r4, #1
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003454:	f6c0 0200 	movt	r2, #2048	; 0x800
 8003458:	2300      	movs	r3, #0
 800345a:	f2c2 0000 	movt	r0, #8192	; 0x2000
static void test_013_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800345e:	f8ca 4000 	str.w	r4, [sl]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003462:	f002 fa55 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003466:	f640 73d4 	movw	r3, #4052	; 0xfd4
                                        bmk_thread4, NULL);
  }

  /* [13.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 800346a:	2202      	movs	r2, #2
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800346c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003470:	4604      	mov	r4, r0
                                        bmk_thread4, NULL);
  }

  /* [13.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 8003472:	f8ca 2000 	str.w	r2, [sl]
  uint32_t n;

  /* [13.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8003476:	6018      	str	r0, [r3, #0]
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8003478:	f001 fd7a 	bl	8004f70 <test_wait_tick>
     time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 800347c:	2500      	movs	r5, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 800347e:	46a9      	mov	r9, r5
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8003480:	4680      	mov	r8, r0
 8003482:	2720      	movs	r7, #32
 8003484:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8003488:	f387 8811 	msr	BASEPRI, r7
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 800348c:	2100      	movs	r1, #0
 800348e:	4620      	mov	r0, r4
 8003490:	f7fd fc46 	bl	8000d20 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8003494:	4620      	mov	r0, r4
 8003496:	2100      	movs	r1, #0
 8003498:	f7fd fc42 	bl	8000d20 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800349c:	4620      	mov	r0, r4
 800349e:	2100      	movs	r1, #0
 80034a0:	f7fd fc3e 	bl	8000d20 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80034a4:	4620      	mov	r0, r4
 80034a6:	2100      	movs	r1, #0
 80034a8:	f7fd fc3a 	bl	8000d20 <chSchWakeupS>
 80034ac:	f389 8811 	msr	BASEPRI, r9
 80034b0:	6a73      	ldr	r3, [r6, #36]	; 0x24
      chSysUnlock();
      n += 4;
 80034b2:	3504      	adds	r5, #4
 80034b4:	ebc8 0303 	rsb	r3, r8, r3
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80034b8:	b29b      	uxth	r3, r3
 80034ba:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80034be:	d3e3      	bcc.n	8003488 <test_013_004_execute.10721+0x58>
  }

  /* [13.4.3] Stopping the target thread.*/
  test_set_step(3);
 80034c0:	2303      	movs	r3, #3
 80034c2:	f8ca 3000 	str.w	r3, [sl]
 80034c6:	2320      	movs	r3, #32
 80034c8:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    chSchWakeupS(tp, MSG_TIMEOUT);
 80034cc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80034d0:	4620      	mov	r0, r4
 80034d2:	f7fd fc25 	bl	8000d20 <chSchWakeupS>
 80034d6:	2300      	movs	r3, #0
 80034d8:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_wait_threads();
 80034dc:	f002 fb90 	bl	8005c00 <test_wait_threads>
  }

  /* [13.4.4] Score is printed.*/
  test_set_step(4);
 80034e0:	f241 3330 	movw	r3, #4912	; 0x1330
  {
    test_print("--- Score : ");
 80034e4:	f247 601c 	movw	r0, #30236	; 0x761c
    chSysUnlock();
    test_wait_threads();
  }

  /* [13.4.4] Score is printed.*/
  test_set_step(4);
 80034e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80034ec:	2204      	movs	r2, #4
  {
    test_print("--- Score : ");
 80034ee:	f6c0 0000 	movt	r0, #2048	; 0x800
    chSysUnlock();
    test_wait_threads();
  }

  /* [13.4.4] Score is printed.*/
  test_set_step(4);
 80034f2:	601a      	str	r2, [r3, #0]
  {
    test_print("--- Score : ");
 80034f4:	f7fd f8bc 	bl	8000670 <test_print>
    test_printn(n * 2);
 80034f8:	0068      	lsls	r0, r5, #1
 80034fa:	f7fd f991 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
  }
}
 80034fe:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* [13.4.4] Score is printed.*/
  test_set_step(4);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" ctxswc/S");
 8003502:	f247 70c4 	movw	r0, #30660	; 0x77c4
 8003506:	f6c0 0000 	movt	r0, #2048	; 0x800
 800350a:	f7fd b891 	b.w	8000630 <test_println>
 800350e:	bf00      	nop

08003510 <test_013_008_execute.10713>:
 * - [13.8.2] Waiting one second then terminating the 5 threads.
 * - [13.8.3] The score is printed.
 * .
 */

static void test_013_008_execute(void) {
 8003510:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t n;

  /* [13.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8003514:	f241 3930 	movw	r9, #4912	; 0x1330
 * - [13.8.2] Waiting one second then terminating the 5 threads.
 * - [13.8.3] The score is printed.
 * .
 */

static void test_013_008_execute(void) {
 8003518:	b083      	sub	sp, #12
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800351a:	f241 28c0 	movw	r8, #4800	; 0x12c0
  /* [13.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
 800351e:	ac02      	add	r4, sp, #8
 8003520:	f2c2 0800 	movt	r8, #8192	; 0x2000
  uint32_t n;

  /* [13.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8003524:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8003528:	2201      	movs	r2, #1
  {
    n = 0;
 800352a:	2300      	movs	r3, #0
 800352c:	f844 3d04 	str.w	r3, [r4, #-4]!
  uint32_t n;

  /* [13.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8003530:	f8c9 2000 	str.w	r2, [r9]
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003534:	f001 fd1c 	bl	8004f70 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003538:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800353c:	f640 1750 	movw	r7, #2384	; 0x950
 8003540:	6899      	ldr	r1, [r3, #8]
 8003542:	f240 5641 	movw	r6, #1345	; 0x541
 8003546:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800354a:	f6c0 0600 	movt	r6, #2048	; 0x800
 800354e:	4623      	mov	r3, r4
 8003550:	4632      	mov	r2, r6
 8003552:	3901      	subs	r1, #1
 8003554:	4638      	mov	r0, r7
 8003556:	f002 f9db 	bl	8005910 <chThdCreateStatic.constprop.52>
 800355a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800355e:	f640 75d4 	movw	r5, #4052	; 0xfd4

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003562:	6899      	ldr	r1, [r3, #8]
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003564:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003568:	6028      	str	r0, [r5, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800356a:	4632      	mov	r2, r6
 800356c:	4623      	mov	r3, r4
 800356e:	3901      	subs	r1, #1
 8003570:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 8003574:	f002 f9cc 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003578:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800357c:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800357e:	6899      	ldr	r1, [r3, #8]
 8003580:	4632      	mov	r2, r6
 8003582:	4623      	mov	r3, r4
 8003584:	f507 7024 	add.w	r0, r7, #656	; 0x290
 8003588:	3901      	subs	r1, #1
 800358a:	f002 f9c1 	bl	8005910 <chThdCreateStatic.constprop.52>
 800358e:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8003592:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003594:	6899      	ldr	r1, [r3, #8]
 8003596:	4632      	mov	r2, r6
 8003598:	4623      	mov	r3, r4
 800359a:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 800359e:	3901      	subs	r1, #1
 80035a0:	f002 f9b6 	bl	8005910 <chThdCreateStatic.constprop.52>
 80035a4:	f8d8 3018 	ldr.w	r3, [r8, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80035a8:	4632      	mov	r2, r6
 80035aa:	6899      	ldr	r1, [r3, #8]
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80035ac:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80035ae:	3901      	subs	r1, #1
 80035b0:	4623      	mov	r3, r4
 80035b2:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 80035b6:	f002 f9ab 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [13.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 80035ba:	2302      	movs	r3, #2
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80035bc:	6128      	str	r0, [r5, #16]
  }

  /* [13.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  {
    chThdSleepSeconds(1);
 80035be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [13.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 80035c2:	f8c9 3000 	str.w	r3, [r9]
  {
    chThdSleepSeconds(1);
 80035c6:	f001 fc53 	bl	8004e70 <chThdSleep>
    test_terminate_threads();
 80035ca:	f7fc ffd1 	bl	8000570 <test_terminate_threads>
    test_wait_threads();
 80035ce:	f002 fb17 	bl	8005c00 <test_wait_threads>
  }

  /* [13.8.3] The score is printed.*/
  test_set_step(3);
  {
    test_print("--- Score : ");
 80035d2:	f247 601c 	movw	r0, #30236	; 0x761c
    test_terminate_threads();
    test_wait_threads();
  }

  /* [13.8.3] The score is printed.*/
  test_set_step(3);
 80035d6:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 80035d8:	f6c0 0000 	movt	r0, #2048	; 0x800
    test_terminate_threads();
    test_wait_threads();
  }

  /* [13.8.3] The score is printed.*/
  test_set_step(3);
 80035dc:	f8c9 3000 	str.w	r3, [r9]
  {
    test_print("--- Score : ");
 80035e0:	f7fd f846 	bl	8000670 <test_print>
    test_printn(n);
 80035e4:	9801      	ldr	r0, [sp, #4]
 80035e6:	f7fd f91b 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
 80035ea:	f247 70c4 	movw	r0, #30660	; 0x77c4
 80035ee:	f6c0 0000 	movt	r0, #2048	; 0x800
 80035f2:	f7fd f81d 	bl	8000630 <test_println>
  }
}
 80035f6:	b003      	add	sp, #12
 80035f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80035fc:	f3af 8000 	nop.w

08003600 <test_013_007_execute.10715>:

static void test_013_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_013_007_execute(void) {
 8003600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003602:	f241 25c0 	movw	r5, #4800	; 0x12c0
 8003606:	f2c2 0500 	movt	r5, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800360a:	69ab      	ldr	r3, [r5, #24]
  uint32_t n;

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 800360c:	f241 3730 	movw	r7, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8003610:	6899      	ldr	r1, [r3, #8]
 8003612:	f640 1050 	movw	r0, #2384	; 0x950
 8003616:	f640 6291 	movw	r2, #3729	; 0xe91
 800361a:	3105      	adds	r1, #5
static void test_013_007_execute(void) {
  uint32_t n;

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 800361c:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8003620:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8003622:	f6c0 0200 	movt	r2, #2048	; 0x800
 8003626:	2300      	movs	r3, #0
 8003628:	f2c2 0000 	movt	r0, #8192	; 0x2000
static void test_013_007_execute(void) {
  uint32_t n;

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 800362c:	603c      	str	r4, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800362e:	f002 f96f 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003632:	69ab      	ldr	r3, [r5, #24]
 8003634:	f640 74d4 	movw	r4, #4052	; 0xfd4
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8003638:	6899      	ldr	r1, [r3, #8]

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 800363a:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 800363e:	f640 6291 	movw	r2, #3729	; 0xe91

  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8003642:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8003644:	3104      	adds	r1, #4
 8003646:	f6c0 0200 	movt	r2, #2048	; 0x800
 800364a:	2300      	movs	r3, #0
 800364c:	4834      	ldr	r0, [pc, #208]	; (8003720 <test_013_007_execute.10715+0x120>)
 800364e:	f002 f95f 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003652:	69ab      	ldr	r3, [r5, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8003654:	f640 6291 	movw	r2, #3729	; 0xe91
 8003658:	6899      	ldr	r1, [r3, #8]
 800365a:	f6c0 0200 	movt	r2, #2048	; 0x800
  /* [13.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 800365e:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8003660:	3103      	adds	r1, #3
 8003662:	2300      	movs	r3, #0
 8003664:	482f      	ldr	r0, [pc, #188]	; (8003724 <test_013_007_execute.10715+0x124>)
 8003666:	f002 f953 	bl	8005910 <chThdCreateStatic.constprop.52>
 800366a:	69ab      	ldr	r3, [r5, #24]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800366c:	f640 6291 	movw	r2, #3729	; 0xe91
 8003670:	6899      	ldr	r1, [r3, #8]
 8003672:	f6c0 0200 	movt	r2, #2048	; 0x800
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8003676:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8003678:	3102      	adds	r1, #2
 800367a:	2300      	movs	r3, #0
 800367c:	482a      	ldr	r0, [pc, #168]	; (8003728 <test_013_007_execute.10715+0x128>)
 800367e:	f002 f947 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003682:	69ab      	ldr	r3, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8003684:	f640 6291 	movw	r2, #3729	; 0xe91
 8003688:	6899      	ldr	r1, [r3, #8]
 800368a:	f6c0 0200 	movt	r2, #2048	; 0x800
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800368e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8003690:	3101      	adds	r1, #1
 8003692:	2300      	movs	r3, #0
 8003694:	4825      	ldr	r0, [pc, #148]	; (800372c <test_013_007_execute.10715+0x12c>)
 8003696:	f002 f93b 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [13.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 800369a:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800369c:	6120      	str	r0, [r4, #16]
  }

  /* [13.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 800369e:	603b      	str	r3, [r7, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80036a0:	f001 fc66 	bl	8004f70 <test_wait_tick>
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80036a4:	2400      	movs	r4, #0
    start = test_wait_tick();
 80036a6:	4606      	mov	r6, r0
 80036a8:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
 80036ac:	f640 1010 	movw	r0, #2320	; 0x910
 80036b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80036b4:	2100      	movs	r1, #0
 80036b6:	f7fd fe53 	bl	8001360 <chSemReset>
 80036ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
 80036bc:	3401      	adds	r4, #1
 80036be:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80036c0:	b29b      	uxth	r3, r3
 80036c2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80036c6:	d3f1      	bcc.n	80036ac <test_013_007_execute.10715+0xac>
  }

  /* [13.7.3] The five threads are terminated.*/
  test_set_step(3);
 80036c8:	2303      	movs	r3, #3
 80036ca:	603b      	str	r3, [r7, #0]
  {
    test_terminate_threads();
 80036cc:	f7fc ff50 	bl	8000570 <test_terminate_threads>
    chSemReset(&sem1, 0);
 80036d0:	f640 1010 	movw	r0, #2320	; 0x910
 80036d4:	2100      	movs	r1, #0
 80036d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80036da:	f7fd fe41 	bl	8001360 <chSemReset>
    test_wait_threads();
 80036de:	f002 fa8f 	bl	8005c00 <test_wait_threads>
  }

  /* [13.7.4] The score is printed.*/
  test_set_step(4);
  {
    test_print("--- Score : ");
 80036e2:	f247 601c 	movw	r0, #30236	; 0x761c
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [13.7.4] The score is printed.*/
  test_set_step(4);
 80036e6:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 80036e8:	f6c0 0000 	movt	r0, #2048	; 0x800
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [13.7.4] The score is printed.*/
  test_set_step(4);
 80036ec:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 80036ee:	f7fc ffbf 	bl	8000670 <test_print>
    test_printn(n);
 80036f2:	4620      	mov	r0, r4
 80036f4:	f7fd f894 	bl	8000820 <test_printn>
    test_print(" reschedules/S, ");
 80036f8:	f247 70d0 	movw	r0, #30672	; 0x77d0
 80036fc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003700:	f7fc ffb6 	bl	8000670 <test_print>
    test_printn(n * 6);
 8003704:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 8003708:	0040      	lsls	r0, r0, #1
 800370a:	f7fd f889 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
  }
}
 800370e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" reschedules/S, ");
    test_printn(n * 6);
    test_println(" ctxswc/S");
 8003712:	f247 70c4 	movw	r0, #30660	; 0x77c4
 8003716:	f6c0 0000 	movt	r0, #2048	; 0x800
 800371a:	f7fc bf89 	b.w	8000630 <test_println>
 800371e:	bf00      	nop
 8003720:	20000a98 	.word	0x20000a98
 8003724:	20000be0 	.word	0x20000be0
 8003728:	20000d28 	.word	0x20000d28
 800372c:	20000e70 	.word	0x20000e70

08003730 <test_013_003_execute.10726>:
 *   second time window.
 * - [13.3.4] Score is printed.
 * .
 */

static void test_013_003_execute(void) {
 8003730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003734:	f241 26c0 	movw	r6, #4800	; 0x12c0
 8003738:	f2c2 0600 	movt	r6, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800373c:	69b3      	ldr	r3, [r6, #24]

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800373e:	f640 1550 	movw	r5, #2384	; 0x950
 8003742:	6899      	ldr	r1, [r3, #8]
 8003744:	f2c2 0500 	movt	r5, #8192	; 0x2000
static void test_013_003_execute(void) {
  uint32_t n;

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8003748:	f241 3730 	movw	r7, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800374c:	f243 1291 	movw	r2, #12689	; 0x3191
static void test_013_003_execute(void) {
  uint32_t n;

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8003750:	f2c2 0700 	movt	r7, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003754:	3101      	adds	r1, #1
 8003756:	4628      	mov	r0, r5
static void test_013_003_execute(void) {
  uint32_t n;

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8003758:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800375a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800375e:	2300      	movs	r3, #0
static void test_013_003_execute(void) {
  uint32_t n;

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8003760:	603c      	str	r4, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003762:	f002 f8d5 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003766:	69b3      	ldr	r3, [r6, #24]
 8003768:	f640 74d4 	movw	r4, #4052	; 0xfd4

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800376c:	6899      	ldr	r1, [r3, #8]
 800376e:	f646 68d1 	movw	r8, #28369	; 0x6ed1

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003772:	f2c2 0400 	movt	r4, #8192	; 0x2000

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8003776:	f6c0 0800 	movt	r8, #2048	; 0x800
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800377a:	f04f 0e02 	mov.w	lr, #2

  /* [13.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800377e:	6020      	str	r0, [r4, #0]

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8003780:	4642      	mov	r2, r8
 8003782:	3902      	subs	r1, #2
 8003784:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 8003788:	2300      	movs	r3, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [13.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800378a:	f8c7 e000 	str.w	lr, [r7]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800378e:	f002 f8bf 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003792:	69b3      	ldr	r3, [r6, #24]
 8003794:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8003796:	6899      	ldr	r1, [r3, #8]
 8003798:	4642      	mov	r2, r8
 800379a:	f505 7024 	add.w	r0, r5, #656	; 0x290
 800379e:	3903      	subs	r1, #3
 80037a0:	2300      	movs	r3, #0
 80037a2:	f002 f8b5 	bl	8005910 <chThdCreateStatic.constprop.52>
 80037a6:	69b3      	ldr	r3, [r6, #24]
 80037a8:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 80037aa:	6899      	ldr	r1, [r3, #8]
 80037ac:	4642      	mov	r2, r8
 80037ae:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 80037b2:	3904      	subs	r1, #4
 80037b4:	2300      	movs	r3, #0
 80037b6:	f002 f8ab 	bl	8005910 <chThdCreateStatic.constprop.52>
 80037ba:	69b3      	ldr	r3, [r6, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80037bc:	4642      	mov	r2, r8
 80037be:	6899      	ldr	r1, [r3, #8]
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 80037c0:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80037c2:	3905      	subs	r1, #5
 80037c4:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 80037c8:	2300      	movs	r3, #0
 80037ca:	f002 f8a1 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [13.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 80037ce:	2303      	movs	r3, #3
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80037d0:	6120      	str	r0, [r4, #16]

  /* [13.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  {
    n = msg_loop_test(threads[0]);
 80037d2:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  }

  /* [13.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 80037d4:	603b      	str	r3, [r7, #0]
  {
    n = msg_loop_test(threads[0]);
 80037d6:	f001 fc8b 	bl	80050f0 <msg_loop_test.10723>
 80037da:	4604      	mov	r4, r0
    test_wait_threads();
 80037dc:	f002 fa10 	bl	8005c00 <test_wait_threads>
  }

  /* [13.3.4] Score is printed.*/
  test_set_step(4);
  {
    test_print("--- Score : ");
 80037e0:	f247 601c 	movw	r0, #30236	; 0x761c
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.3.4] Score is printed.*/
  test_set_step(4);
 80037e4:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 80037e6:	f6c0 0000 	movt	r0, #2048	; 0x800
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.3.4] Score is printed.*/
  test_set_step(4);
 80037ea:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 80037ec:	f7fc ff40 	bl	8000670 <test_print>
    test_printn(n);
 80037f0:	4620      	mov	r0, r4
 80037f2:	f7fd f815 	bl	8000820 <test_printn>
    test_print(" msgs/S, ");
 80037f6:	f247 70e4 	movw	r0, #30692	; 0x77e4
 80037fa:	f6c0 0000 	movt	r0, #2048	; 0x800
 80037fe:	f7fc ff37 	bl	8000670 <test_print>
    test_printn(n << 1);
 8003802:	0060      	lsls	r0, r4, #1
 8003804:	f7fd f80c 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
  }
}
 8003808:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 800380c:	f247 70c4 	movw	r0, #30660	; 0x77c4
 8003810:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003814:	f7fc bf0c 	b.w	8000630 <test_println>
 8003818:	f3af 8000 	nop.w
 800381c:	f3af 8000 	nop.w

08003820 <test_013_002_execute.10728>:
 *   second time window.
 * - [13.2.3] Score is printed.
 * .
 */

static void test_013_002_execute(void) {
 8003820:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003822:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8003826:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800382a:	699b      	ldr	r3, [r3, #24]
  uint32_t n;

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800382c:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003830:	6899      	ldr	r1, [r3, #8]
 8003832:	f640 1050 	movw	r0, #2384	; 0x950
 8003836:	f243 1291 	movw	r2, #12689	; 0x3191
 800383a:	3101      	adds	r1, #1
static void test_013_002_execute(void) {
  uint32_t n;

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800383c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003840:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003842:	f6c0 0200 	movt	r2, #2048	; 0x800
 8003846:	2300      	movs	r3, #0
 8003848:	f2c2 0000 	movt	r0, #8192	; 0x2000
static void test_013_002_execute(void) {
  uint32_t n;

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800384c:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800384e:	f002 f85f 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003852:	f640 73d4 	movw	r3, #4052	; 0xfd4
  }

  /* [13.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 8003856:	2202      	movs	r2, #2

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8003858:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [13.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800385c:	6022      	str	r2, [r4, #0]

  /* [13.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800385e:	6018      	str	r0, [r3, #0]

  /* [13.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
  {
    n = msg_loop_test(threads[0]);
 8003860:	f001 fc46 	bl	80050f0 <msg_loop_test.10723>
 8003864:	4605      	mov	r5, r0
    test_wait_threads();
 8003866:	f002 f9cb 	bl	8005c00 <test_wait_threads>
  }

  /* [13.2.3] Score is printed.*/
  test_set_step(3);
  {
    test_print("--- Score : ");
 800386a:	f247 601c 	movw	r0, #30236	; 0x761c
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.2.3] Score is printed.*/
  test_set_step(3);
 800386e:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 8003870:	f6c0 0000 	movt	r0, #2048	; 0x800
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.2.3] Score is printed.*/
  test_set_step(3);
 8003874:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8003876:	f7fc fefb 	bl	8000670 <test_print>
    test_printn(n);
 800387a:	4628      	mov	r0, r5
 800387c:	f7fc ffd0 	bl	8000820 <test_printn>
    test_print(" msgs/S, ");
 8003880:	f247 70e4 	movw	r0, #30692	; 0x77e4
 8003884:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003888:	f7fc fef2 	bl	8000670 <test_print>
    test_printn(n << 1);
 800388c:	0068      	lsls	r0, r5, #1
 800388e:	f7fc ffc7 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
  }
}
 8003892:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 8003896:	f247 70c4 	movw	r0, #30660	; 0x77c4
 800389a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800389e:	f7fc bec7 	b.w	8000630 <test_println>
 80038a2:	bf00      	nop
 80038a4:	f3af 8000 	nop.w
 80038a8:	f3af 8000 	nop.w
 80038ac:	f3af 8000 	nop.w

080038b0 <test_013_001_execute.10730>:
 *   second time window.
 * - [13.1.3] Score is printed.
 * .
 */

static void test_013_001_execute(void) {
 80038b0:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80038b2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80038b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80038ba:	699b      	ldr	r3, [r3, #24]
  uint32_t n;

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80038bc:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038c0:	6899      	ldr	r1, [r3, #8]
 80038c2:	f640 1050 	movw	r0, #2384	; 0x950
 80038c6:	f243 1291 	movw	r2, #12689	; 0x3191
 80038ca:	3901      	subs	r1, #1
static void test_013_001_execute(void) {
  uint32_t n;

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80038cc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80038d0:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038d2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80038d6:	2300      	movs	r3, #0
 80038d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
static void test_013_001_execute(void) {
  uint32_t n;

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80038dc:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038de:	f002 f817 	bl	8005910 <chThdCreateStatic.constprop.52>
 80038e2:	f640 73d4 	movw	r3, #4052	; 0xfd4
  }

  /* [13.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80038e6:	2202      	movs	r2, #2

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [13.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80038ec:	6022      	str	r2, [r4, #0]

  /* [13.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80038ee:	6018      	str	r0, [r3, #0]

  /* [13.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
  {
    n = msg_loop_test(threads[0]);
 80038f0:	f001 fbfe 	bl	80050f0 <msg_loop_test.10723>
 80038f4:	4605      	mov	r5, r0
    test_wait_threads();
 80038f6:	f002 f983 	bl	8005c00 <test_wait_threads>
  }

  /* [13.1.3] Score is printed.*/
  test_set_step(3);
  {
    test_print("--- Score : ");
 80038fa:	f247 601c 	movw	r0, #30236	; 0x761c
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.1.3] Score is printed.*/
  test_set_step(3);
 80038fe:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 8003900:	f6c0 0000 	movt	r0, #2048	; 0x800
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [13.1.3] Score is printed.*/
  test_set_step(3);
 8003904:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8003906:	f7fc feb3 	bl	8000670 <test_print>
    test_printn(n);
 800390a:	4628      	mov	r0, r5
 800390c:	f7fc ff88 	bl	8000820 <test_printn>
    test_print(" msgs/S, ");
 8003910:	f247 70e4 	movw	r0, #30692	; 0x77e4
 8003914:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003918:	f7fc feaa 	bl	8000670 <test_print>
    test_printn(n << 1);
 800391c:	0068      	lsls	r0, r5, #1
 800391e:	f7fc ff7f 	bl	8000820 <test_printn>
    test_println(" ctxswc/S");
  }
}
 8003922:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 8003926:	f247 70c4 	movw	r0, #30660	; 0x77c4
 800392a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800392e:	f7fc be7f 	b.w	8000630 <test_println>
 8003932:	bf00      	nop
 8003934:	f3af 8000 	nop.w
 8003938:	f3af 8000 	nop.w
 800393c:	f3af 8000 	nop.w

08003940 <test_012_002_execute.10519>:

static void test_012_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void test_012_002_execute(void) {
 8003940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  tprio_t prio;

  /* [12.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8003942:	f241 3530 	movw	r5, #4912	; 0x1330
 8003946:	4b5f      	ldr	r3, [pc, #380]	; (8003ac4 <test_012_002_execute.10519+0x184>)
 8003948:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800394c:	2201      	movs	r2, #1
 800394e:	f640 1140 	movw	r1, #2368	; 0x940
 8003952:	602a      	str	r2, [r5, #0]
 8003954:	f103 0710 	add.w	r7, r3, #16
 8003958:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800395c:	2620      	movs	r6, #32
 800395e:	2400      	movs	r4, #0
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 8003960:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8003964:	f386 8811 	msr	BASEPRI, r6
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8003968:	6808      	ldr	r0, [r1, #0]
 800396a:	6010      	str	r0, [r2, #0]
  mp->next = php;
 800396c:	600a      	str	r2, [r1, #0]
 800396e:	f384 8811 	msr	BASEPRI, r4
  tprio_t prio;

  /* [12.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 8003972:	42bb      	cmp	r3, r7
 8003974:	d1f4      	bne.n	8003960 <test_012_002_execute.10519+0x20>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003976:	f241 23c0 	movw	r3, #4800	; 0x12c0
 800397a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800397e:	699b      	ldr	r3, [r3, #24]
  }

  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8003980:	f247 70f0 	movw	r0, #30704	; 0x77f0
 8003984:	689e      	ldr	r6, [r3, #8]
 8003986:	f247 6240 	movw	r2, #30272	; 0x7640
  {
    prio = chThdGetPriorityX();
  }

  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
 800398a:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800398c:	1e71      	subs	r1, r6, #1
 800398e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8003992:	f6c0 0000 	movt	r0, #2048	; 0x800
  {
    prio = chThdGetPriorityX();
  }

  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
 8003996:	602b      	str	r3, [r5, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8003998:	f7ff fa72 	bl	8002e80 <chThdCreateFromMemoryPool.constprop.23>
 800399c:	f640 74d4 	movw	r4, #4052	; 0xfd4
 80039a0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80039a4:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80039a6:	f247 6244 	movw	r2, #30276	; 0x7644
 80039aa:	f247 70f8 	movw	r0, #30712	; 0x77f8
 80039ae:	1eb1      	subs	r1, r6, #2
 80039b0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80039b4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80039b8:	f7ff fa62 	bl	8002e80 <chThdCreateFromMemoryPool.constprop.23>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 80039bc:	f647 0208 	movw	r2, #30728	; 0x7808

  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80039c0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 80039c2:	f647 0000 	movw	r0, #30720	; 0x7800
 80039c6:	1ef1      	subs	r1, r6, #3
 80039c8:	f6c0 0200 	movt	r2, #2048	; 0x800
 80039cc:	f6c0 0000 	movt	r0, #2048	; 0x800
 80039d0:	f7ff fa56 	bl	8002e80 <chThdCreateFromMemoryPool.constprop.23>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 80039d4:	f647 0214 	movw	r2, #30740	; 0x7814
  /* [12.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 80039d8:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 80039da:	f647 000c 	movw	r0, #30732	; 0x780c
 80039de:	1f31      	subs	r1, r6, #4
 80039e0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80039e4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80039e8:	f7ff fa4a 	bl	8002e80 <chThdCreateFromMemoryPool.constprop.23>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 80039ec:	f647 12a4 	movw	r2, #31140	; 0x79a4
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 80039f0:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 80039f2:	f647 0018 	movw	r0, #30744	; 0x7818
 80039f6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80039fa:	1f71      	subs	r1, r6, #5
 80039fc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003a00:	f7ff fa3e 	bl	8002e80 <chThdCreateFromMemoryPool.constprop.23>
  }

  /* [12.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 8003a04:	6823      	ldr	r3, [r4, #0]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
  }

  /* [12.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8003a06:	2204      	movs	r2, #4
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8003a08:	6120      	str	r0, [r4, #16]
  }

  /* [12.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8003a0a:	602a      	str	r2, [r5, #0]
  {
    test_assert((threads[0] != NULL) &&
 8003a0c:	4618      	mov	r0, r3
 8003a0e:	b13b      	cbz	r3, 8003a20 <test_012_002_execute.10519+0xe0>
 8003a10:	6860      	ldr	r0, [r4, #4]
 8003a12:	b128      	cbz	r0, 8003a20 <test_012_002_execute.10519+0xe0>
 8003a14:	68a0      	ldr	r0, [r4, #8]
 8003a16:	b118      	cbz	r0, 8003a20 <test_012_002_execute.10519+0xe0>
 8003a18:	68e0      	ldr	r0, [r4, #12]
 8003a1a:	3000      	adds	r0, #0
 8003a1c:	bf18      	it	ne
 8003a1e:	2001      	movne	r0, #1
 8003a20:	f647 0120 	movw	r1, #30752	; 0x7820
 8003a24:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003a28:	f7fc fe6a 	bl	8000700 <_test_assert>
 8003a2c:	b100      	cbz	r0, 8003a30 <test_012_002_execute.10519+0xf0>
 8003a2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8003a30:	6920      	ldr	r0, [r4, #16]
 8003a32:	f647 0138 	movw	r1, #30776	; 0x7838
 8003a36:	f1d0 0001 	rsbs	r0, r0, #1
 8003a3a:	bf38      	it	cc
 8003a3c:	2000      	movcc	r0, #0
 8003a3e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003a42:	f7fc fe5d 	bl	8000700 <_test_assert>
 8003a46:	2800      	cmp	r0, #0
 8003a48:	d1f1      	bne.n	8003a2e <test_012_002_execute.10519+0xee>
                "thread creation not failed");
  }

  /* [12.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8003a4a:	2305      	movs	r3, #5
 8003a4c:	602b      	str	r3, [r5, #0]
  {
    test_wait_threads();
 8003a4e:	f002 f8d7 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8003a52:	f647 0054 	movw	r0, #30804	; 0x7854
 8003a56:	f247 61ac 	movw	r1, #30380	; 0x76ac
                "thread creation not failed");
  }

  /* [12.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8003a5a:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8003a5e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003a62:	f6c0 0100 	movt	r1, #2048	; 0x800
                "thread creation not failed");
  }

  /* [12.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8003a66:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8003a6a:	f7fc fe19 	bl	80006a0 <_test_assert_sequence>
 8003a6e:	2800      	cmp	r0, #0
 8003a70:	d1dd      	bne.n	8003a2e <test_012_002_execute.10519+0xee>
  }

  /* [12.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 8003a72:	2306      	movs	r3, #6
 8003a74:	6023      	str	r3, [r4, #0]
 8003a76:	2404      	movs	r4, #4
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8003a78:	f640 1040 	movw	r0, #2368	; 0x940
 8003a7c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003a80:	f7fd f826 	bl	8000ad0 <chPoolAlloc>
 8003a84:	f647 015c 	movw	r1, #30812	; 0x785c
 8003a88:	3000      	adds	r0, #0
 8003a8a:	bf18      	it	ne
 8003a8c:	2001      	movne	r0, #1
 8003a8e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003a92:	f7fc fe35 	bl	8000700 <_test_assert>
 8003a96:	2800      	cmp	r0, #0
 8003a98:	d1c9      	bne.n	8003a2e <test_012_002_execute.10519+0xee>
  }

  /* [12.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 8003a9a:	3c01      	subs	r4, #1
 8003a9c:	d1ec      	bne.n	8003a78 <test_012_002_execute.10519+0x138>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8003a9e:	f640 1040 	movw	r0, #2368	; 0x940
 8003aa2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003aa6:	f7fd f813 	bl	8000ad0 <chPoolAlloc>
  }
}
 8003aaa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [12.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8003aae:	f647 016c 	movw	r1, #30828	; 0x786c
 8003ab2:	f1d0 0001 	rsbs	r0, r0, #1
 8003ab6:	bf38      	it	cc
 8003ab8:	2000      	movcc	r0, #0
 8003aba:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003abe:	f7fc be1f 	b.w	8000700 <_test_assert>
 8003ac2:	bf00      	nop
 8003ac4:	08007924 	.word	0x08007924
 8003ac8:	f3af 8000 	nop.w
 8003acc:	f3af 8000 	nop.w

08003ad0 <test_012_001_execute.10523>:

static void test_012_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_012_001_execute(void) {
 8003ad0:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003ad2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8003ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ada:	b085      	sub	sp, #20
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003adc:	699d      	ldr	r5, [r3, #24]
  {
    prio = chThdGetPriorityX();
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8003ade:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003ae2:	f640 1020 	movw	r0, #2336	; 0x920
  {
    prio = chThdGetPriorityX();
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8003ae6:	2302      	movs	r3, #2
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003ae8:	4669      	mov	r1, sp
  {
    prio = chThdGetPriorityX();
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8003aea:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003aee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003af2:	aa01      	add	r2, sp, #4
 8003af4:	68ae      	ldr	r6, [r5, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8003af6:	6023      	str	r3, [r4, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003af8:	f7fd fb8a 	bl	8001210 <chHeapStatus>
    test_assert(n1 == 1, "heap fragmented");
 8003afc:	1e47      	subs	r7, r0, #1
  }

  /* [12.1.2] Getting heap info before the test.*/
  test_set_step(2);
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8003afe:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 8003b00:	f247 61c0 	movw	r1, #30400	; 0x76c0
 8003b04:	4278      	negs	r0, r7
 8003b06:	4178      	adcs	r0, r7
 8003b08:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003b0c:	f7fc fdf8 	bl	8000700 <_test_assert>
 8003b10:	b108      	cbz	r0, 8003b16 <test_012_001_execute.10523+0x46>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 8003b12:	b005      	add	sp, #20
 8003b14:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8003b16:	f247 71f0 	movw	r1, #30704	; 0x77f0
 8003b1a:	f247 6340 	movw	r3, #30272	; 0x7640
 8003b1e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003b22:	f6c0 0300 	movt	r3, #2048	; 0x800
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8003b26:	2703      	movs	r7, #3
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8003b28:	f44f 70a4 	mov.w	r0, #328	; 0x148
 8003b2c:	1e72      	subs	r2, r6, #1
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8003b2e:	6027      	str	r7, [r4, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8003b30:	f7ff f976 	bl	8002e20 <chThdCreateFromHeap.constprop.24>
 8003b34:	f640 77d4 	movw	r7, #4052	; 0xfd4
 8003b38:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8003b3a:	f647 0120 	movw	r1, #30752	; 0x7820
 8003b3e:	3000      	adds	r0, #0
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8003b40:	f2c2 0700 	movt	r7, #8192	; 0x2000
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8003b44:	bf18      	it	ne
 8003b46:	2001      	movne	r0, #1
 8003b48:	f6c0 0100 	movt	r1, #2048	; 0x800
  }

  /* [12.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8003b4c:	603b      	str	r3, [r7, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8003b4e:	f7fc fdd7 	bl	8000700 <_test_assert>
 8003b52:	2800      	cmp	r0, #0
 8003b54:	d1dd      	bne.n	8003b12 <test_012_001_execute.10523+0x42>
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8003b56:	f247 71f8 	movw	r1, #30712	; 0x77f8
 8003b5a:	f247 6344 	movw	r3, #30276	; 0x7644
 8003b5e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003b62:	f6c0 0300 	movt	r3, #2048	; 0x800
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 8003b66:	f04f 0e04 	mov.w	lr, #4
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8003b6a:	f44f 70a4 	mov.w	r0, #328	; 0x148
 8003b6e:	1eb2      	subs	r2, r6, #2
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 8003b70:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8003b74:	f7ff f954 	bl	8002e20 <chThdCreateFromHeap.constprop.24>
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 8003b78:	f647 0120 	movw	r1, #30752	; 0x7820
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8003b7c:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 8003b7e:	3000      	adds	r0, #0
 8003b80:	bf18      	it	ne
 8003b82:	2001      	movne	r0, #1
 8003b84:	f6c0 0100 	movt	r1, #2048	; 0x800
  }

  /* [12.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8003b88:	607b      	str	r3, [r7, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 8003b8a:	f7fc fdb9 	bl	8000700 <_test_assert>
 8003b8e:	2800      	cmp	r0, #0
 8003b90:	d1bf      	bne.n	8003b12 <test_012_001_execute.10523+0x42>
  }

  /* [12.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 8003b92:	20c8      	movs	r0, #200	; 0xc8
 8003b94:	f647 0100 	movw	r1, #30720	; 0x7800
 8003b98:	f647 0308 	movw	r3, #30728	; 0x7808
 8003b9c:	1ef2      	subs	r2, r6, #3
 8003b9e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003ba2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003ba6:	f2c0 0002 	movt	r0, #2
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  }

  /* [12.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 8003baa:	2605      	movs	r6, #5
 8003bac:	6026      	str	r6, [r4, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 8003bae:	f7ff f937 	bl	8002e20 <chThdCreateFromHeap.constprop.24>
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 8003bb2:	f647 0138 	movw	r1, #30776	; 0x7838
  }

  /* [12.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 8003bb6:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 8003bb8:	f1d0 0001 	rsbs	r0, r0, #1
 8003bbc:	bf38      	it	cc
 8003bbe:	2000      	movcc	r0, #0
 8003bc0:	f6c0 0100 	movt	r1, #2048	; 0x800
  }

  /* [12.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 8003bc4:	60bb      	str	r3, [r7, #8]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 8003bc6:	f7fc fd9b 	bl	8000700 <_test_assert>
 8003bca:	2800      	cmp	r0, #0
 8003bcc:	d1a1      	bne.n	8003b12 <test_012_001_execute.10523+0x42>
  }

  /* [12.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 8003bce:	2306      	movs	r3, #6
 8003bd0:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8003bd2:	f002 f815 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8003bd6:	f647 0080 	movw	r0, #30848	; 0x7880
 8003bda:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8003bde:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003be2:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003be6:	f7fc fd5b 	bl	80006a0 <_test_assert_sequence>
 8003bea:	2800      	cmp	r0, #0
 8003bec:	d191      	bne.n	8003b12 <test_012_001_execute.10523+0x42>
  }

  /* [12.1.7] Getting heap info again for verification.*/
  test_set_step(7);
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8003bee:	f640 1020 	movw	r0, #2336	; 0x920
    test_wait_threads();
    test_assert_sequence("AB", "invalid sequence");
  }

  /* [12.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 8003bf2:	2307      	movs	r3, #7
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8003bf4:	a902      	add	r1, sp, #8
 8003bf6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003bfa:	aa03      	add	r2, sp, #12
    test_wait_threads();
    test_assert_sequence("AB", "invalid sequence");
  }

  /* [12.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 8003bfc:	6023      	str	r3, [r4, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8003bfe:	f7fd fb07 	bl	8001210 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8003c02:	1a2d      	subs	r5, r5, r0
 8003c04:	4268      	negs	r0, r5
 8003c06:	f647 0184 	movw	r1, #30852	; 0x7884
 8003c0a:	4168      	adcs	r0, r5
 8003c0c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003c10:	f7fc fd76 	bl	8000700 <_test_assert>
 8003c14:	2800      	cmp	r0, #0
 8003c16:	f47f af7c 	bne.w	8003b12 <test_012_001_execute.10523+0x42>
    test_assert(total1 == total2, "total free space changed");
 8003c1a:	9800      	ldr	r0, [sp, #0]
 8003c1c:	9b02      	ldr	r3, [sp, #8]
 8003c1e:	f647 019c 	movw	r1, #30876	; 0x789c
 8003c22:	1ac4      	subs	r4, r0, r3
 8003c24:	4260      	negs	r0, r4
 8003c26:	4160      	adcs	r0, r4
 8003c28:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003c2c:	f7fc fd68 	bl	8000700 <_test_assert>
 8003c30:	2800      	cmp	r0, #0
 8003c32:	f47f af6e 	bne.w	8003b12 <test_012_001_execute.10523+0x42>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8003c36:	9801      	ldr	r0, [sp, #4]
 8003c38:	9b03      	ldr	r3, [sp, #12]
 8003c3a:	f647 01b8 	movw	r1, #30904	; 0x78b8
 8003c3e:	1ac2      	subs	r2, r0, r3
 8003c40:	4250      	negs	r0, r2
 8003c42:	4150      	adcs	r0, r2
 8003c44:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003c48:	f7fc fd5a 	bl	8000700 <_test_assert>
 8003c4c:	e761      	b.n	8003b12 <test_012_001_execute.10523+0x42>
 8003c4e:	bf00      	nop

08003c50 <test_008_005_execute.9880>:

static void test_008_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_008_005_execute(void) {
 8003c50:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8003c52:	f241 3430 	movw	r4, #4912	; 0x1330
 8003c56:	2301      	movs	r3, #1
 8003c58:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    chEvtAddEvents(5);
 8003c5c:	2005      	movs	r0, #5
static void test_008_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8003c5e:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8003c60:	f7fc ff4e 	bl	8000b00 <chEvtAddEvents>
  }

  /* [8.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8003c64:	2302      	movs	r3, #2
 8003c66:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8003c68:	f7ff f8ba 	bl	8002de0 <chEvtWaitAll.constprop.29>
    test_assert(m == 5, "unexpected pending bit");
 8003c6c:	f1b0 0c05 	subs.w	ip, r0, #5
 8003c70:	f1dc 0000 	rsbs	r0, ip, #0
 8003c74:	f647 01d8 	movw	r1, #30936	; 0x78d8
 8003c78:	eb50 000c 	adcs.w	r0, r0, ip
 8003c7c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003c80:	f7fc fd3e 	bl	8000700 <_test_assert>
 8003c84:	b100      	cbz	r0, 8003c88 <test_008_005_execute.9880+0x38>
 8003c86:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003c88:	f7ff f82a 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8003c8c:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8003c90:	f1d0 0001 	rsbs	r0, r0, #1
 8003c94:	bf38      	it	cc
 8003c96:	2000      	movcc	r0, #0
 8003c98:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003c9c:	f7fc fd30 	bl	8000700 <_test_assert>
 8003ca0:	2800      	cmp	r0, #0
 8003ca2:	d1f0      	bne.n	8003c86 <test_008_005_execute.9880+0x36>
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 8003ca4:	2303      	movs	r3, #3
  {
    chEvtAddEvents(4);
 8003ca6:	2004      	movs	r0, #4
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 8003ca8:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(4);
 8003caa:	f7fc ff29 	bl	8000b00 <chEvtAddEvents>
  }

  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 8003cae:	2304      	movs	r3, #4
 8003cb0:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8003cb2:	f001 f95d 	bl	8004f70 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003cb6:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8003cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003cbe:	699b      	ldr	r3, [r3, #24]
 8003cc0:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003cc2:	6899      	ldr	r1, [r3, #8]
 8003cc4:	f640 1050 	movw	r0, #2384	; 0x950
 8003cc8:	f641 42f1 	movw	r2, #7409	; 0x1cf1
 8003ccc:	3901      	subs	r1, #1
 8003cce:	f6c0 0200 	movt	r2, #2048	; 0x800
 8003cd2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003cd6:	f001 fe1b 	bl	8005910 <chThdCreateStatic.constprop.52>
 8003cda:	f640 73d4 	movw	r3, #4052	; 0xfd4
 8003cde:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 8003ce2:	2205      	movs	r2, #5
 8003ce4:	6022      	str	r2, [r4, #0]
  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003ce6:	6018      	str	r0, [r3, #0]
  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 8003ce8:	f7ff f87a 	bl	8002de0 <chEvtWaitAll.constprop.29>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003cec:	f105 0134 	add.w	r1, r5, #52	; 0x34
  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 8003cf0:	4604      	mov	r4, r0

  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8003cf2:	f105 0032 	add.w	r0, r5, #50	; 0x32
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8003cf6:	b280      	uxth	r0, r0
 8003cf8:	b289      	uxth	r1, r1
 8003cfa:	f7ff f8f1 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8003cfe:	2800      	cmp	r0, #0
 8003d00:	d1c1      	bne.n	8003c86 <test_008_005_execute.9880+0x36>
                            "out of time window");
    test_assert(m == 5, "event flags error");
 8003d02:	f1b4 0e05 	subs.w	lr, r4, #5
 8003d06:	f1de 0000 	rsbs	r0, lr, #0
 8003d0a:	f647 01fc 	movw	r1, #30972	; 0x78fc
 8003d0e:	eb50 000e 	adcs.w	r0, r0, lr
 8003d12:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003d16:	f7fc fcf3 	bl	8000700 <_test_assert>
 8003d1a:	2800      	cmp	r0, #0
 8003d1c:	d1b3      	bne.n	8003c86 <test_008_005_execute.9880+0x36>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003d1e:	f7fe ffdf 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8003d22:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8003d26:	f1d0 0001 	rsbs	r0, r0, #1
 8003d2a:	bf38      	it	cc
 8003d2c:	2000      	movcc	r0, #0
 8003d2e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003d32:	f7fc fce5 	bl	8000700 <_test_assert>
 8003d36:	2800      	cmp	r0, #0
 8003d38:	d1a5      	bne.n	8003c86 <test_008_005_execute.9880+0x36>
    test_wait_threads();
  }
}
 8003d3a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 5, "event flags error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8003d3e:	f001 bf5f 	b.w	8005c00 <test_wait_threads>
 8003d42:	bf00      	nop
 8003d44:	f3af 8000 	nop.w
 8003d48:	f3af 8000 	nop.w
 8003d4c:	f3af 8000 	nop.w

08003d50 <chMBReset.constprop.21>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8003d50:	b538      	push	{r3, r4, r5, lr}
 8003d52:	2320      	movs	r3, #32
 8003d54:	f383 8811 	msr	BASEPRI, r3
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8003d58:	f640 0438 	movw	r4, #2104	; 0x838
 8003d5c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003d60:	6823      	ldr	r3, [r4, #0]
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (cnt_t)0;
  mbp->reset = true;
 8003d62:	2201      	movs	r2, #1
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8003d64:	f104 0018 	add.w	r0, r4, #24
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (cnt_t)0;
 8003d68:	2500      	movs	r5, #0
  mbp->reset = true;
 8003d6a:	7522      	strb	r2, [r4, #20]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8003d6c:	60a3      	str	r3, [r4, #8]
  mbp->rdptr = mbp->buffer;
 8003d6e:	60e3      	str	r3, [r4, #12]
  mbp->cnt   = (cnt_t)0;
 8003d70:	6125      	str	r5, [r4, #16]
  mbp->reset = true;
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8003d72:	f7fe ff2d 	bl	8002bd0 <chThdDequeueAllI.constprop.48>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8003d76:	f104 0020 	add.w	r0, r4, #32
 8003d7a:	f7fe ff29 	bl	8002bd0 <chThdDequeueAllI.constprop.48>
 */
void chMBReset(mailbox_t *mbp) {

  chSysLock();
  chMBResetI(mbp);
  chSchRescheduleS();
 8003d7e:	f7fc ff2f 	bl	8000be0 <chSchRescheduleS>
 8003d82:	f385 8811 	msr	BASEPRI, r5
 8003d86:	bd38      	pop	{r3, r4, r5, pc}
 8003d88:	f3af 8000 	nop.w
 8003d8c:	f3af 8000 	nop.w

08003d90 <test_009_003_execute.10097>:

static void test_009_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_003_execute(void) {
 8003d90:	b530      	push	{r4, r5, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [9.3.1] Filling the mailbox.*/
  test_set_step(1);
 8003d92:	f241 3530 	movw	r5, #4912	; 0x1330
 8003d96:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003d9a:	2301      	movs	r3, #1

static void test_009_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_003_execute(void) {
 8003d9c:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [9.3.1] Filling the mailbox.*/
  test_set_step(1);
 8003d9e:	602b      	str	r3, [r5, #0]
 8003da0:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8003da2:	4620      	mov	r0, r4
 8003da4:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8003da8:	f001 fb32 	bl	8005410 <chMBPost.constprop.20>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8003dac:	f647 1110 	movw	r1, #30992	; 0x7910
 8003db0:	f1d0 0001 	rsbs	r0, r0, #1
 8003db4:	bf38      	it	cc
 8003db6:	2000      	movcc	r0, #0
 8003db8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003dbc:	3401      	adds	r4, #1
 8003dbe:	f7fc fc9f 	bl	8000700 <_test_assert>
 8003dc2:	b990      	cbnz	r0, 8003dea <test_009_003_execute.10097+0x5a>
  unsigned i;

  /* [9.3.1] Filling the mailbox.*/
  test_set_step(1);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8003dc4:	2c46      	cmp	r4, #70	; 0x46
 8003dc6:	d1ec      	bne.n	8003da2 <test_009_003_execute.10097+0x12>
    }
  }

  /* [9.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8003dc8:	2302      	movs	r3, #2
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8003dca:	2101      	movs	r1, #1
 8003dcc:	2058      	movs	r0, #88	; 0x58
    }
  }

  /* [9.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8003dce:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8003dd0:	f001 fb1e 	bl	8005410 <chMBPost.constprop.20>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003dd4:	f1b0 33ff 	subs.w	r3, r0, #4294967295	; 0xffffffff
 8003dd8:	4258      	negs	r0, r3
 8003dda:	f647 1110 	movw	r1, #30992	; 0x7910
 8003dde:	4158      	adcs	r0, r3
 8003de0:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003de4:	f7fc fc8c 	bl	8000700 <_test_assert>
 8003de8:	b108      	cbz	r0, 8003dee <test_009_003_execute.10097+0x5e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 8003dea:	b003      	add	sp, #12
 8003dec:	bd30      	pop	{r4, r5, pc}
 8003dee:	2320      	movs	r3, #32
 8003df0:	f383 8811 	msr	BASEPRI, r3
  test_set_step(2);
  {
    msg1 = chMBPost(&mb1, 'X', 1);
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
    chSysLock();
    msg1 = chMBPostI(&mb1, 'X');
 8003df4:	2058      	movs	r0, #88	; 0x58
 8003df6:	f7fe fec3 	bl	8002b80 <chMBPostI.constprop.19>
 8003dfa:	2300      	movs	r3, #0
 8003dfc:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003e00:	f1b0 3cff 	subs.w	ip, r0, #4294967295	; 0xffffffff
 8003e04:	f1dc 0000 	rsbs	r0, ip, #0
 8003e08:	f647 1110 	movw	r1, #30992	; 0x7910
 8003e0c:	eb50 000c 	adcs.w	r0, r0, ip
 8003e10:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003e14:	f7fc fc74 	bl	8000700 <_test_assert>
 8003e18:	2800      	cmp	r0, #0
 8003e1a:	d1e6      	bne.n	8003dea <test_009_003_execute.10097+0x5a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 8003e1c:	2101      	movs	r1, #1
 8003e1e:	2058      	movs	r0, #88	; 0x58
 8003e20:	f001 fb3e 	bl	80054a0 <chMBPostAhead.constprop.18>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003e24:	f1b0 3eff 	subs.w	lr, r0, #4294967295	; 0xffffffff
 8003e28:	f1de 0000 	rsbs	r0, lr, #0
 8003e2c:	f647 1110 	movw	r1, #30992	; 0x7910
 8003e30:	eb50 000e 	adcs.w	r0, r0, lr
 8003e34:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003e38:	f7fc fc62 	bl	8000700 <_test_assert>
 8003e3c:	2800      	cmp	r0, #0
 8003e3e:	d1d4      	bne.n	8003dea <test_009_003_execute.10097+0x5a>
 8003e40:	2320      	movs	r3, #32
 8003e42:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'X');
 8003e46:	2058      	movs	r0, #88	; 0x58
 8003e48:	f7fe fe72 	bl	8002b30 <chMBPostAheadI.constprop.17>
 8003e4c:	2300      	movs	r3, #0
 8003e4e:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003e52:	f1b0 34ff 	subs.w	r4, r0, #4294967295	; 0xffffffff
 8003e56:	4260      	negs	r0, r4
 8003e58:	f647 1110 	movw	r1, #30992	; 0x7910
 8003e5c:	4160      	adcs	r0, r4
 8003e5e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003e62:	f7fc fc4d 	bl	8000700 <_test_assert>
 8003e66:	4604      	mov	r4, r0
 8003e68:	2800      	cmp	r0, #0
 8003e6a:	d1be      	bne.n	8003dea <test_009_003_execute.10097+0x5a>
  }

  /* [9.3.3] Resetting the mailbox. The mailbox is then returned in
     active state.*/
  test_set_step(3);
 8003e6c:	2303      	movs	r3, #3
 8003e6e:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 8003e70:	f7ff ff6e 	bl	8003d50 <chMBReset.constprop.21>
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 8003e74:	f640 0338 	movw	r3, #2104	; 0x838
 8003e78:	f2c2 0300 	movt	r3, #8192	; 0x2000
    chMBResumeX(&mb1);
  }

  /* [9.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 8003e7c:	2204      	movs	r2, #4
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8003e7e:	2101      	movs	r1, #1
 8003e80:	a801      	add	r0, sp, #4
 8003e82:	751c      	strb	r4, [r3, #20]
    chMBReset(&mb1);
    chMBResumeX(&mb1);
  }

  /* [9.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 8003e84:	602a      	str	r2, [r5, #0]
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8003e86:	f001 fb53 	bl	8005530 <chMBFetch.constprop.16>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003e8a:	f1b0 32ff 	subs.w	r2, r0, #4294967295	; 0xffffffff
 8003e8e:	4250      	negs	r0, r2
 8003e90:	f647 1110 	movw	r1, #30992	; 0x7910
 8003e94:	4150      	adcs	r0, r2
 8003e96:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003e9a:	f7fc fc31 	bl	8000700 <_test_assert>
 8003e9e:	2800      	cmp	r0, #0
 8003ea0:	d1a3      	bne.n	8003dea <test_009_003_execute.10097+0x5a>
 8003ea2:	2320      	movs	r3, #32
 8003ea4:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8003ea8:	a801      	add	r0, sp, #4
 8003eaa:	f7fe fe19 	bl	8002ae0 <chMBFetchI.constprop.15>
 8003eae:	2300      	movs	r3, #0
 8003eb0:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003eb4:	f1b0 33ff 	subs.w	r3, r0, #4294967295	; 0xffffffff
 8003eb8:	4258      	negs	r0, r3
 8003eba:	f647 1110 	movw	r1, #30992	; 0x7910
 8003ebe:	4158      	adcs	r0, r3
 8003ec0:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003ec4:	f7fc fc1c 	bl	8000700 <_test_assert>
 8003ec8:	e78f      	b.n	8003dea <test_009_003_execute.10097+0x5a>
 8003eca:	bf00      	nop
 8003ecc:	f3af 8000 	nop.w

08003ed0 <test_009_001_teardown.10095>:
static void test_009_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_009_001_teardown(void) {
  chMBReset(&mb1);
 8003ed0:	f7ff bf3e 	b.w	8003d50 <chMBReset.constprop.21>
 8003ed4:	f3af 8000 	nop.w
 8003ed8:	f3af 8000 	nop.w
 8003edc:	f3af 8000 	nop.w

08003ee0 <test_009_002_teardown.10093>:
static void test_009_002_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_009_002_teardown(void) {
  chMBReset(&mb1);
 8003ee0:	f7ff bf36 	b.w	8003d50 <chMBReset.constprop.21>
 8003ee4:	f3af 8000 	nop.w
 8003ee8:	f3af 8000 	nop.w
 8003eec:	f3af 8000 	nop.w

08003ef0 <test_009_003_teardown.10091>:
static void test_009_003_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_009_003_teardown(void) {
  chMBReset(&mb1);
 8003ef0:	f7ff bf2e 	b.w	8003d50 <chMBReset.constprop.21>
 8003ef4:	f3af 8000 	nop.w
 8003ef8:	f3af 8000 	nop.w
 8003efc:	f3af 8000 	nop.w

08003f00 <test_008_006_execute.9876>:

static void test_008_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_008_006_execute(void) {
 8003f00:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;

  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 8003f02:	f241 3530 	movw	r5, #4912	; 0x1330
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003f06:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8003f0a:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003f0e:	2301      	movs	r3, #1
 8003f10:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003f14:	602b      	str	r3, [r5, #0]
 8003f16:	69a2      	ldr	r2, [r4, #24]
 8003f18:	2320      	movs	r3, #32
 8003f1a:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003f1e:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003f20:	b953      	cbnz	r3, 8003f38 <test_008_006_execute.9876+0x38>
 8003f22:	f383 8811 	msr	BASEPRI, r3
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003f26:	f647 113c 	movw	r1, #31036	; 0x793c
 8003f2a:	2001      	movs	r0, #1
 8003f2c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003f30:	f7fc fbe6 	bl	8000700 <_test_assert>
 8003f34:	b1a0      	cbz	r0, 8003f60 <test_008_006_execute.9876+0x60>
 8003f36:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8003f38:	4258      	negs	r0, r3
 8003f3a:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8003f3c:	ea23 0300 	bic.w	r3, r3, r0
 8003f40:	6353      	str	r3, [r2, #52]	; 0x34
 8003f42:	2300      	movs	r3, #0
 8003f44:	f383 8811 	msr	BASEPRI, r3
 8003f48:	f647 113c 	movw	r1, #31036	; 0x793c
 8003f4c:	f1d0 0001 	rsbs	r0, r0, #1
 8003f50:	bf38      	it	cc
 8003f52:	2000      	movcc	r0, #0
 8003f54:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003f58:	f7fc fbd2 	bl	8000700 <_test_assert>
 8003f5c:	2800      	cmp	r0, #0
 8003f5e:	d1ea      	bne.n	8003f36 <test_008_006_execute.9876+0x36>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003f60:	69a3      	ldr	r3, [r4, #24]
 8003f62:	2220      	movs	r2, #32
 8003f64:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 8003f68:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003f6a:	2a00      	cmp	r2, #0
 8003f6c:	d035      	beq.n	8003fda <test_008_006_execute.9876+0xda>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8003f6e:	2200      	movs	r2, #0
 8003f70:	635a      	str	r2, [r3, #52]	; 0x34
 8003f72:	f382 8811 	msr	BASEPRI, r2
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003f76:	f647 113c 	movw	r1, #31036	; 0x793c
 8003f7a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003f7e:	f7fc fbbf 	bl	8000700 <_test_assert>
 8003f82:	2800      	cmp	r0, #0
 8003f84:	d1d7      	bne.n	8003f36 <test_008_006_execute.9876+0x36>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003f86:	69a3      	ldr	r3, [r4, #24]
 8003f88:	2220      	movs	r2, #32
 8003f8a:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  if ((ctp->epending & events) != events) {
 8003f8e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003f90:	3201      	adds	r2, #1
 8003f92:	d07a      	beq.n	800408a <test_008_006_execute.9876+0x18a>
 8003f94:	2300      	movs	r3, #0
 8003f96:	f383 8811 	msr	BASEPRI, r3
 8003f9a:	2001      	movs	r0, #1
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8003f9c:	f647 113c 	movw	r1, #31036	; 0x793c
 8003fa0:	f6c0 0100 	movt	r1, #2048	; 0x800
 8003fa4:	f7fc fbac 	bl	8000700 <_test_assert>
 8003fa8:	2800      	cmp	r0, #0
 8003faa:	d1c4      	bne.n	8003f36 <test_008_006_execute.9876+0x36>
  }

  /* [8.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8003fac:	2302      	movs	r3, #2
 8003fae:	602b      	str	r3, [r5, #0]
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8003fb0:	69a6      	ldr	r6, [r4, #24]
 8003fb2:	2320      	movs	r3, #32
 8003fb4:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8003fb8:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003fba:	b995      	cbnz	r5, 8003fe2 <test_008_006_execute.9876+0xe2>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8003fbc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003fc0:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8003fc2:	200a      	movs	r0, #10
 8003fc4:	2132      	movs	r1, #50	; 0x32
 8003fc6:	f000 ff23 	bl	8004e10 <chSchGoSleepTimeoutS>
 8003fca:	2800      	cmp	r0, #0
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8003fcc:	bfa8      	it	ge
 8003fce:	6b75      	ldrge	r5, [r6, #52]	; 0x34
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8003fd0:	da07      	bge.n	8003fe2 <test_008_006_execute.9876+0xe2>
 8003fd2:	f385 8811 	msr	BASEPRI, r5
 8003fd6:	2001      	movs	r0, #1
 8003fd8:	e00f      	b.n	8003ffa <test_008_006_execute.9876+0xfa>
 8003fda:	f382 8811 	msr	BASEPRI, r2
 8003fde:	2001      	movs	r0, #1
 8003fe0:	e7c9      	b.n	8003f76 <test_008_006_execute.9876+0x76>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8003fe2:	4268      	negs	r0, r5
 8003fe4:	4028      	ands	r0, r5
  ctp->epending &= ~m;
 8003fe6:	ea25 0500 	bic.w	r5, r5, r0
 8003fea:	6375      	str	r5, [r6, #52]	; 0x34
 8003fec:	2300      	movs	r3, #0
 8003fee:	f383 8811 	msr	BASEPRI, r3
 8003ff2:	f1d0 0001 	rsbs	r0, r0, #1
 8003ff6:	bf38      	it	cc
 8003ff8:	2000      	movcc	r0, #0
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8003ffa:	f647 113c 	movw	r1, #31036	; 0x793c
 8003ffe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004002:	f7fc fb7d 	bl	8000700 <_test_assert>
 8004006:	2800      	cmp	r0, #0
 8004008:	d195      	bne.n	8003f36 <test_008_006_execute.9876+0x36>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800400a:	69a5      	ldr	r5, [r4, #24]
 800400c:	2320      	movs	r3, #32
 800400e:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8004012:	6b6e      	ldr	r6, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8004014:	b956      	cbnz	r6, 800402c <test_008_006_execute.9876+0x12c>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8004016:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800401a:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800401c:	200a      	movs	r0, #10
 800401e:	2132      	movs	r1, #50	; 0x32
 8004020:	f000 fef6 	bl	8004e10 <chSchGoSleepTimeoutS>
 8004024:	2800      	cmp	r0, #0
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8004026:	bfa8      	it	ge
 8004028:	6b6e      	ldrge	r6, [r5, #52]	; 0x34
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800402a:	db33      	blt.n	8004094 <test_008_006_execute.9876+0x194>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 800402c:	2300      	movs	r3, #0
 800402e:	636b      	str	r3, [r5, #52]	; 0x34
 8004030:	f383 8811 	msr	BASEPRI, r3
 8004034:	f1d6 0001 	rsbs	r0, r6, #1
 8004038:	bf38      	it	cc
 800403a:	2000      	movcc	r0, #0
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 800403c:	f647 113c 	movw	r1, #31036	; 0x793c
 8004040:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004044:	f7fc fb5c 	bl	8000700 <_test_assert>
 8004048:	4605      	mov	r5, r0
 800404a:	2800      	cmp	r0, #0
 800404c:	f47f af73 	bne.w	8003f36 <test_008_006_execute.9876+0x36>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8004050:	69a4      	ldr	r4, [r4, #24]
 8004052:	2320      	movs	r3, #32
 8004054:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 8004058:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800405a:	3301      	adds	r3, #1
 800405c:	d008      	beq.n	8004070 <test_008_006_execute.9876+0x170>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 800405e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004062:	6263      	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8004064:	200b      	movs	r0, #11
 8004066:	2132      	movs	r1, #50	; 0x32
 8004068:	f000 fed2 	bl	8004e10 <chSchGoSleepTimeoutS>
 800406c:	2800      	cmp	r0, #0
 800406e:	db15      	blt.n	800409c <test_008_006_execute.9876+0x19c>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8004070:	2300      	movs	r3, #0
 8004072:	6363      	str	r3, [r4, #52]	; 0x34
 8004074:	f383 8811 	msr	BASEPRI, r3
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8004078:	f647 113c 	movw	r1, #31036	; 0x793c
 800407c:	4628      	mov	r0, r5
 800407e:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 8004082:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8004086:	f7fc bb3b 	b.w	8000700 <_test_assert>
 800408a:	2200      	movs	r2, #0
 800408c:	635a      	str	r2, [r3, #52]	; 0x34
 800408e:	f382 8811 	msr	BASEPRI, r2
 8004092:	e783      	b.n	8003f9c <test_008_006_execute.9876+0x9c>
 8004094:	f386 8811 	msr	BASEPRI, r6
 8004098:	2001      	movs	r0, #1
 800409a:	e7cf      	b.n	800403c <test_008_006_execute.9876+0x13c>
 800409c:	2300      	movs	r3, #0
 800409e:	f383 8811 	msr	BASEPRI, r3
 80040a2:	2501      	movs	r5, #1
 80040a4:	e7e8      	b.n	8004078 <test_008_006_execute.9876+0x178>
 80040a6:	bf00      	nop
 80040a8:	f3af 8000 	nop.w
 80040ac:	f3af 8000 	nop.w

080040b0 <test_005_006_execute.9261>:

static void test_005_006_teardown(void) {
  test_wait_threads();
}

static void test_005_006_execute(void) {
 80040b0:	b570      	push	{r4, r5, r6, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80040b2:	f241 3430 	movw	r4, #4912	; 0x1330

static void test_005_006_teardown(void) {
  test_wait_threads();
}

static void test_005_006_execute(void) {
 80040b6:	b084      	sub	sp, #16
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80040b8:	ad01      	add	r5, sp, #4
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 80040ba:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80040be:	2201      	movs	r2, #1
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 80040c0:	2300      	movs	r3, #0
 80040c2:	9303      	str	r3, [sp, #12]
 80040c4:	6022      	str	r2, [r4, #0]
 80040c6:	9501      	str	r5, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 80040c8:	9502      	str	r5, [sp, #8]
 80040ca:	2320      	movs	r3, #32
 80040cc:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80040d0:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80040d2:	f647 114c 	movw	r1, #31052	; 0x794c
 80040d6:	2800      	cmp	r0, #0
 80040d8:	bfcc      	ite	gt
 80040da:	2000      	movgt	r0, #0
 80040dc:	2001      	movle	r0, #1
 80040de:	f6c0 0100 	movt	r1, #2048	; 0x800
 80040e2:	f7fc fb0d 	bl	8000700 <_test_assert>
 80040e6:	b120      	cbz	r0, 80040f2 <test_005_006_execute.9261+0x42>
 80040e8:	2300      	movs	r3, #0
 80040ea:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 80040ee:	b004      	add	sp, #16
 80040f0:	bd70      	pop	{r4, r5, r6, pc}
 80040f2:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [5.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 80040f6:	2302      	movs	r3, #2
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 80040f8:	4628      	mov	r0, r5
 80040fa:	2100      	movs	r1, #0
 80040fc:	6023      	str	r3, [r4, #0]
 80040fe:	f7fd f92f 	bl	8001360 <chSemReset>
 8004102:	2320      	movs	r3, #32
 8004104:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8004108:	9803      	ldr	r0, [sp, #12]
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800410a:	f647 114c 	movw	r1, #31052	; 0x794c
 800410e:	2800      	cmp	r0, #0
 8004110:	bfcc      	ite	gt
 8004112:	2000      	movgt	r0, #0
 8004114:	2001      	movle	r0, #1
 8004116:	f6c0 0100 	movt	r1, #2048	; 0x800
 800411a:	f7fc faf1 	bl	8000700 <_test_assert>
 800411e:	2800      	cmp	r0, #0
 8004120:	d1e2      	bne.n	80040e8 <test_005_006_execute.9261+0x38>
 8004122:	f380 8811 	msr	BASEPRI, r0
 8004126:	f241 23c0 	movw	r3, #4800	; 0x12c0
 800412a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800412e:	699b      	ldr	r3, [r3, #24]
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004130:	f640 1050 	movw	r0, #2384	; 0x950
 8004134:	6899      	ldr	r1, [r3, #8]
 8004136:	f244 2281 	movw	r2, #17025	; 0x4281
 800413a:	3901      	subs	r1, #1
 800413c:	462b      	mov	r3, r5
 800413e:	f6c0 0200 	movt	r2, #2048	; 0x800
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8004142:	2603      	movs	r6, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004144:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8004148:	6026      	str	r6, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800414a:	f001 fbe1 	bl	8005910 <chThdCreateStatic.constprop.52>
 800414e:	f640 73d4 	movw	r3, #4052	; 0xfd4
 8004152:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004156:	6018      	str	r0, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [5.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 8004158:	2304      	movs	r3, #4
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->sem);
 800415a:	4628      	mov	r0, r5
 800415c:	6023      	str	r3, [r4, #0]
 800415e:	f7fc fe6f 	bl	8000e40 <chSemWait>
 8004162:	2320      	movs	r3, #32
 8004164:	4606      	mov	r6, r0
 8004166:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 800416a:	9803      	ldr	r0, [sp, #12]
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800416c:	f647 114c 	movw	r1, #31052	; 0x794c
 8004170:	2800      	cmp	r0, #0
 8004172:	bfcc      	ite	gt
 8004174:	2000      	movgt	r0, #0
 8004176:	2001      	movle	r0, #1
 8004178:	f6c0 0100 	movt	r1, #2048	; 0x800
 800417c:	f7fc fac0 	bl	8000700 <_test_assert>
 8004180:	2800      	cmp	r0, #0
 8004182:	d1b1      	bne.n	80040e8 <test_005_006_execute.9261+0x38>
 8004184:	f380 8811 	msr	BASEPRI, r0
    test_assert(msg == MSG_OK, "unexpected message");
 8004188:	f647 1158 	movw	r1, #31064	; 0x7958
 800418c:	f1d6 0001 	rsbs	r0, r6, #1
 8004190:	bf38      	it	cc
 8004192:	2000      	movcc	r0, #0
 8004194:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004198:	f7fc fab2 	bl	8000700 <_test_assert>
 800419c:	2800      	cmp	r0, #0
 800419e:	d1a6      	bne.n	80040ee <test_005_006_execute.9261+0x3e>
  }

  /* [5.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 80041a0:	2305      	movs	r3, #5
 80041a2:	6023      	str	r3, [r4, #0]
 80041a4:	2320      	movs	r3, #32
 80041a6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80041aa:	9b03      	ldr	r3, [sp, #12]
 80041ac:	2b00      	cmp	r3, #0
 80041ae:	dd5b      	ble.n	8004268 <test_005_006_execute.9261+0x1b8>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80041b0:	f7fc fd16 	bl	8000be0 <chSchRescheduleS>
 80041b4:	2300      	movs	r3, #0
 80041b6:	f383 8811 	msr	BASEPRI, r3
 80041ba:	2320      	movs	r3, #32
 80041bc:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 80041c0:	9803      	ldr	r0, [sp, #12]
 80041c2:	f647 116c 	movw	r1, #31084	; 0x796c
 80041c6:	2800      	cmp	r0, #0
 80041c8:	bfd4      	ite	le
 80041ca:	2000      	movle	r0, #0
 80041cc:	2001      	movgt	r0, #1
 80041ce:	f6c0 0100 	movt	r1, #2048	; 0x800
 80041d2:	f7fc fa95 	bl	8000700 <_test_assert>
 80041d6:	2800      	cmp	r0, #0
 80041d8:	d186      	bne.n	80040e8 <test_005_006_execute.9261+0x38>
 80041da:	f380 8811 	msr	BASEPRI, r0
 80041de:	2320      	movs	r3, #32
 80041e0:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 80041e4:	9803      	ldr	r0, [sp, #12]
 80041e6:	f647 1178 	movw	r1, #31096	; 0x7978
 80041ea:	1e42      	subs	r2, r0, #1
 80041ec:	4250      	negs	r0, r2
 80041ee:	4150      	adcs	r0, r2
 80041f0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80041f4:	f7fc fa84 	bl	8000700 <_test_assert>
 80041f8:	2800      	cmp	r0, #0
 80041fa:	f47f af75 	bne.w	80040e8 <test_005_006_execute.9261+0x38>
 80041fe:	f380 8811 	msr	BASEPRI, r0
  }

  /* [5.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8004202:	2306      	movs	r3, #6
 8004204:	6023      	str	r3, [r4, #0]
 8004206:	2320      	movs	r3, #32
 8004208:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 800420c:	9b03      	ldr	r3, [sp, #12]
 800420e:	2b00      	cmp	r3, #0
 8004210:	dd2e      	ble.n	8004270 <test_005_006_execute.9261+0x1c0>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8004212:	f7fc fce5 	bl	8000be0 <chSchRescheduleS>
 8004216:	2300      	movs	r3, #0
 8004218:	f383 8811 	msr	BASEPRI, r3
 800421c:	2320      	movs	r3, #32
 800421e:	f383 8811 	msr	BASEPRI, r3
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8004222:	9803      	ldr	r0, [sp, #12]
 8004224:	f647 1150 	movw	r1, #31056	; 0x7950
 8004228:	2800      	cmp	r0, #0
 800422a:	bfd4      	ite	le
 800422c:	2000      	movle	r0, #0
 800422e:	2001      	movgt	r0, #1
 8004230:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004234:	f7fc fa64 	bl	8000700 <_test_assert>
 8004238:	2800      	cmp	r0, #0
 800423a:	f47f af55 	bne.w	80040e8 <test_005_006_execute.9261+0x38>
 800423e:	f380 8811 	msr	BASEPRI, r0
 8004242:	2320      	movs	r3, #32
 8004244:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8004248:	9803      	ldr	r0, [sp, #12]
 800424a:	f647 1178 	movw	r1, #31096	; 0x7978
 800424e:	1e43      	subs	r3, r0, #1
 8004250:	4258      	negs	r0, r3
 8004252:	4158      	adcs	r0, r3
 8004254:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004258:	f7fc fa52 	bl	8000700 <_test_assert>
 800425c:	2800      	cmp	r0, #0
 800425e:	f47f af43 	bne.w	80040e8 <test_005_006_execute.9261+0x38>
 8004262:	f380 8811 	msr	BASEPRI, r0
 8004266:	e742      	b.n	80040ee <test_005_006_execute.9261+0x3e>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 8004268:	4628      	mov	r0, r5
 800426a:	f7fd f861 	bl	8001330 <chSemSignalI>
 800426e:	e79f      	b.n	80041b0 <test_005_006_execute.9261+0x100>
 8004270:	4628      	mov	r0, r5
 8004272:	f7fd f85d 	bl	8001330 <chSemSignalI>
 8004276:	e7cc      	b.n	8004212 <test_005_006_execute.9261+0x162>
 8004278:	f3af 8000 	nop.w
 800427c:	f3af 8000 	nop.w

08004280 <thread4.9231.4116>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {
 8004280:	b508      	push	{r3, lr}
 8004282:	2320      	movs	r3, #32
 8004284:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8004288:	6883      	ldr	r3, [r0, #8]
 800428a:	2b00      	cmp	r3, #0
 800428c:	dd05      	ble.n	800429a <thread4.9231.4116+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800428e:	f7fc fca7 	bl	8000be0 <chSchRescheduleS>
 8004292:	2300      	movs	r3, #0
 8004294:	f383 8811 	msr	BASEPRI, r3
 8004298:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 800429a:	f7fd f849 	bl	8001330 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800429e:	f7fc fc9f 	bl	8000be0 <chSchRescheduleS>
 80042a2:	2300      	movs	r3, #0
 80042a4:	f383 8811 	msr	BASEPRI, r3
 80042a8:	bd08      	pop	{r3, pc}
 80042aa:	bf00      	nop
 80042ac:	f3af 8000 	nop.w

080042b0 <test_005_003_execute.9283>:

static void test_005_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_005_003_execute(void) {
 80042b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 80042b4:	f241 3530 	movw	r5, #4912	; 0x1330
 80042b8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80042bc:	2301      	movs	r3, #1
 80042be:	602b      	str	r3, [r5, #0]
 80042c0:	2320      	movs	r3, #32
 80042c2:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 80042c6:	f640 74c8 	movw	r4, #4040	; 0xfc8
 80042ca:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80042ce:	68a3      	ldr	r3, [r4, #8]
 80042d0:	3b01      	subs	r3, #1
 80042d2:	bf5a      	itte	pl
 80042d4:	60a3      	strpl	r3, [r4, #8]
 80042d6:	2000      	movpl	r0, #0
 80042d8:	2001      	movmi	r0, #1
 80042da:	2300      	movs	r3, #0
 80042dc:	f383 8811 	msr	BASEPRI, r3
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 80042e0:	f647 1110 	movw	r1, #30992	; 0x7910
 80042e4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80042e8:	f7fc fa0a 	bl	8000700 <_test_assert>
 80042ec:	b108      	cbz	r0, 80042f2 <test_005_003_execute.9283+0x42>
 80042ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80042f2:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80042f4:	f247 6198 	movw	r1, #30360	; 0x7698
 80042f8:	ebb0 0904 	subs.w	r9, r0, r4
 80042fc:	f1d9 0000 	rsbs	r0, r9, #0
 8004300:	eb50 0009 	adcs.w	r0, r0, r9
 8004304:	f640 76c8 	movw	r6, #4040	; 0xfc8
 8004308:	f6c0 0100 	movt	r1, #2048	; 0x800
 800430c:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8004310:	f7fc f9f6 	bl	8000700 <_test_assert>
 8004314:	2800      	cmp	r0, #0
 8004316:	d1ea      	bne.n	80042ee <test_005_003_execute.9283+0x3e>
    test_assert(sem1.cnt == 0, "counter not zero");
 8004318:	68b0      	ldr	r0, [r6, #8]
 800431a:	f647 118c 	movw	r1, #31116	; 0x798c
 800431e:	f1d0 0001 	rsbs	r0, r0, #1
 8004322:	bf38      	it	cc
 8004324:	2000      	movcc	r0, #0
 8004326:	f6c0 0100 	movt	r1, #2048	; 0x800
 800432a:	f7fc f9e9 	bl	8000700 <_test_assert>
 800432e:	4603      	mov	r3, r0
 8004330:	2800      	cmp	r0, #0
 8004332:	d1dc      	bne.n	80042ee <test_005_003_execute.9283+0x3e>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004334:	f241 22c0 	movw	r2, #4800	; 0x12c0
 8004338:	f2c2 0200 	movt	r2, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800433c:	6992      	ldr	r2, [r2, #24]
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800433e:	f640 1050 	movw	r0, #2384	; 0x950
 8004342:	6891      	ldr	r1, [r2, #8]
 8004344:	f641 62c1 	movw	r2, #7873	; 0x1ec1
 8004348:	3901      	subs	r1, #1
 800434a:	f6c0 0200 	movt	r2, #2048	; 0x800
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 800434e:	2602      	movs	r6, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004350:	f2c2 0000 	movt	r0, #8192	; 0x2000
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8004354:	602e      	str	r6, [r5, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004356:	f001 fadb 	bl	8005910 <chThdCreateStatic.constprop.52>
 800435a:	f640 73d4 	movw	r3, #4052	; 0xfd4
 800435e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004362:	6018      	str	r0, [r3, #0]
 8004364:	2320      	movs	r3, #32
 8004366:	f383 8811 	msr	BASEPRI, r3
 800436a:	68a3      	ldr	r3, [r4, #8]
 800436c:	3b01      	subs	r3, #1
 800436e:	2b00      	cmp	r3, #0
 8004370:	60a3      	str	r3, [r4, #8]
 8004372:	bfa8      	it	ge
 8004374:	2601      	movge	r6, #1
 8004376:	f2c0 8092 	blt.w	800449e <test_005_003_execute.9283+0x1ee>
 800437a:	2300      	movs	r3, #0
 800437c:	f383 8811 	msr	BASEPRI, r3
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_wait_threads();
 8004380:	f001 fc3e 	bl	8005c00 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8004384:	f647 1110 	movw	r1, #30992	; 0x7910
 8004388:	4630      	mov	r0, r6
 800438a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800438e:	f7fc f9b7 	bl	8000700 <_test_assert>
 8004392:	2800      	cmp	r0, #0
 8004394:	d1ab      	bne.n	80042ee <test_005_003_execute.9283+0x3e>
 8004396:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8004398:	f247 6198 	movw	r1, #30360	; 0x7698
 800439c:	ebb0 0804 	subs.w	r8, r0, r4
 80043a0:	f1d8 0000 	rsbs	r0, r8, #0
 80043a4:	eb50 0008 	adcs.w	r0, r0, r8
 80043a8:	f640 76c8 	movw	r6, #4040	; 0xfc8
 80043ac:	f6c0 0100 	movt	r1, #2048	; 0x800
 80043b0:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80043b4:	f7fc f9a4 	bl	8000700 <_test_assert>
 80043b8:	2800      	cmp	r0, #0
 80043ba:	d198      	bne.n	80042ee <test_005_003_execute.9283+0x3e>
    test_assert(sem1.cnt == 0, "counter not zero");
 80043bc:	68b0      	ldr	r0, [r6, #8]
 80043be:	f647 118c 	movw	r1, #31116	; 0x798c
 80043c2:	f1d0 0001 	rsbs	r0, r0, #1
 80043c6:	bf38      	it	cc
 80043c8:	2000      	movcc	r0, #0
 80043ca:	f6c0 0100 	movt	r1, #2048	; 0x800
 80043ce:	f7fc f997 	bl	8000700 <_test_assert>
 80043d2:	2800      	cmp	r0, #0
 80043d4:	d18b      	bne.n	80042ee <test_005_003_execute.9283+0x3e>
  }

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
 80043d6:	2303      	movs	r3, #3
 80043d8:	602b      	str	r3, [r5, #0]
 80043da:	4680      	mov	r8, r0
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 80043dc:	f000 fdc8 	bl	8004f70 <test_wait_tick>
 80043e0:	2541      	movs	r5, #65	; 0x41
 80043e2:	4681      	mov	r9, r0
 80043e4:	2720      	movs	r7, #32
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
 80043e6:	4628      	mov	r0, r5
 80043e8:	f7fc f8e2 	bl	80005b0 <test_emit_token>
 80043ec:	f387 8811 	msr	BASEPRI, r7
 80043f0:	68a3      	ldr	r3, [r4, #8]
 80043f2:	2000      	movs	r0, #0
 80043f4:	3b01      	subs	r3, #1
 80043f6:	4283      	cmp	r3, r0
 80043f8:	60a3      	str	r3, [r4, #8]
 80043fa:	da0c      	bge.n	8004416 <test_005_003_execute.9283+0x166>
 80043fc:	f640 70c8 	movw	r0, #4040	; 0xfc8
 8004400:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004404:	2132      	movs	r1, #50	; 0x32
 8004406:	f7fd fd73 	bl	8001ef0 <chSemWaitTimeoutS.part.1.5425>
 800440a:	f1b0 3cff 	subs.w	ip, r0, #4294967295	; 0xffffffff
 800440e:	f1dc 0000 	rsbs	r0, ip, #0
 8004412:	eb50 000c 	adcs.w	r0, r0, ip
 8004416:	f388 8811 	msr	BASEPRI, r8
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800441a:	f647 1110 	movw	r1, #30992	; 0x7910
 800441e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004422:	f7fc f96d 	bl	8000700 <_test_assert>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8004426:	f247 6198 	movw	r1, #30360	; 0x7698
 800442a:	f6c0 0100 	movt	r1, #2048	; 0x800
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800442e:	2800      	cmp	r0, #0
 8004430:	f47f af5d 	bne.w	80042ee <test_005_003_execute.9283+0x3e>
 8004434:	6820      	ldr	r0, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8004436:	ebb0 0e04 	subs.w	lr, r0, r4
 800443a:	f1de 0000 	rsbs	r0, lr, #0
 800443e:	eb50 000e 	adcs.w	r0, r0, lr
 8004442:	f7fc f95d 	bl	8000700 <_test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
 8004446:	f647 118c 	movw	r1, #31116	; 0x798c
 800444a:	f6c0 0100 	movt	r1, #2048	; 0x800
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800444e:	2800      	cmp	r0, #0
 8004450:	f47f af4d 	bne.w	80042ee <test_005_003_execute.9283+0x3e>
      test_assert(sem1.cnt == 0, "counter not zero");
 8004454:	68b0      	ldr	r0, [r6, #8]
 8004456:	3501      	adds	r5, #1
 8004458:	f1d0 0001 	rsbs	r0, r0, #1
 800445c:	bf38      	it	cc
 800445e:	2000      	movcc	r0, #0
 8004460:	f7fc f94e 	bl	8000700 <_test_assert>
 8004464:	b2ed      	uxtb	r5, r5
 8004466:	2800      	cmp	r0, #0
 8004468:	f47f af41 	bne.w	80042ee <test_005_003_execute.9283+0x3e>

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
 800446c:	2d46      	cmp	r5, #70	; 0x46
 800446e:	d1ba      	bne.n	80043e6 <test_005_003_execute.9283+0x136>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8004470:	f647 10a0 	movw	r0, #31136	; 0x79a0
 8004474:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8004478:	f6c0 0000 	movt	r0, #2048	; 0x800
 800447c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004480:	f7fc f90e 	bl	80006a0 <_test_assert_sequence>
 8004484:	2800      	cmp	r0, #0
 8004486:	f47f af32 	bne.w	80042ee <test_005_003_execute.9283+0x3e>
  }

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 800448a:	f109 00fa 	add.w	r0, r9, #250	; 0xfa
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800448e:	f109 01fc 	add.w	r1, r9, #252	; 0xfc
 8004492:	b280      	uxth	r0, r0
 8004494:	b289      	uxth	r1, r1
                            "out of time window");
  }
}
 8004496:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800449a:	f7fe bd21 	b.w	8002ee0 <_test_assert_time_window.constprop.2>
 800449e:	f640 70c8 	movw	r0, #4040	; 0xfc8
 80044a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80044a6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80044aa:	f7fd fd21 	bl	8001ef0 <chSemWaitTimeoutS.part.1.5425>
 80044ae:	f1d0 0601 	rsbs	r6, r0, #1
 80044b2:	bf38      	it	cc
 80044b4:	2600      	movcc	r6, #0
 80044b6:	e760      	b.n	800437a <test_005_003_execute.9283+0xca>
 80044b8:	f3af 8000 	nop.w
 80044bc:	f3af 8000 	nop.w

080044c0 <test_002_002_execute.8660>:
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_002_002_execute(void) {
 80044c0:	b510      	push	{r4, lr}
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 80044c2:	f241 3430 	movw	r4, #4912	; 0x1330
 80044c6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80044ca:	2301      	movs	r3, #1
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_002_002_execute(void) {
 80044cc:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 80044ce:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80044d0:	f3ef 8311 	mrs	r3, BASEPRI
 80044d4:	b91b      	cbnz	r3, 80044de <test_002_002_execute.8660+0x1e>
 80044d6:	f7fc ffd3 	bl	8001480 <chSysGetStatusAndLockX.part.1.4323>
 80044da:	f7fc fc11 	bl	8000d00 <chSysRestoreStatusX.part.2.4326>
    chSysRestoreStatusX(sts);
  }

  /* [2.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 80044de:	2302      	movs	r3, #2
 80044e0:	6023      	str	r3, [r4, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80044e2:	2320      	movs	r3, #32
 80044e4:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80044e8:	f3ef 8311 	mrs	r3, BASEPRI
 80044ec:	b91b      	cbnz	r3, 80044f6 <test_002_002_execute.8660+0x36>
 80044ee:	f7fc ffc7 	bl	8001480 <chSysGetStatusAndLockX.part.1.4323>
 80044f2:	f7fc fc05 	bl	8000d00 <chSysRestoreStatusX.part.2.4326>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80044f6:	2300      	movs	r3, #0
 80044f8:	f383 8811 	msr	BASEPRI, r3
    chSysRestoreStatusX(sts);
    chSysUnlock();
  }

  /* [2.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 80044fc:	2303      	movs	r3, #3
 80044fe:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004500:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8004504:	b913      	cbnz	r3, 800450c <test_002_002_execute.8660+0x4c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004506:	2320      	movs	r3, #32
 8004508:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800450c:	f3ef 8311 	mrs	r3, BASEPRI
 8004510:	b913      	cbnz	r3, 8004518 <test_002_002_execute.8660+0x58>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004512:	2320      	movs	r3, #32
 8004514:	f383 8811 	msr	BASEPRI, r3
 8004518:	2300      	movs	r3, #0
 800451a:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalLock();
    chSysUnlock();
  }

  /* [2.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 800451e:	2304      	movs	r3, #4
 8004520:	6023      	str	r3, [r4, #0]
 8004522:	2320      	movs	r3, #32
 8004524:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004528:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800452c:	b113      	cbz	r3, 8004534 <test_002_002_execute.8660+0x74>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800452e:	2300      	movs	r3, #0
 8004530:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004534:	f3ef 8311 	mrs	r3, BASEPRI
 8004538:	b113      	cbz	r3, 8004540 <test_002_002_execute.8660+0x80>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800453a:	2300      	movs	r3, #0
 800453c:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalUnlock();
    chSysUnconditionalUnlock();
  }

  /* [2.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8004540:	2205      	movs	r2, #5
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8004542:	2300      	movs	r3, #0
 8004544:	9304      	str	r3, [sp, #16]
 8004546:	6022      	str	r2, [r4, #0]
 8004548:	2320      	movs	r3, #32
 800454a:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800454e:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8004550:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8004552:	b113      	cbz	r3, 800455a <test_002_002_execute.8660+0x9a>
    chVTDoResetI(vtp);
 8004554:	4620      	mov	r0, r4
 8004556:	f7fc fa4b 	bl	80009f0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800455a:	f243 12b1 	movw	r2, #12721	; 0x31b1
 800455e:	4620      	mov	r0, r4
 8004560:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004564:	2101      	movs	r1, #1
 8004566:	2300      	movs	r3, #0
 8004568:	f000 fc02 	bl	8004d70 <chVTDoSetI>
 800456c:	2300      	movs	r3, #0
 800456e:	f383 8811 	msr	BASEPRI, r3
  {
    chVTObjectInit(&vt);
    chVTSet(&vt, 1, vtcb, NULL);
    chThdSleep(10);
 8004572:	200a      	movs	r0, #10
 8004574:	f000 fc7c 	bl	8004e70 <chThdSleep>
 8004578:	2320      	movs	r3, #32
 800457a:	f383 8811 	msr	BASEPRI, r3
 800457e:	2300      	movs	r3, #0
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 8004580:	9804      	ldr	r0, [sp, #16]
 8004582:	f383 8811 	msr	BASEPRI, r3

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8004586:	f647 11a8 	movw	r1, #31144	; 0x79a8
 800458a:	f1d0 0001 	rsbs	r0, r0, #1
 800458e:	bf38      	it	cc
 8004590:	2000      	movcc	r0, #0
 8004592:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004596:	f7fc f8b3 	bl	8000700 <_test_assert>
  }
}
 800459a:	b006      	add	sp, #24
 800459c:	bd10      	pop	{r4, pc}
 800459e:	bf00      	nop

080045a0 <test_004_001_execute.9052>:
}

static void test_004_001_execute(void) {
 80045a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80045a2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80045a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80045aa:	699b      	ldr	r3, [r3, #24]
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80045ac:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80045b0:	6899      	ldr	r1, [r3, #8]
 80045b2:	f640 1050 	movw	r0, #2384	; 0x950
 80045b6:	f644 5231 	movw	r2, #19761	; 0x4d31
 80045ba:	f247 6340 	movw	r3, #30272	; 0x7640
 80045be:	3901      	subs	r1, #1
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80045c0:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80045c4:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80045c6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80045ca:	f6c0 0300 	movt	r3, #2048	; 0x800
 80045ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80045d2:	6034      	str	r4, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80045d4:	f001 f99c 	bl	8005910 <chThdCreateStatic.constprop.52>
 80045d8:	f640 73d4 	movw	r3, #4052	; 0xfd4
 80045dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80045e0:	6018      	str	r0, [r3, #0]
 80045e2:	2320      	movs	r3, #32
 80045e4:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80045e8:	f241 24c0 	movw	r4, #4800	; 0x12c0
 80045ec:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80045f0:	69a2      	ldr	r2, [r4, #24]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80045f2:	f640 73e8 	movw	r3, #4072	; 0xfe8
 80045f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  tp->u.wttrp = trp;
 80045fa:	6253      	str	r3, [r2, #36]	; 0x24
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80045fc:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80045fe:	601a      	str	r2, [r3, #0]
 8004600:	f7fc fbe6 	bl	8000dd0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8004604:	69a3      	ldr	r3, [r4, #24]
 8004606:	2200      	movs	r2, #0
 8004608:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 800460a:	f382 8811 	msr	BASEPRI, r2
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 800460e:	f640 75e8 	movw	r5, #4072	; 0xfe8
 8004612:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004616:	6828      	ldr	r0, [r5, #0]
 8004618:	f647 11bc 	movw	r1, #31164	; 0x79bc
 800461c:	f1d0 0001 	rsbs	r0, r0, #1
 8004620:	bf38      	it	cc
 8004622:	2000      	movcc	r0, #0
 8004624:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004628:	f7fc f86a 	bl	8000700 <_test_assert>
 800462c:	b100      	cbz	r0, 8004630 <test_004_001_execute.9052+0x90>
 800462e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
 8004630:	f1d7 0001 	rsbs	r0, r7, #1
 8004634:	f247 01f0 	movw	r1, #28912	; 0x70f0
 8004638:	bf38      	it	cc
 800463a:	2000      	movcc	r0, #0
 800463c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004640:	f7fc f85e 	bl	8000700 <_test_assert>
 8004644:	2800      	cmp	r0, #0
 8004646:	d1f2      	bne.n	800462e <test_004_001_execute.9052+0x8e>
    test_wait_threads();
 8004648:	f001 fada 	bl	8005c00 <test_wait_threads>
  }

  /* [4.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 800464c:	2302      	movs	r3, #2
 800464e:	6033      	str	r3, [r6, #0]
 8004650:	2320      	movs	r3, #32
 8004652:	f383 8811 	msr	BASEPRI, r3
 8004656:	69a3      	ldr	r3, [r4, #24]
 8004658:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800465c:	6a54      	ldr	r4, [r2, #36]	; 0x24
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800465e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 8004662:	625d      	str	r5, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004664:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8004666:	602b      	str	r3, [r5, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004668:	f000 fbd2 	bl	8004e10 <chSchGoSleepTimeoutS>
 800466c:	b2a4      	uxth	r4, r4
 800466e:	4606      	mov	r6, r0
 8004670:	2300      	movs	r3, #0
 8004672:	f383 8811 	msr	BASEPRI, r3
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
 8004676:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 800467a:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 800467e:	b280      	uxth	r0, r0
 8004680:	b289      	uxth	r1, r1
 8004682:	f7fe fc2d 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8004686:	2800      	cmp	r0, #0
 8004688:	d1d1      	bne.n	800462e <test_004_001_execute.9052+0x8e>
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 800468a:	6828      	ldr	r0, [r5, #0]
 800468c:	f647 11bc 	movw	r1, #31164	; 0x79bc
 8004690:	f1d0 0001 	rsbs	r0, r0, #1
 8004694:	bf38      	it	cc
 8004696:	2000      	movcc	r0, #0
 8004698:	f6c0 0100 	movt	r1, #2048	; 0x800
 800469c:	f7fc f830 	bl	8000700 <_test_assert>
 80046a0:	2800      	cmp	r0, #0
 80046a2:	d1c4      	bne.n	800462e <test_004_001_execute.9052+0x8e>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 80046a4:	f1b6 33ff 	subs.w	r3, r6, #4294967295	; 0xffffffff
 80046a8:	4258      	negs	r0, r3
 80046aa:	f247 01f0 	movw	r1, #28912	; 0x70f0
 80046ae:	4158      	adcs	r0, r3
 80046b0:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 80046b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 80046b8:	f7fc b822 	b.w	8000700 <_test_assert>
 80046bc:	f3af 8000 	nop.w

080046c0 <evt_thread7.9841.4211>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(evt_thread7, p) {
 80046c0:	b508      	push	{r3, lr}
 80046c2:	2320      	movs	r3, #32
 80046c4:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80046c8:	f640 0060 	movw	r0, #2144	; 0x860
 80046cc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80046d0:	2100      	movs	r1, #0
 80046d2:	f7fc fc7d 	bl	8000fd0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80046d6:	f7fc fa83 	bl	8000be0 <chSchRescheduleS>
 80046da:	2300      	movs	r3, #0
 80046dc:	f383 8811 	msr	BASEPRI, r3

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 80046e0:	2032      	movs	r0, #50	; 0x32
 80046e2:	f000 fbc5 	bl	8004e70 <chThdSleep>
 80046e6:	2320      	movs	r3, #32
 80046e8:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 80046ec:	f640 0034 	movw	r0, #2100	; 0x834
 80046f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80046f4:	2100      	movs	r1, #0
 80046f6:	f7fc fc6b 	bl	8000fd0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80046fa:	f7fc fa71 	bl	8000be0 <chSchRescheduleS>
 80046fe:	2300      	movs	r3, #0
 8004700:	f383 8811 	msr	BASEPRI, r3
 8004704:	bd08      	pop	{r3, pc}
 8004706:	bf00      	nop
 8004708:	f3af 8000 	nop.w
 800470c:	f3af 8000 	nop.w

08004710 <test_008_007_execute.9859>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_008_007_execute(void) {
 8004710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8004714:	f241 3330 	movw	r3, #4912	; 0x1330
 8004718:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800471c:	2201      	movs	r2, #1
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_008_007_execute(void) {
 800471e:	b08a      	sub	sp, #40	; 0x28
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8004720:	601a      	str	r2, [r3, #0]
 8004722:	2320      	movs	r3, #32
 8004724:	f383 8811 	msr	BASEPRI, r3
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004728:	f640 0460 	movw	r4, #2144	; 0x860
 800472c:	f2c2 0400 	movt	r4, #8192	; 0x2000
  esp->next     = elp;
  elp->listener = currp;
 8004730:	f241 23c0 	movw	r3, #4800	; 0x12c0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004734:	6821      	ldr	r1, [r4, #0]
  esp->next     = elp;
  elp->listener = currp;
 8004736:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800473a:	699a      	ldr	r2, [r3, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800473c:	af0a      	add	r7, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 800473e:	2501      	movs	r5, #1
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8004740:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004744:	f847 1d28 	str.w	r1, [r7, #-40]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8004748:	2300      	movs	r3, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 800474a:	9201      	str	r2, [sp, #4]
  elp->events   = events;
 800474c:	9502      	str	r5, [sp, #8]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 800474e:	9004      	str	r0, [sp, #16]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8004750:	6027      	str	r7, [r4, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8004752:	9303      	str	r3, [sp, #12]
 8004754:	f383 8811 	msr	BASEPRI, r3
 8004758:	2320      	movs	r3, #32
 800475a:	f383 8811 	msr	BASEPRI, r3
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800475e:	f640 0334 	movw	r3, #2100	; 0x834
  esp->next     = elp;
  elp->listener = currp;
 8004762:	f241 22c0 	movw	r2, #4800	; 0x12c0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004766:	f2c2 0300 	movt	r3, #8192	; 0x2000
  esp->next     = elp;
  elp->listener = currp;
 800476a:	f2c2 0200 	movt	r2, #8192	; 0x2000
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800476e:	6818      	ldr	r0, [r3, #0]
  esp->next     = elp;
  elp->listener = currp;
 8004770:	6992      	ldr	r2, [r2, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004772:	ae0a      	add	r6, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
 8004774:	9206      	str	r2, [sp, #24]
  elp->events   = events;
 8004776:	2104      	movs	r1, #4
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8004778:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800477c:	f846 0d14 	str.w	r0, [r6, #-20]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8004780:	2200      	movs	r2, #0

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8004782:	9107      	str	r1, [sp, #28]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8004784:	9509      	str	r5, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8004786:	601e      	str	r6, [r3, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8004788:	9208      	str	r2, [sp, #32]
 800478a:	f382 8811 	msr	BASEPRI, r2
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 800478e:	f241 3530 	movw	r5, #4912	; 0x1330
 8004792:	2302      	movs	r3, #2
 8004794:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004798:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 800479a:	f000 fbe9 	bl	8004f70 <test_wait_tick>
 800479e:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80047a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80047a6:	699b      	ldr	r3, [r3, #24]
 80047a8:	4680      	mov	r8, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80047aa:	6899      	ldr	r1, [r3, #8]
 80047ac:	f640 1050 	movw	r0, #2384	; 0x950
 80047b0:	f244 62c1 	movw	r2, #18113	; 0x46c1
 80047b4:	f247 6340 	movw	r3, #30272	; 0x7640
 80047b8:	3901      	subs	r1, #1
 80047ba:	f6c0 0200 	movt	r2, #2048	; 0x800
 80047be:	f6c0 0300 	movt	r3, #2048	; 0x800
 80047c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80047c6:	f001 f8a3 	bl	8005910 <chThdCreateStatic.constprop.52>
 80047ca:	f640 73d4 	movw	r3, #4052	; 0xfd4
 80047ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 80047d2:	2203      	movs	r2, #3
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80047d4:	6018      	str	r0, [r3, #0]
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 80047d6:	602a      	str	r2, [r5, #0]
  {
    m = chEvtWaitAll(5);
 80047d8:	f7fe fb02 	bl	8002de0 <chEvtWaitAll.constprop.29>
  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
 80047dc:	f108 0032 	add.w	r0, r8, #50	; 0x32
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80047e0:	f108 0134 	add.w	r1, r8, #52	; 0x34
 80047e4:	b280      	uxth	r0, r0
 80047e6:	b289      	uxth	r1, r1
 80047e8:	f7fe fb7a 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 80047ec:	b110      	cbz	r0, 80047f4 <test_008_007_execute.9859+0xe4>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 80047ee:	b00a      	add	sp, #40	; 0x28
 80047f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80047f4:	f7fe fa74 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 80047f8:	f647 01f0 	movw	r1, #30960	; 0x78f0
 80047fc:	f1d0 0001 	rsbs	r0, r0, #1
 8004800:	bf38      	it	cc
 8004802:	2000      	movcc	r0, #0
 8004804:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004808:	f7fb ff7a 	bl	8000700 <_test_assert>
 800480c:	2800      	cmp	r0, #0
 800480e:	d1ee      	bne.n	80047ee <test_008_007_execute.9859+0xde>
    test_wait_threads();
 8004810:	f001 f9f6 	bl	8005c00 <test_wait_threads>

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
 8004814:	f640 0834 	movw	r8, #2100	; 0x834
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el1);
 8004818:	f640 0060 	movw	r0, #2144	; 0x860
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 800481c:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el1);
 800481e:	4669      	mov	r1, sp
 8004820:	f2c2 0000 	movt	r0, #8192	; 0x2000
    chEvtUnregister(&es2, &el2);
 8004824:	f2c2 0800 	movt	r8, #8192	; 0x2000
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 8004828:	602b      	str	r3, [r5, #0]
  {
    chEvtUnregister(&es1, &el1);
 800482a:	f7fc f979 	bl	8000b20 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 800482e:	4631      	mov	r1, r6
 8004830:	4640      	mov	r0, r8
 8004832:	f7fc f975 	bl	8000b20 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 8004836:	6820      	ldr	r0, [r4, #0]
 8004838:	f247 7180 	movw	r1, #30592	; 0x7780
 800483c:	1b04      	subs	r4, r0, r4
 800483e:	4260      	negs	r0, r4
 8004840:	4160      	adcs	r0, r4
 8004842:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004846:	f7fb ff5b 	bl	8000700 <_test_assert>
 800484a:	2800      	cmp	r0, #0
 800484c:	d1cf      	bne.n	80047ee <test_008_007_execute.9859+0xde>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 800484e:	f8d8 0000 	ldr.w	r0, [r8]
 8004852:	f247 7180 	movw	r1, #30592	; 0x7780
 8004856:	ebb0 0208 	subs.w	r2, r0, r8
 800485a:	4250      	negs	r0, r2
 800485c:	4150      	adcs	r0, r2
 800485e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004862:	f7fb ff4d 	bl	8000700 <_test_assert>
 8004866:	e7c2      	b.n	80047ee <test_008_007_execute.9859+0xde>
 8004868:	f3af 8000 	nop.w
 800486c:	f3af 8000 	nop.w

08004870 <test_009_001_execute.10107>:

static void test_009_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_001_execute(void) {
 8004870:	b570      	push	{r4, r5, r6, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [9.1.1] Testing the mailbox size.*/
  test_set_step(1);
 8004872:	f241 3530 	movw	r5, #4912	; 0x1330
 8004876:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800487a:	2301      	movs	r3, #1

static void test_009_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_001_execute(void) {
 800487c:	b082      	sub	sp, #8
  msg_t msg1, msg2;
  unsigned i;

  /* [9.1.1] Testing the mailbox size.*/
  test_set_step(1);
 800487e:	602b      	str	r3, [r5, #0]
 8004880:	2320      	movs	r3, #32
 8004882:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 8004886:	f640 0438 	movw	r4, #2104	; 0x838
 800488a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 800488e:	6861      	ldr	r1, [r4, #4]
 8004890:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004892:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8004894:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004896:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800489a:	1f03      	subs	r3, r0, #4
 800489c:	4258      	negs	r0, r3
 800489e:	f647 11c8 	movw	r1, #31176	; 0x79c8
 80048a2:	4158      	adcs	r0, r3
 80048a4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80048a8:	f7fb ff2a 	bl	8000700 <_test_assert>
 80048ac:	b120      	cbz	r0, 80048b8 <test_009_001_execute.10107+0x48>
 80048ae:	2300      	movs	r3, #0
 80048b0:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80048b4:	b002      	add	sp, #8
 80048b6:	bd70      	pop	{r4, r5, r6, pc}
 80048b8:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [9.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 80048bc:	2302      	movs	r3, #2
 80048be:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 80048c0:	f7ff fa46 	bl	8003d50 <chMBReset.constprop.21>
 80048c4:	2320      	movs	r3, #32
 80048c6:	f383 8811 	msr	BASEPRI, r3
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 80048ca:	6861      	ldr	r1, [r4, #4]
 80048cc:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80048ce:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 80048d0:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80048d2:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80048d6:	f1b0 0c04 	subs.w	ip, r0, #4
 80048da:	f1dc 0000 	rsbs	r0, ip, #0
 80048de:	f247 7138 	movw	r1, #30520	; 0x7738
 80048e2:	eb50 000c 	adcs.w	r0, r0, ip
 80048e6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80048ea:	f7fb ff09 	bl	8000700 <_test_assert>
 80048ee:	2800      	cmp	r0, #0
 80048f0:	d1dd      	bne.n	80048ae <test_009_001_execute.10107+0x3e>
 80048f2:	f380 8811 	msr	BASEPRI, r0
 80048f6:	2320      	movs	r3, #32
 80048f8:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80048fc:	6920      	ldr	r0, [r4, #16]
 80048fe:	f647 11d4 	movw	r1, #31188	; 0x79d4
 8004902:	f1d0 0001 	rsbs	r0, r0, #1
 8004906:	bf38      	it	cc
 8004908:	2000      	movcc	r0, #0
 800490a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800490e:	f7fb fef7 	bl	8000700 <_test_assert>
 8004912:	2800      	cmp	r0, #0
 8004914:	d1cb      	bne.n	80048ae <test_009_001_execute.10107+0x3e>
 8004916:	f380 8811 	msr	BASEPRI, r0
 800491a:	2320      	movs	r3, #32
 800491c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8004920:	6820      	ldr	r0, [r4, #0]
 8004922:	68a3      	ldr	r3, [r4, #8]
 8004924:	f647 11e0 	movw	r1, #31200	; 0x79e0
 8004928:	ebb0 0e03 	subs.w	lr, r0, r3
 800492c:	f1de 0000 	rsbs	r0, lr, #0
 8004930:	eb50 000e 	adcs.w	r0, r0, lr
 8004934:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004938:	f7fb fee2 	bl	8000700 <_test_assert>
 800493c:	2800      	cmp	r0, #0
 800493e:	d1b6      	bne.n	80048ae <test_009_001_execute.10107+0x3e>
 8004940:	f380 8811 	msr	BASEPRI, r0
 8004944:	2320      	movs	r3, #32
 8004946:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800494a:	6820      	ldr	r0, [r4, #0]
 800494c:	68e3      	ldr	r3, [r4, #12]
 800494e:	f647 2104 	movw	r1, #31236	; 0x7a04
 8004952:	1ac6      	subs	r6, r0, r3
 8004954:	4270      	negs	r0, r6
 8004956:	4170      	adcs	r0, r6
 8004958:	f6c0 0100 	movt	r1, #2048	; 0x800
 800495c:	f7fb fed0 	bl	8000700 <_test_assert>
 8004960:	2800      	cmp	r0, #0
 8004962:	d1a4      	bne.n	80048ae <test_009_001_execute.10107+0x3e>
 8004964:	f380 8811 	msr	BASEPRI, r0
  }

  /* [9.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 8004968:	2303      	movs	r3, #3
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
 800496a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800496e:	2000      	movs	r0, #0
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }

  /* [9.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 8004970:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
 8004972:	f000 fd4d 	bl	8005410 <chMBPost.constprop.20>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8004976:	f647 2128 	movw	r1, #31272	; 0x7a28
 800497a:	1c82      	adds	r2, r0, #2
 800497c:	bf14      	ite	ne
 800497e:	2000      	movne	r0, #0
 8004980:	2001      	moveq	r0, #1
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }

  /* [9.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 8004982:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
    test_assert(msg1 == MSG_RESET, "not in reset state");
 8004986:	f6c0 0100 	movt	r1, #2048	; 0x800
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }

  /* [9.1.3] Testing the behavior of API when the mailbox is in reset
     state then return in active state.*/
  test_set_step(3);
 800498a:	f2c2 0600 	movt	r6, #8192	; 0x2000
  {
    msg1 = chMBPost(&mb1, (msg_t)0, TIME_INFINITE);
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800498e:	f7fb feb7 	bl	8000700 <_test_assert>
 8004992:	2800      	cmp	r0, #0
 8004994:	d18e      	bne.n	80048b4 <test_009_001_execute.10107+0x44>
    msg1 = chMBPostAhead(&mb1, (msg_t)0, TIME_INFINITE);
 8004996:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800499a:	f000 fd81 	bl	80054a0 <chMBPostAhead.constprop.18>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800499e:	f647 2128 	movw	r1, #31272	; 0x7a28
 80049a2:	1c83      	adds	r3, r0, #2
 80049a4:	bf14      	ite	ne
 80049a6:	2000      	movne	r0, #0
 80049a8:	2001      	moveq	r0, #1
 80049aa:	f6c0 0100 	movt	r1, #2048	; 0x800
 80049ae:	f7fb fea7 	bl	8000700 <_test_assert>
 80049b2:	2800      	cmp	r0, #0
 80049b4:	f47f af7e 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80049b8:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80049bc:	a801      	add	r0, sp, #4
 80049be:	f000 fdb7 	bl	8005530 <chMBFetch.constprop.16>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 80049c2:	f647 2128 	movw	r1, #31272	; 0x7a28
 80049c6:	1c82      	adds	r2, r0, #2
 80049c8:	bf14      	ite	ne
 80049ca:	2000      	movne	r0, #0
 80049cc:	2001      	moveq	r0, #1
 80049ce:	f6c0 0100 	movt	r1, #2048	; 0x800
 80049d2:	f7fb fe95 	bl	8000700 <_test_assert>
 80049d6:	2800      	cmp	r0, #0
 80049d8:	f47f af6c 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
    chMBResumeX(&mb1);
  }

  /* [9.1.4] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(4);
 80049dc:	2304      	movs	r3, #4
 80049de:	6033      	str	r3, [r6, #0]
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 80049e0:	7520      	strb	r0, [r4, #20]
 80049e2:	2642      	movs	r6, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80049e4:	4630      	mov	r0, r6
 80049e6:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80049ea:	f000 fd11 	bl	8005410 <chMBPost.constprop.20>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80049ee:	f647 1110 	movw	r1, #30992	; 0x7910
 80049f2:	f1d0 0001 	rsbs	r0, r0, #1
 80049f6:	bf38      	it	cc
 80049f8:	2000      	movcc	r0, #0
 80049fa:	f6c0 0100 	movt	r1, #2048	; 0x800
 80049fe:	3601      	adds	r6, #1
 8004a00:	f7fb fe7e 	bl	8000700 <_test_assert>
 8004a04:	2800      	cmp	r0, #0
 8004a06:	f47f af55 	bne.w	80048b4 <test_009_001_execute.10107+0x44>

  /* [9.1.4] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(4);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8004a0a:	2e45      	cmp	r6, #69	; 0x45
 8004a0c:	d1ea      	bne.n	80049e4 <test_009_001_execute.10107+0x174>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 8004a0e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004a12:	2041      	movs	r0, #65	; 0x41
 8004a14:	f000 fd44 	bl	80054a0 <chMBPostAhead.constprop.18>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004a18:	f647 1110 	movw	r1, #30992	; 0x7910
 8004a1c:	f1d0 0001 	rsbs	r0, r0, #1
 8004a20:	bf38      	it	cc
 8004a22:	2000      	movcc	r0, #0
 8004a24:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004a28:	f7fb fe6a 	bl	8000700 <_test_assert>
 8004a2c:	2800      	cmp	r0, #0
 8004a2e:	f47f af41 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
  }

  /* [9.1.5] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(5);
 8004a32:	2305      	movs	r3, #5
 8004a34:	602b      	str	r3, [r5, #0]
 8004a36:	2320      	movs	r3, #32
 8004a38:	f383 8811 	msr	BASEPRI, r3
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8004a3c:	6861      	ldr	r1, [r4, #4]
 8004a3e:	6822      	ldr	r2, [r4, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8004a40:	6923      	ldr	r3, [r4, #16]
 8004a42:	1a8a      	subs	r2, r1, r2
 8004a44:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8004a48:	f647 213c 	movw	r1, #31292	; 0x7a3c
 8004a4c:	bf14      	ite	ne
 8004a4e:	2000      	movne	r0, #0
 8004a50:	2001      	moveq	r0, #1
 8004a52:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004a56:	f7fb fe53 	bl	8000700 <_test_assert>
 8004a5a:	2800      	cmp	r0, #0
 8004a5c:	f47f af27 	bne.w	80048ae <test_009_001_execute.10107+0x3e>
 8004a60:	f380 8811 	msr	BASEPRI, r0
 8004a64:	2320      	movs	r3, #32
 8004a66:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8004a6a:	6920      	ldr	r0, [r4, #16]
 8004a6c:	f647 2148 	movw	r1, #31304	; 0x7a48
 8004a70:	1f03      	subs	r3, r0, #4
 8004a72:	4258      	negs	r0, r3
 8004a74:	4158      	adcs	r0, r3
 8004a76:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004a7a:	f7fb fe41 	bl	8000700 <_test_assert>
 8004a7e:	2800      	cmp	r0, #0
 8004a80:	f47f af15 	bne.w	80048ae <test_009_001_execute.10107+0x3e>
 8004a84:	f380 8811 	msr	BASEPRI, r0
 8004a88:	2320      	movs	r3, #32
 8004a8a:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8004a8e:	68e0      	ldr	r0, [r4, #12]
 8004a90:	68a3      	ldr	r3, [r4, #8]
 8004a92:	f647 2154 	movw	r1, #31316	; 0x7a54
 8004a96:	ebb0 0c03 	subs.w	ip, r0, r3
 8004a9a:	f1dc 0000 	rsbs	r0, ip, #0
 8004a9e:	eb50 000c 	adcs.w	r0, r0, ip
 8004aa2:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004aa6:	f7fb fe2b 	bl	8000700 <_test_assert>
 8004aaa:	2800      	cmp	r0, #0
 8004aac:	f47f aeff 	bne.w	80048ae <test_009_001_execute.10107+0x3e>
 8004ab0:	f380 8811 	msr	BASEPRI, r0
  }

  /* [9.1.6] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(6);
 8004ab4:	2306      	movs	r3, #6
 8004ab6:	602b      	str	r3, [r5, #0]
 8004ab8:	2604      	movs	r6, #4
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8004aba:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004abe:	a801      	add	r0, sp, #4
 8004ac0:	f000 fd36 	bl	8005530 <chMBFetch.constprop.16>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004ac4:	f647 1110 	movw	r1, #30992	; 0x7910
 8004ac8:	f1d0 0001 	rsbs	r0, r0, #1
 8004acc:	bf38      	it	cc
 8004ace:	2000      	movcc	r0, #0
 8004ad0:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004ad4:	f7fb fe14 	bl	8000700 <_test_assert>
 8004ad8:	2800      	cmp	r0, #0
 8004ada:	f47f aeeb 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
      test_emit_token(msg2);
 8004ade:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8004ae2:	f7fb fd65 	bl	80005b0 <test_emit_token>

  /* [9.1.6] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(6);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8004ae6:	3e01      	subs	r6, #1
 8004ae8:	d1e7      	bne.n	8004aba <test_009_001_execute.10107+0x24a>
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8004aea:	f647 0054 	movw	r0, #30804	; 0x7854
 8004aee:	f647 216c 	movw	r1, #31340	; 0x7a6c
 8004af2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004af6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004afa:	f7fb fdd1 	bl	80006a0 <_test_assert_sequence>
 8004afe:	2800      	cmp	r0, #0
 8004b00:	f47f aed8 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
  }

  /* [9.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 8004b04:	2307      	movs	r3, #7
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8004b06:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004b0a:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 8004b0c:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8004b0e:	f000 fc7f 	bl	8005410 <chMBPost.constprop.20>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004b12:	f647 1110 	movw	r1, #30992	; 0x7910
 8004b16:	f1d0 0001 	rsbs	r0, r0, #1
 8004b1a:	bf38      	it	cc
 8004b1c:	2000      	movcc	r0, #0
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 8004b1e:	f241 3530 	movw	r5, #4912	; 0x1330
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004b22:	f6c0 0100 	movt	r1, #2048	; 0x800
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.1.7] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(7);
 8004b26:	f2c2 0500 	movt	r5, #8192	; 0x2000
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004b2a:	f7fb fde9 	bl	8000700 <_test_assert>
 8004b2e:	2800      	cmp	r0, #0
 8004b30:	f47f aec0 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8004b34:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004b38:	a801      	add	r0, sp, #4
 8004b3a:	f000 fcf9 	bl	8005530 <chMBFetch.constprop.16>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8004b3e:	f647 1110 	movw	r1, #30992	; 0x7910
 8004b42:	f1d0 0001 	rsbs	r0, r0, #1
 8004b46:	bf38      	it	cc
 8004b48:	2000      	movcc	r0, #0
 8004b4a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b4e:	f7fb fdd7 	bl	8000700 <_test_assert>
 8004b52:	2800      	cmp	r0, #0
 8004b54:	f47f aeae 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
  }

  /* [9.1.8] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(8);
 8004b58:	2308      	movs	r3, #8
 8004b5a:	602b      	str	r3, [r5, #0]
 8004b5c:	2320      	movs	r3, #32
 8004b5e:	f383 8811 	msr	BASEPRI, r3
 8004b62:	6861      	ldr	r1, [r4, #4]
 8004b64:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b66:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8004b68:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8004b6a:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004b6e:	f1b0 0e04 	subs.w	lr, r0, #4
 8004b72:	f1de 0000 	rsbs	r0, lr, #0
 8004b76:	f247 7138 	movw	r1, #30520	; 0x7738
 8004b7a:	eb50 000e 	adcs.w	r0, r0, lr
 8004b7e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004b82:	f7fb fdbd 	bl	8000700 <_test_assert>
 8004b86:	2800      	cmp	r0, #0
 8004b88:	f47f ae91 	bne.w	80048ae <test_009_001_execute.10107+0x3e>
 8004b8c:	f380 8811 	msr	BASEPRI, r0
 8004b90:	2320      	movs	r3, #32
 8004b92:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8004b96:	6920      	ldr	r0, [r4, #16]
 8004b98:	f647 11d4 	movw	r1, #31188	; 0x79d4
 8004b9c:	f1d0 0001 	rsbs	r0, r0, #1
 8004ba0:	bf38      	it	cc
 8004ba2:	2000      	movcc	r0, #0
 8004ba4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004ba8:	f7fb fdaa 	bl	8000700 <_test_assert>
 8004bac:	2800      	cmp	r0, #0
 8004bae:	f47f ae7e 	bne.w	80048ae <test_009_001_execute.10107+0x3e>
 8004bb2:	f380 8811 	msr	BASEPRI, r0
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8004bb6:	6820      	ldr	r0, [r4, #0]
 8004bb8:	68a3      	ldr	r3, [r4, #8]
 8004bba:	f647 11e0 	movw	r1, #31200	; 0x79e0
 8004bbe:	1ac6      	subs	r6, r0, r3
 8004bc0:	4270      	negs	r0, r6
 8004bc2:	4170      	adcs	r0, r6
 8004bc4:	f640 0438 	movw	r4, #2104	; 0x838
 8004bc8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004bcc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8004bd0:	f7fb fd96 	bl	8000700 <_test_assert>
 8004bd4:	2800      	cmp	r0, #0
 8004bd6:	f47f ae6d 	bne.w	80048b4 <test_009_001_execute.10107+0x44>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8004bda:	6820      	ldr	r0, [r4, #0]
 8004bdc:	68e3      	ldr	r3, [r4, #12]
 8004bde:	f647 2104 	movw	r1, #31236	; 0x7a04
 8004be2:	1ac5      	subs	r5, r0, r3
 8004be4:	4268      	negs	r0, r5
 8004be6:	4168      	adcs	r0, r5
 8004be8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004bec:	f7fb fd88 	bl	8000700 <_test_assert>
 8004bf0:	e660      	b.n	80048b4 <test_009_001_execute.10107+0x44>
 8004bf2:	bf00      	nop
 8004bf4:	f3af 8000 	nop.w
 8004bf8:	f3af 8000 	nop.w
 8004bfc:	f3af 8000 	nop.w

08004c00 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8004c00:	4770      	bx	lr
 8004c02:	bf00      	nop
 8004c04:	f3af 8000 	nop.w
 8004c08:	f3af 8000 	nop.w
 8004c0c:	f3af 8000 	nop.w

08004c10 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8004c10:	4770      	bx	lr
 8004c12:	bf00      	nop
 8004c14:	f3af 8000 	nop.w
 8004c18:	f3af 8000 	nop.w
 8004c1c:	f3af 8000 	nop.w

08004c20 <test_010_001_setup.10257>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004c20:	f640 0310 	movw	r3, #2064	; 0x810
 8004c24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c28:	2200      	movs	r2, #0
  mp->object_size = size;
 8004c2a:	2104      	movs	r1, #4
 8004c2c:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004c2e:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 8004c30:	609a      	str	r2, [r3, #8]
 8004c32:	4770      	bx	lr
 8004c34:	f3af 8000 	nop.w
 8004c38:	f3af 8000 	nop.w
 8004c3c:	f3af 8000 	nop.w

08004c40 <test_003_004_execute.8787>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void test_003_004_execute(void) {
 8004c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004c44:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8004c48:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8004c4c:	69a3      	ldr	r3, [r4, #24]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8004c4e:	f241 3630 	movw	r6, #4912	; 0x1330
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004c52:	689d      	ldr	r5, [r3, #8]
 8004c54:	f2c2 0600 	movt	r6, #8192	; 0x2000

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8004c58:	1caf      	adds	r7, r5, #2

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8004c5a:	f105 0801 	add.w	r8, r5, #1

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8004c5e:	609f      	str	r7, [r3, #8]

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8004c60:	4640      	mov	r0, r8
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8004c62:	2302      	movs	r3, #2
 8004c64:	6033      	str	r3, [r6, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 8004c66:	f7fb ffe3 	bl	8000c30 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8004c6a:	1b42      	subs	r2, r0, r5
 8004c6c:	4250      	negs	r0, r2
 8004c6e:	f247 019c 	movw	r1, #28828	; 0x709c
 8004c72:	4150      	adcs	r0, r2
 8004c74:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004c78:	f7fb fd42 	bl	8000700 <_test_assert>
 8004c7c:	b108      	cbz	r0, 8004c82 <test_003_004_execute.8787+0x42>
 8004c7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8004c82:	69a3      	ldr	r3, [r4, #24]
 8004c84:	f247 01c0 	movw	r1, #28864	; 0x70c0
 8004c88:	6898      	ldr	r0, [r3, #8]
 8004c8a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004c8e:	1a3b      	subs	r3, r7, r0
 8004c90:	4258      	negs	r0, r3
 8004c92:	4158      	adcs	r0, r3
 8004c94:	f7fb fd34 	bl	8000700 <_test_assert>
 8004c98:	2800      	cmp	r0, #0
 8004c9a:	d1f0      	bne.n	8004c7e <test_003_004_execute.8787+0x3e>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8004c9c:	69a3      	ldr	r3, [r4, #24]
 8004c9e:	f647 2180 	movw	r1, #31360	; 0x7a80
 8004ca2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8004ca4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004ca8:	ebb8 0c00 	subs.w	ip, r8, r0
 8004cac:	f1dc 0000 	rsbs	r0, ip, #0
 8004cb0:	eb50 000c 	adcs.w	r0, r0, ip
 8004cb4:	f7fb fd24 	bl	8000700 <_test_assert>
 8004cb8:	2800      	cmp	r0, #0
 8004cba:	d1e0      	bne.n	8004c7e <test_003_004_execute.8787+0x3e>
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
  {
    p1 = chThdSetPriority(prio + 3);
 8004cbc:	1cef      	adds	r7, r5, #3
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8004cbe:	2303      	movs	r3, #3
  {
    p1 = chThdSetPriority(prio + 3);
 8004cc0:	4638      	mov	r0, r7
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8004cc2:	6033      	str	r3, [r6, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 8004cc4:	f7fb ffb4 	bl	8000c30 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8004cc8:	ebb8 0e00 	subs.w	lr, r8, r0
 8004ccc:	f1de 0000 	rsbs	r0, lr, #0
 8004cd0:	f247 019c 	movw	r1, #28828	; 0x709c
 8004cd4:	eb50 000e 	adcs.w	r0, r0, lr
 8004cd8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004cdc:	f7fb fd10 	bl	8000700 <_test_assert>
 8004ce0:	2800      	cmp	r0, #0
 8004ce2:	d1cc      	bne.n	8004c7e <test_003_004_execute.8787+0x3e>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8004ce4:	69a3      	ldr	r3, [r4, #24]
 8004ce6:	f247 01c0 	movw	r1, #28864	; 0x70c0
 8004cea:	6898      	ldr	r0, [r3, #8]
 8004cec:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004cf0:	1a3a      	subs	r2, r7, r0
 8004cf2:	4250      	negs	r0, r2
 8004cf4:	4150      	adcs	r0, r2
 8004cf6:	f7fb fd03 	bl	8000700 <_test_assert>
 8004cfa:	2800      	cmp	r0, #0
 8004cfc:	d1bf      	bne.n	8004c7e <test_003_004_execute.8787+0x3e>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8004cfe:	69a3      	ldr	r3, [r4, #24]
 8004d00:	f647 21a8 	movw	r1, #31400	; 0x7aa8
 8004d04:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8004d06:	f6c0 0100 	movt	r1, #2048	; 0x800
 8004d0a:	1a3b      	subs	r3, r7, r0
 8004d0c:	4258      	negs	r0, r3
 8004d0e:	4158      	adcs	r0, r3
 8004d10:	f7fb fcf6 	bl	8000700 <_test_assert>
 8004d14:	2800      	cmp	r0, #0
 8004d16:	d1b2      	bne.n	8004c7e <test_003_004_execute.8787+0x3e>
  }

  /* [3.4.4] Restoring original conditions.*/
  test_set_step(4);
 8004d18:	2304      	movs	r3, #4
 8004d1a:	6033      	str	r3, [r6, #0]
 8004d1c:	2320      	movs	r3, #32
 8004d1e:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004d22:	69a3      	ldr	r3, [r4, #24]
 8004d24:	2200      	movs	r2, #0
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8004d26:	609d      	str	r5, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8004d28:	63dd      	str	r5, [r3, #60]	; 0x3c
 8004d2a:	f382 8811 	msr	BASEPRI, r2
 8004d2e:	e7a6      	b.n	8004c7e <test_003_004_execute.8787+0x3e>

08004d30 <thread1.9045>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8004d30:	b510      	push	{r4, lr}
 8004d32:	2320      	movs	r3, #32
 8004d34:	4604      	mov	r4, r0
 8004d36:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004d3a:	f640 73e8 	movw	r3, #4072	; 0xfe8
 8004d3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d42:	6818      	ldr	r0, [r3, #0]
 8004d44:	b120      	cbz	r0, 8004d50 <thread1.9045+0x20>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004d46:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 8004d48:	6241      	str	r1, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004d4a:	6019      	str	r1, [r3, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8004d4c:	f7fc f8d8 	bl	8000f00 <chSchReadyI>

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
 8004d50:	f7fb ff46 	bl	8000be0 <chSchRescheduleS>
 8004d54:	2300      	movs	r3, #0
 8004d56:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_emit_token(*(char *)p);
 8004d5a:	7820      	ldrb	r0, [r4, #0]
}
 8004d5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
  chSysUnlock();
  test_emit_token(*(char *)p);
 8004d60:	f7fb bc26 	b.w	80005b0 <test_emit_token>
 8004d64:	f3af 8000 	nop.w
 8004d68:	f3af 8000 	nop.w
 8004d6c:	f3af 8000 	nop.w

08004d70 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8004d70:	b4f0      	push	{r4, r5, r6, r7}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d72:	f241 25c0 	movw	r5, #4800	; 0x12c0
 8004d76:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8004d7a:	462e      	mov	r6, r5
 8004d7c:	f856 4f1c 	ldr.w	r4, [r6, #28]!
 8004d80:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8004d84:	f8d7 c024 	ldr.w	ip, [r7, #36]	; 0x24
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8004d88:	2901      	cmp	r1, #1
 8004d8a:	bf98      	it	ls
 8004d8c:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d8e:	42b4      	cmp	r4, r6

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8004d90:	60c2      	str	r2, [r0, #12]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8004d92:	6103      	str	r3, [r0, #16]
 8004d94:	fa1f f28c 	uxth.w	r2, ip
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8004d98:	d026      	beq.n	8004de8 <chVTDoSetI+0x78>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8004d9a:	8cee      	ldrh	r6, [r5, #38]	; 0x26
 8004d9c:	1b92      	subs	r2, r2, r6
 8004d9e:	188b      	adds	r3, r1, r2
 8004da0:	b29b      	uxth	r3, r3

    if (delta < now - ch.vtlist.lasttime) {
 8004da2:	4293      	cmp	r3, r2
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8004da4:	8922      	ldrh	r2, [r4, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;

    if (delta < now - ch.vtlist.lasttime) {
 8004da6:	db1a      	blt.n	8004dde <chVTDoSetI+0x6e>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8004da8:	4293      	cmp	r3, r2
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8004daa:	bf3e      	ittt	cc
 8004dac:	1999      	addcc	r1, r3, r6
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004dae:	b289      	uxthcc	r1, r1
 8004db0:	6379      	strcc	r1, [r7, #52]	; 0x34
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8004db2:	4293      	cmp	r3, r2
 8004db4:	d905      	bls.n	8004dc2 <chVTDoSetI+0x52>
    delta -= p->delta;
    p = p->next;
 8004db6:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8004db8:	1a9b      	subs	r3, r3, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8004dba:	8922      	ldrh	r2, [r4, #8]
    delta -= p->delta;
 8004dbc:	b29b      	uxth	r3, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8004dbe:	429a      	cmp	r2, r3
 8004dc0:	d3f9      	bcc.n	8004db6 <chVTDoSetI+0x46>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8004dc2:	6862      	ldr	r2, [r4, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8004dc4:	6004      	str	r4, [r0, #0]
  vtp->prev = vtp->next->prev;
 8004dc6:	6042      	str	r2, [r0, #4]
  vtp->prev->next = vtp;
 8004dc8:	6010      	str	r0, [r2, #0]
  p->prev = vtp;
 8004dca:	6060      	str	r0, [r4, #4]
  vtp->delta = delta
 8004dcc:	8103      	strh	r3, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8004dce:	8921      	ldrh	r1, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 8004dd0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8004dd4:	1acb      	subs	r3, r1, r3
 8004dd6:	8123      	strh	r3, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 8004dd8:	84aa      	strh	r2, [r5, #36]	; 0x24
}
 8004dda:	bcf0      	pop	{r4, r5, r6, r7}
 8004ddc:	4770      	bx	lr
    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 8004dde:	6824      	ldr	r4, [r4, #0]

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8004de0:	1a9b      	subs	r3, r3, r2
 8004de2:	b29b      	uxth	r3, r3
 8004de4:	8922      	ldrh	r2, [r4, #8]
 8004de6:	e7e4      	b.n	8004db2 <chVTDoSetI+0x42>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8004de8:	eb01 0c02 	add.w	ip, r1, r2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004dec:	fa1f fc8c 	uxth.w	ip, ip
  STM32_ST_TIM->SR     = 0;
 8004df0:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004df2:	2302      	movs	r3, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8004df4:	84ea      	strh	r2, [r5, #38]	; 0x26
      ch.vtlist.next = vtp;
 8004df6:	61e8      	str	r0, [r5, #28]
      ch.vtlist.prev = vtp;
 8004df8:	6228      	str	r0, [r5, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8004dfa:	6004      	str	r4, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8004dfc:	6044      	str	r4, [r0, #4]
      vtp->delta = delay;
 8004dfe:	8101      	strh	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004e00:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8004e04:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004e06:	60fb      	str	r3, [r7, #12]
 8004e08:	e7e7      	b.n	8004dda <chVTDoSetI+0x6a>
 8004e0a:	bf00      	nop
 8004e0c:	f3af 8000 	nop.w

08004e10 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8004e10:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8004e12:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004e16:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8004e18:	b087      	sub	sp, #28
 8004e1a:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8004e1c:	d017      	beq.n	8004e4e <chSchGoSleepTimeoutS+0x3e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8004e1e:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8004e22:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8004e26:	f240 32b1 	movw	r2, #945	; 0x3b1
 8004e2a:	69a3      	ldr	r3, [r4, #24]
 8004e2c:	a801      	add	r0, sp, #4
 8004e2e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8004e32:	f7ff ff9d 	bl	8004d70 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8004e36:	4628      	mov	r0, r5
 8004e38:	f7fb ffca 	bl	8000dd0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8004e3c:	9b04      	ldr	r3, [sp, #16]
 8004e3e:	b113      	cbz	r3, 8004e46 <chSchGoSleepTimeoutS+0x36>
      chVTDoResetI(&vt);
 8004e40:	a801      	add	r0, sp, #4
 8004e42:	f7fb fdd5 	bl	80009f0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8004e46:	69a3      	ldr	r3, [r4, #24]
}
 8004e48:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8004e4a:	b007      	add	sp, #28
 8004e4c:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004e4e:	f7fb ffbf 	bl	8000dd0 <chSchGoSleepS>
 8004e52:	f241 24c0 	movw	r4, #4800	; 0x12c0
 8004e56:	f2c2 0400 	movt	r4, #8192	; 0x2000
  }

  return currp->u.rdymsg;
 8004e5a:	69a3      	ldr	r3, [r4, #24]
}
 8004e5c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8004e5e:	b007      	add	sp, #28
 8004e60:	bd30      	pop	{r4, r5, pc}
 8004e62:	bf00      	nop
 8004e64:	f3af 8000 	nop.w
 8004e68:	f3af 8000 	nop.w
 8004e6c:	f3af 8000 	nop.w

08004e70 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8004e70:	b508      	push	{r3, lr}
 8004e72:	4601      	mov	r1, r0
 8004e74:	2320      	movs	r3, #32
 8004e76:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8004e7a:	2008      	movs	r0, #8
 8004e7c:	f7ff ffc8 	bl	8004e10 <chSchGoSleepTimeoutS>
 8004e80:	2300      	movs	r3, #0
 8004e82:	f383 8811 	msr	BASEPRI, r3
 8004e86:	bd08      	pop	{r3, pc}
 8004e88:	f3af 8000 	nop.w
 8004e8c:	f3af 8000 	nop.w

08004e90 <test_003_001_execute.8795>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void test_003_001_execute(void) {
 8004e90:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8004e92:	f241 3430 	movw	r4, #4912	; 0x1330
 8004e96:	2301      	movs	r3, #1
 8004e98:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8004e9c:	6023      	str	r3, [r4, #0]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004e9e:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8004ea2:	6a75      	ldr	r5, [r6, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 8004ea4:	2064      	movs	r0, #100	; 0x64
 8004ea6:	b2ad      	uxth	r5, r5
 8004ea8:	f7ff ffe2 	bl	8004e70 <chThdSleep>
    test_assert_time_window(time + 100,
 8004eac:	f105 0064 	add.w	r0, r5, #100	; 0x64
 8004eb0:	f105 0167 	add.w	r1, r5, #103	; 0x67
 8004eb4:	b280      	uxth	r0, r0
 8004eb6:	b289      	uxth	r1, r1
 8004eb8:	f7fe f812 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8004ebc:	b100      	cbz	r0, 8004ec0 <test_003_001_execute.8795+0x30>
 8004ebe:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [3.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8004ec0:	2302      	movs	r3, #2
 8004ec2:	6023      	str	r3, [r4, #0]
 8004ec4:	6a75      	ldr	r5, [r6, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 8004ec6:	2064      	movs	r0, #100	; 0x64
 8004ec8:	b2ad      	uxth	r5, r5
 8004eca:	f7ff ffd1 	bl	8004e70 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 8004ece:	f105 0064 	add.w	r0, r5, #100	; 0x64
 8004ed2:	f105 0167 	add.w	r1, r5, #103	; 0x67
 8004ed6:	b280      	uxth	r0, r0
 8004ed8:	b289      	uxth	r1, r1
 8004eda:	f7fe f801 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8004ede:	2800      	cmp	r0, #0
 8004ee0:	d1ed      	bne.n	8004ebe <test_003_001_execute.8795+0x2e>
  }

  /* [3.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8004ee2:	2303      	movs	r3, #3
 8004ee4:	6023      	str	r3, [r4, #0]
 8004ee6:	6a75      	ldr	r5, [r6, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 8004ee8:	2064      	movs	r0, #100	; 0x64
 8004eea:	b2ad      	uxth	r5, r5
 8004eec:	f7ff ffc0 	bl	8004e70 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 8004ef0:	f105 0064 	add.w	r0, r5, #100	; 0x64
 8004ef4:	f105 0167 	add.w	r1, r5, #103	; 0x67
 8004ef8:	b280      	uxth	r0, r0
 8004efa:	b289      	uxth	r1, r1
 8004efc:	f7fd fff0 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8004f00:	2800      	cmp	r0, #0
 8004f02:	d1dc      	bne.n	8004ebe <test_003_001_execute.8795+0x2e>
                            "out of time window");
  }

  /* [3.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 8004f04:	2304      	movs	r3, #4
 8004f06:	6023      	str	r3, [r4, #0]
 8004f08:	6a75      	ldr	r5, [r6, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 8004f0a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004f0e:	b2ad      	uxth	r5, r5
 8004f10:	f7ff ffae 	bl	8004e70 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 8004f14:	f505 707a 	add.w	r0, r5, #1000	; 0x3e8
 8004f18:	f205 31eb 	addw	r1, r5, #1003	; 0x3eb
 8004f1c:	b280      	uxth	r0, r0
 8004f1e:	b289      	uxth	r1, r1
 8004f20:	f7fd ffde 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8004f24:	2800      	cmp	r0, #0
 8004f26:	d1ca      	bne.n	8004ebe <test_003_001_execute.8795+0x2e>
                            "out of time window");
  }

  /* [3.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 8004f28:	2305      	movs	r3, #5
 8004f2a:	6023      	str	r3, [r4, #0]
 8004f2c:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8004f2e:	2320      	movs	r3, #32
 8004f30:	b2ad      	uxth	r5, r5
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
 8004f32:	f105 0464 	add.w	r4, r5, #100	; 0x64
 8004f36:	b2a4      	uxth	r4, r4
 8004f38:	f383 8811 	msr	BASEPRI, r3
 8004f3c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004f40:	6a59      	ldr	r1, [r3, #36]	; 0x24
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
 8004f42:	1a61      	subs	r1, r4, r1
 8004f44:	b289      	uxth	r1, r1
  if (time > (systime_t)0) {
 8004f46:	b111      	cbz	r1, 8004f4e <test_003_001_execute.8795+0xbe>
 8004f48:	2008      	movs	r0, #8
 8004f4a:	f7ff ff61 	bl	8004e10 <chSchGoSleepTimeoutS>
 8004f4e:	2300      	movs	r3, #0
 8004f50:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(time + 100,
 8004f54:	f105 0167 	add.w	r1, r5, #103	; 0x67
 8004f58:	4620      	mov	r0, r4
 8004f5a:	b289      	uxth	r1, r1
                            time + 100 + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
  }
}
 8004f5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     "now" + 100 ticks.*/
  test_set_step(5);
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
    test_assert_time_window(time + 100,
 8004f60:	f7fd bfbe 	b.w	8002ee0 <_test_assert_time_window.constprop.2>
 8004f64:	f3af 8000 	nop.w
 8004f68:	f3af 8000 	nop.w
 8004f6c:	f3af 8000 	nop.w

08004f70 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8004f70:	b508      	push	{r3, lr}

  chThdSleep(1);
 8004f72:	2001      	movs	r0, #1
 8004f74:	f7ff ff7c 	bl	8004e70 <chThdSleep>
 8004f78:	2320      	movs	r3, #32
 8004f7a:	f383 8811 	msr	BASEPRI, r3
 8004f7e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004f82:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8004f84:	2300      	movs	r3, #0
 8004f86:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8004f8a:	b280      	uxth	r0, r0
 8004f8c:	bd08      	pop	{r3, pc}
 8004f8e:	bf00      	nop

08004f90 <test_013_011_execute.10701>:

static void test_013_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void test_013_011_execute(void) {
 8004f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [13.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8004f92:	f241 3730 	movw	r7, #4912	; 0x1330
 8004f96:	2301      	movs	r3, #1
 8004f98:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8004f9c:	603b      	str	r3, [r7, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8004f9e:	f7ff ffe7 	bl	8004f70 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8004fa2:	2400      	movs	r4, #0
    start = test_wait_tick();
 8004fa4:	4606      	mov	r6, r0
 8004fa6:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chMtxLock(&mtx1);
 8004faa:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fb2:	f7fc f8ed 	bl	8001190 <chMtxLock>
      chMtxUnlock(&mtx1);
 8004fb6:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fbe:	f7fc f847 	bl	8001050 <chMtxUnlock>
      chMtxLock(&mtx1);
 8004fc2:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fca:	f7fc f8e1 	bl	8001190 <chMtxLock>
      chMtxUnlock(&mtx1);
 8004fce:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fd2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fd6:	f7fc f83b 	bl	8001050 <chMtxUnlock>
      chMtxLock(&mtx1);
 8004fda:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fde:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fe2:	f7fc f8d5 	bl	8001190 <chMtxLock>
      chMtxUnlock(&mtx1);
 8004fe6:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004fea:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fee:	f7fc f82f 	bl	8001050 <chMtxUnlock>
      chMtxLock(&mtx1);
 8004ff2:	f640 70ec 	movw	r0, #4076	; 0xfec
 8004ff6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ffa:	f7fc f8c9 	bl	8001190 <chMtxLock>
      chMtxUnlock(&mtx1);
 8004ffe:	f640 70ec 	movw	r0, #4076	; 0xfec
 8005002:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005006:	f7fc f823 	bl	8001050 <chMtxUnlock>
 800500a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
 800500c:	3401      	adds	r4, #1
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800500e:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8005010:	b29b      	uxth	r3, r3
 8005012:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005016:	d3c8      	bcc.n	8004faa <test_013_011_execute.10701+0x1a>
  }

  /* [13.11.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
 8005018:	f247 601c 	movw	r0, #30236	; 0x761c
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.11.2] The score is printed.*/
  test_set_step(2);
 800501c:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800501e:	f6c0 0000 	movt	r0, #2048	; 0x800
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.11.2] The score is printed.*/
  test_set_step(2);
 8005022:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8005024:	f7fb fb24 	bl	8000670 <test_print>
    test_printn(n * 4);
 8005028:	00a0      	lsls	r0, r4, #2
 800502a:	f7fb fbf9 	bl	8000820 <test_printn>
    test_println(" lock+unlock/S");
  }
}
 800502e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [13.11.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" lock+unlock/S");
 8005032:	f647 20c8 	movw	r0, #31432	; 0x7ac8
 8005036:	f6c0 0000 	movt	r0, #2048	; 0x800
 800503a:	f7fb baf9 	b.w	8000630 <test_println>
 800503e:	bf00      	nop

08005040 <test_013_010_execute.10705>:

static void test_013_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_013_010_execute(void) {
 8005040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [13.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8005042:	f241 3730 	movw	r7, #4912	; 0x1330
 8005046:	2301      	movs	r3, #1
 8005048:	f2c2 0700 	movt	r7, #8192	; 0x2000
 800504c:	603b      	str	r3, [r7, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800504e:	f7ff ff8f 	bl	8004f70 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8005052:	2400      	movs	r4, #0
    start = test_wait_tick();
 8005054:	4606      	mov	r6, r0
 8005056:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chSemWait(&sem1);
 800505a:	f640 1010 	movw	r0, #2320	; 0x910
 800505e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005062:	f7fb feed 	bl	8000e40 <chSemWait>
      chSemSignal(&sem1);
 8005066:	f640 1010 	movw	r0, #2320	; 0x910
 800506a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800506e:	f7fb fe8f 	bl	8000d90 <chSemSignal>
      chSemWait(&sem1);
 8005072:	f640 1010 	movw	r0, #2320	; 0x910
 8005076:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800507a:	f7fb fee1 	bl	8000e40 <chSemWait>
      chSemSignal(&sem1);
 800507e:	f640 1010 	movw	r0, #2320	; 0x910
 8005082:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005086:	f7fb fe83 	bl	8000d90 <chSemSignal>
      chSemWait(&sem1);
 800508a:	f640 1010 	movw	r0, #2320	; 0x910
 800508e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005092:	f7fb fed5 	bl	8000e40 <chSemWait>
      chSemSignal(&sem1);
 8005096:	f640 1010 	movw	r0, #2320	; 0x910
 800509a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800509e:	f7fb fe77 	bl	8000d90 <chSemSignal>
      chSemWait(&sem1);
 80050a2:	f640 1010 	movw	r0, #2320	; 0x910
 80050a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050aa:	f7fb fec9 	bl	8000e40 <chSemWait>
      chSemSignal(&sem1);
 80050ae:	f640 1010 	movw	r0, #2320	; 0x910
 80050b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050b6:	f7fb fe6b 	bl	8000d90 <chSemSignal>
 80050ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
 80050bc:	3401      	adds	r4, #1
 80050be:	1b9b      	subs	r3, r3, r6
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80050c0:	b29b      	uxth	r3, r3
 80050c2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80050c6:	d3c8      	bcc.n	800505a <test_013_010_execute.10705+0x1a>
  }

  /* [13.10.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
 80050c8:	f247 601c 	movw	r0, #30236	; 0x761c
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.10.2] The score is printed.*/
  test_set_step(2);
 80050cc:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80050ce:	f6c0 0000 	movt	r0, #2048	; 0x800
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [13.10.2] The score is printed.*/
  test_set_step(2);
 80050d2:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 80050d4:	f7fb facc 	bl	8000670 <test_print>
    test_printn(n * 4);
 80050d8:	00a0      	lsls	r0, r4, #2
 80050da:	f7fb fba1 	bl	8000820 <test_printn>
    test_println(" wait+signal/S");
  }
}
 80050de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [13.10.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" wait+signal/S");
 80050e2:	f647 20d8 	movw	r0, #31448	; 0x7ad8
 80050e6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80050ea:	f7fb baa1 	b.w	8000630 <test_println>
 80050ee:	bf00      	nop

080050f0 <msg_loop_test.10723>:
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 80050f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80050f2:	4605      	mov	r5, r0
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 80050f4:	f7ff ff3c 	bl	8004f70 <test_wait_tick>
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
 80050f8:	2400      	movs	r4, #0
  start = test_wait_tick();
 80050fa:	4607      	mov	r7, r0
 80050fc:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
 8005100:	4628      	mov	r0, r5
 8005102:	2101      	movs	r1, #1
 8005104:	f7fb ff14 	bl	8000f30 <chMsgSend>
 8005108:	6a73      	ldr	r3, [r6, #36]	; 0x24
    n++;
 800510a:	3401      	adds	r4, #1
 800510c:	1bdb      	subs	r3, r3, r7
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 800510e:	b29b      	uxth	r3, r3
 8005110:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005114:	d3f4      	bcc.n	8005100 <msg_loop_test.10723+0x10>
  (void)chMsgSend(tp, 0);
 8005116:	4628      	mov	r0, r5
 8005118:	2100      	movs	r1, #0
 800511a:	f7fb ff09 	bl	8000f30 <chMsgSend>
  return n;
}
 800511e:	4620      	mov	r0, r4
 8005120:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005122:	bf00      	nop
 8005124:	f3af 8000 	nop.w
 8005128:	f3af 8000 	nop.w
 800512c:	f3af 8000 	nop.w

08005130 <chThdEnqueueTimeoutS.4263>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8005130:	b410      	push	{r4}
 8005132:	4602      	mov	r2, r0

  if (TIME_IMMEDIATE == timeout) {
 8005134:	b171      	cbz	r1, 8005154 <chThdEnqueueTimeoutS.4263+0x24>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8005136:	f241 23c0 	movw	r3, #4800	; 0x12c0
 800513a:	f2c2 0300 	movt	r3, #8192	; 0x2000
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800513e:	6844      	ldr	r4, [r0, #4]
 8005140:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005142:	2004      	movs	r0, #4
 8005144:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8005148:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 800514a:	6053      	str	r3, [r2, #4]
}
 800514c:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8005150:	f7ff be5e 	b.w	8004e10 <chSchGoSleepTimeoutS>
}
 8005154:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005158:	f85d 4b04 	ldr.w	r4, [sp], #4
 800515c:	4770      	bx	lr
 800515e:	bf00      	nop

08005160 <iqGetTimeout.4136>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8005160:	b570      	push	{r4, r5, r6, lr}
 8005162:	2320      	movs	r3, #32
 8005164:	4604      	mov	r4, r0
 8005166:	460e      	mov	r6, r1
 8005168:	f383 8811 	msr	BASEPRI, r3
 800516c:	e003      	b.n	8005176 <iqGetTimeout.4136+0x16>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 800516e:	f7ff ffdf 	bl	8005130 <chThdEnqueueTimeoutS.4263>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8005172:	2800      	cmp	r0, #0
 8005174:	db1b      	blt.n	80051ae <iqGetTimeout.4136+0x4e>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8005176:	68a5      	ldr	r5, [r4, #8]
 8005178:	4620      	mov	r0, r4
 800517a:	4631      	mov	r1, r6
 800517c:	2d00      	cmp	r5, #0
 800517e:	d0f6      	beq.n	800516e <iqGetTimeout.4136+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8005180:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8005182:	6921      	ldr	r1, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8005184:	1c53      	adds	r3, r2, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8005186:	68a0      	ldr	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8005188:	428b      	cmp	r3, r1
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800518a:	61a3      	str	r3, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800518c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8005190:	bf28      	it	cs
 8005192:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8005194:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
 8005196:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8005198:	bf28      	it	cs
 800519a:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800519c:	69e3      	ldr	r3, [r4, #28]
 800519e:	b10b      	cbz	r3, 80051a4 <iqGetTimeout.4136+0x44>
    iqp->q_notify(iqp);
 80051a0:	4620      	mov	r0, r4
 80051a2:	4798      	blx	r3
 80051a4:	2300      	movs	r3, #0
 80051a6:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 80051aa:	4628      	mov	r0, r5
}
 80051ac:	bd70      	pop	{r4, r5, r6, pc}
 80051ae:	f385 8811 	msr	BASEPRI, r5
 80051b2:	bd70      	pop	{r4, r5, r6, pc}
 80051b4:	f3af 8000 	nop.w
 80051b8:	f3af 8000 	nop.w
 80051bc:	f3af 8000 	nop.w

080051c0 <_gett.7731>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80051c0:	300c      	adds	r0, #12
 80051c2:	f7ff bfcd 	b.w	8005160 <iqGetTimeout.4136>
 80051c6:	bf00      	nop
 80051c8:	f3af 8000 	nop.w
 80051cc:	f3af 8000 	nop.w

080051d0 <_get.7735>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80051d0:	300c      	adds	r0, #12
 80051d2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80051d6:	f7ff bfc3 	b.w	8005160 <iqGetTimeout.4136>
 80051da:	bf00      	nop
 80051dc:	f3af 8000 	nop.w

080051e0 <iqReadTimeout.4170>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 80051e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80051e4:	4698      	mov	r8, r3
 80051e6:	b083      	sub	sp, #12
 80051e8:	4604      	mov	r4, r0
 80051ea:	4689      	mov	r9, r1
 80051ec:	4615      	mov	r5, r2
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 80051ee:	69c7      	ldr	r7, [r0, #28]
 80051f0:	2320      	movs	r3, #32
 80051f2:	f383 8811 	msr	BASEPRI, r3
 80051f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80051fa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80051fc:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8005200:	4442      	add	r2, r8
 8005202:	b292      	uxth	r2, r2
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8005204:	2600      	movs	r6, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8005206:	9201      	str	r2, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8005208:	fa1f fb8b 	uxth.w	fp, fp
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800520c:	68a3      	ldr	r3, [r4, #8]
 800520e:	b30b      	cbz	r3, 8005254 <iqReadTimeout.4170+0x74>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8005210:	69a3      	ldr	r3, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8005212:	68a1      	ldr	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8005214:	1c5a      	adds	r2, r3, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8005216:	3901      	subs	r1, #1
    *bp++ = *iqp->q_rdptr++;
 8005218:	61a2      	str	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 800521a:	60a1      	str	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800521c:	781b      	ldrb	r3, [r3, #0]
 800521e:	f109 0a01 	add.w	sl, r9, #1
 8005222:	f889 3000 	strb.w	r3, [r9]
    if (iqp->q_rdptr >= iqp->q_top) {
 8005226:	6923      	ldr	r3, [r4, #16]
 8005228:	69a2      	ldr	r2, [r4, #24]
 800522a:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 800522c:	bf24      	itt	cs
 800522e:	68e3      	ldrcs	r3, [r4, #12]
 8005230:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8005232:	b10f      	cbz	r7, 8005238 <iqReadTimeout.4170+0x58>
      nfy(iqp);
 8005234:	4620      	mov	r0, r4
 8005236:	47b8      	blx	r7
 8005238:	2300      	movs	r3, #0
 800523a:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 800523e:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8005240:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8005244:	d01a      	beq.n	800527c <iqReadTimeout.4170+0x9c>
 8005246:	2220      	movs	r2, #32
 8005248:	f382 8811 	msr	BASEPRI, r2
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 800524c:	68a3      	ldr	r3, [r4, #8]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800524e:	46d1      	mov	r9, sl
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8005250:	2b00      	cmp	r3, #0
 8005252:	d1dd      	bne.n	8005210 <iqReadTimeout.4170+0x30>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8005254:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 8005258:	4593      	cmp	fp, r2
 800525a:	d813      	bhi.n	8005284 <iqReadTimeout.4170+0xa4>
 800525c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8005260:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8005262:	9a01      	ldr	r2, [sp, #4]
 8005264:	1a51      	subs	r1, r2, r1
 8005266:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8005268:	4588      	cmp	r8, r1
 800526a:	d305      	bcc.n	8005278 <iqReadTimeout.4170+0x98>
 800526c:	4620      	mov	r0, r4
 800526e:	f7ff ff5f 	bl	8005130 <chThdEnqueueTimeoutS.4263>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8005272:	2800      	cmp	r0, #0
 8005274:	d0ca      	beq.n	800520c <iqReadTimeout.4170+0x2c>
 8005276:	2300      	movs	r3, #0
 8005278:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 800527c:	4630      	mov	r0, r6
 800527e:	b003      	add	sp, #12
 8005280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005284:	4620      	mov	r0, r4
 8005286:	4641      	mov	r1, r8
 8005288:	f7ff ff52 	bl	8005130 <chThdEnqueueTimeoutS.4263>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800528c:	2800      	cmp	r0, #0
 800528e:	d0bd      	beq.n	800520c <iqReadTimeout.4170+0x2c>
 8005290:	e7f1      	b.n	8005276 <iqReadTimeout.4170+0x96>
 8005292:	bf00      	nop
 8005294:	f3af 8000 	nop.w
 8005298:	f3af 8000 	nop.w
 800529c:	f3af 8000 	nop.w

080052a0 <_readt.7706>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80052a0:	300c      	adds	r0, #12
 80052a2:	f7ff bf9d 	b.w	80051e0 <iqReadTimeout.4170>
 80052a6:	bf00      	nop
 80052a8:	f3af 8000 	nop.w
 80052ac:	f3af 8000 	nop.w

080052b0 <_read.7715>:
                        n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80052b0:	300c      	adds	r0, #12
 80052b2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80052b6:	f7ff bf93 	b.w	80051e0 <iqReadTimeout.4170>
 80052ba:	bf00      	nop
 80052bc:	f3af 8000 	nop.w

080052c0 <oqPutTimeout.4185>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80052c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80052c2:	4604      	mov	r4, r0
 80052c4:	460f      	mov	r7, r1
 80052c6:	4616      	mov	r6, r2
 80052c8:	2320      	movs	r3, #32
 80052ca:	f383 8811 	msr	BASEPRI, r3
 80052ce:	e003      	b.n	80052d8 <oqPutTimeout.4185+0x18>
 80052d0:	f7ff ff2e 	bl	8005130 <chThdEnqueueTimeoutS.4263>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 80052d4:	2800      	cmp	r0, #0
 80052d6:	db1a      	blt.n	800530e <oqPutTimeout.4185+0x4e>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 80052d8:	68a5      	ldr	r5, [r4, #8]
 80052da:	4620      	mov	r0, r4
 80052dc:	4631      	mov	r1, r6
 80052de:	2d00      	cmp	r5, #0
 80052e0:	d0f6      	beq.n	80052d0 <oqPutTimeout.4185+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 80052e2:	6963      	ldr	r3, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80052e4:	68a1      	ldr	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 80052e6:	1c5a      	adds	r2, r3, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80052e8:	3901      	subs	r1, #1
  *oqp->q_wrptr++ = b;
 80052ea:	6162      	str	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 80052ec:	60a1      	str	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 80052ee:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80052f0:	6923      	ldr	r3, [r4, #16]
 80052f2:	6962      	ldr	r2, [r4, #20]
 80052f4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 80052f6:	bf24      	itt	cs
 80052f8:	68e3      	ldrcs	r3, [r4, #12]
 80052fa:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80052fc:	69e3      	ldr	r3, [r4, #28]
 80052fe:	b10b      	cbz	r3, 8005304 <oqPutTimeout.4185+0x44>
    oqp->q_notify(oqp);
 8005300:	4620      	mov	r0, r4
 8005302:	4798      	blx	r3
 8005304:	2300      	movs	r3, #0
 8005306:	f383 8811 	msr	BASEPRI, r3
 800530a:	2000      	movs	r0, #0
  }

  osalSysUnlock();

  return MSG_OK;
}
 800530c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800530e:	f385 8811 	msr	BASEPRI, r5
 8005312:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005314:	f3af 8000 	nop.w
 8005318:	f3af 8000 	nop.w
 800531c:	f3af 8000 	nop.w

08005320 <_putt.7738>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8005320:	3030      	adds	r0, #48	; 0x30
 8005322:	f7ff bfcd 	b.w	80052c0 <oqPutTimeout.4185>
 8005326:	bf00      	nop
 8005328:	f3af 8000 	nop.w
 800532c:	f3af 8000 	nop.w

08005330 <_put.7743>:
                       n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8005330:	3030      	adds	r0, #48	; 0x30
 8005332:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8005336:	f7ff bfc3 	b.w	80052c0 <oqPutTimeout.4185>
 800533a:	bf00      	nop
 800533c:	f3af 8000 	nop.w

08005340 <oqWriteTimeout.4207>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8005340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005344:	4698      	mov	r8, r3
 8005346:	b083      	sub	sp, #12
 8005348:	4604      	mov	r4, r0
 800534a:	4689      	mov	r9, r1
 800534c:	4615      	mov	r5, r2
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 800534e:	69c7      	ldr	r7, [r0, #28]
 8005350:	2320      	movs	r3, #32
 8005352:	f383 8811 	msr	BASEPRI, r3
 8005356:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800535a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800535c:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8005360:	4442      	add	r2, r8
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8005362:	2600      	movs	r6, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8005364:	b292      	uxth	r2, r2
 8005366:	9201      	str	r2, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8005368:	fa1f fb8b 	uxth.w	fp, fp
 800536c:	46b2      	mov	sl, r6
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 800536e:	68a3      	ldr	r3, [r4, #8]
 8005370:	b1fb      	cbz	r3, 80053b2 <oqWriteTimeout.4207+0x72>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8005372:	6963      	ldr	r3, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8005374:	68a1      	ldr	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8005376:	1c5a      	adds	r2, r3, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8005378:	3901      	subs	r1, #1
    *oqp->q_wrptr++ = *bp++;
 800537a:	6162      	str	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 800537c:	60a1      	str	r1, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800537e:	f899 2000 	ldrb.w	r2, [r9]
 8005382:	f109 0901 	add.w	r9, r9, #1
 8005386:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8005388:	6923      	ldr	r3, [r4, #16]
 800538a:	6962      	ldr	r2, [r4, #20]
 800538c:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 800538e:	bf24      	itt	cs
 8005390:	68e3      	ldrcs	r3, [r4, #12]
 8005392:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8005394:	b10f      	cbz	r7, 800539a <oqWriteTimeout.4207+0x5a>
      nfy(oqp);
 8005396:	4620      	mov	r0, r4
 8005398:	47b8      	blx	r7
 800539a:	f38a 8811 	msr	BASEPRI, sl

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 800539e:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 80053a0:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 80053a4:	d019      	beq.n	80053da <oqWriteTimeout.4207+0x9a>
 80053a6:	2320      	movs	r3, #32
 80053a8:	f383 8811 	msr	BASEPRI, r3
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 80053ac:	68a3      	ldr	r3, [r4, #8]
 80053ae:	2b00      	cmp	r3, #0
 80053b0:	d1df      	bne.n	8005372 <oqWriteTimeout.4207+0x32>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80053b2:	f64f 72fd 	movw	r2, #65533	; 0xfffd
 80053b6:	4593      	cmp	fp, r2
 80053b8:	d813      	bhi.n	80053e2 <oqWriteTimeout.4207+0xa2>
 80053ba:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80053be:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80053c0:	9a01      	ldr	r2, [sp, #4]
 80053c2:	1a51      	subs	r1, r2, r1
 80053c4:	b289      	uxth	r1, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80053c6:	4588      	cmp	r8, r1
 80053c8:	d305      	bcc.n	80053d6 <oqWriteTimeout.4207+0x96>
 80053ca:	4620      	mov	r0, r4
 80053cc:	f7ff feb0 	bl	8005130 <chThdEnqueueTimeoutS.4263>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80053d0:	2800      	cmp	r0, #0
 80053d2:	d0cc      	beq.n	800536e <oqWriteTimeout.4207+0x2e>
 80053d4:	2300      	movs	r3, #0
 80053d6:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 80053da:	4630      	mov	r0, r6
 80053dc:	b003      	add	sp, #12
 80053de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80053e2:	4620      	mov	r0, r4
 80053e4:	4641      	mov	r1, r8
 80053e6:	f7ff fea3 	bl	8005130 <chThdEnqueueTimeoutS.4263>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80053ea:	2800      	cmp	r0, #0
 80053ec:	d0bf      	beq.n	800536e <oqWriteTimeout.4207+0x2e>
 80053ee:	e7f1      	b.n	80053d4 <oqWriteTimeout.4207+0x94>

080053f0 <_writet.7720>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80053f0:	3030      	adds	r0, #48	; 0x30
 80053f2:	f7ff bfa5 	b.w	8005340 <oqWriteTimeout.4207>
 80053f6:	bf00      	nop
 80053f8:	f3af 8000 	nop.w
 80053fc:	f3af 8000 	nop.w

08005400 <_write.7726>:
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8005400:	3030      	adds	r0, #48	; 0x30
 8005402:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8005406:	f7ff bf9b 	b.w	8005340 <oqWriteTimeout.4207>
 800540a:	bf00      	nop
 800540c:	f3af 8000 	nop.w

08005410 <chMBPost.constprop.20>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8005410:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005414:	2320      	movs	r3, #32
 8005416:	4680      	mov	r8, r0
 8005418:	460f      	mov	r7, r1
 800541a:	f383 8811 	msr	BASEPRI, r3
 800541e:	f640 0638 	movw	r6, #2104	; 0x838
 8005422:	f2c2 0600 	movt	r6, #8192	; 0x2000
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005426:	4634      	mov	r4, r6
 8005428:	e00c      	b.n	8005444 <chMBPost.constprop.20+0x34>
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 800542a:	f8d4 e000 	ldr.w	lr, [r4]
 800542e:	6862      	ldr	r2, [r4, #4]

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005430:	6925      	ldr	r5, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8005432:	ebce 0c02 	rsb	ip, lr, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005436:	ebc5 05ac 	rsb	r5, r5, ip, asr #2
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 800543a:	2d00      	cmp	r5, #0
 800543c:	dc13      	bgt.n	8005466 <chMBPost.constprop.20+0x56>

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 800543e:	f7ff fe77 	bl	8005130 <chThdEnqueueTimeoutS.4263>
  } while (rdymsg == MSG_OK);
 8005442:	b958      	cbnz	r0, 800545c <chMBPost.constprop.20+0x4c>
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005444:	f640 0338 	movw	r3, #2104	; 0x838
 8005448:	7d32      	ldrb	r2, [r6, #20]
 800544a:	f2c2 0300 	movt	r3, #8192	; 0x2000

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 800544e:	4639      	mov	r1, r7
 8005450:	f103 0018 	add.w	r0, r3, #24
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005454:	2a00      	cmp	r2, #0
 8005456:	d0e8      	beq.n	800542a <chMBPost.constprop.20+0x1a>
      return MSG_RESET;
 8005458:	f06f 0001 	mvn.w	r0, #1
 800545c:	2300      	movs	r3, #0
 800545e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005462:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
      *mbp->wrptr++ = msg;
 8005466:	6898      	ldr	r0, [r3, #8]
 8005468:	1d01      	adds	r1, r0, #4
 800546a:	6099      	str	r1, [r3, #8]
      if (mbp->wrptr >= mbp->top) {
 800546c:	4291      	cmp	r1, r2
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
      *mbp->wrptr++ = msg;
 800546e:	f8c0 8000 	str.w	r8, [r0]
      if (mbp->wrptr >= mbp->top) {
        mbp->wrptr = mbp->buffer;
 8005472:	bf28      	it	cs
 8005474:	f8c3 e008 	strcs.w	lr, [r3, #8]
      }
      mbp->cnt++;
 8005478:	6933      	ldr	r3, [r6, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 800547a:	4806      	ldr	r0, [pc, #24]	; (8005494 <chMBPost.constprop.20+0x84>)
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
      *mbp->wrptr++ = msg;
      if (mbp->wrptr >= mbp->top) {
        mbp->wrptr = mbp->buffer;
      }
      mbp->cnt++;
 800547c:	3301      	adds	r3, #1
 800547e:	6133      	str	r3, [r6, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8005480:	f7fd fa2e 	bl	80028e0 <chThdDequeueNextI.constprop.49>
      chSchRescheduleS();
 8005484:	f7fb fbac 	bl	8000be0 <chSchRescheduleS>
 8005488:	2000      	movs	r0, #0
 800548a:	2300      	movs	r3, #0
 800548c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005490:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005494:	20000858 	.word	0x20000858
 8005498:	f3af 8000 	nop.w
 800549c:	f3af 8000 	nop.w

080054a0 <chMBPostAhead.constprop.18>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80054a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80054a4:	2320      	movs	r3, #32
 80054a6:	4680      	mov	r8, r0
 80054a8:	460f      	mov	r7, r1
 80054aa:	f383 8811 	msr	BASEPRI, r3
 80054ae:	f640 0638 	movw	r6, #2104	; 0x838
 80054b2:	f2c2 0600 	movt	r6, #8192	; 0x2000
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 80054b6:	4634      	mov	r4, r6
 80054b8:	e00b      	b.n	80054d2 <chMBPostAhead.constprop.18+0x32>
 80054ba:	6925      	ldr	r5, [r4, #16]
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 80054bc:	e894 4004 	ldmia.w	r4, {r2, lr}
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 80054c0:	ebc2 0c0e 	rsb	ip, r2, lr
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80054c4:	ebc5 05ac 	rsb	r5, r5, ip, asr #2
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
 80054c8:	2d00      	cmp	r5, #0
 80054ca:	dc13      	bgt.n	80054f4 <chMBPostAhead.constprop.18+0x54>

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80054cc:	f7ff fe30 	bl	8005130 <chThdEnqueueTimeoutS.4263>
  } while (rdymsg == MSG_OK);
 80054d0:	b958      	cbnz	r0, 80054ea <chMBPostAhead.constprop.18+0x4a>
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 80054d2:	f640 0338 	movw	r3, #2104	; 0x838
 80054d6:	7d32      	ldrb	r2, [r6, #20]
 80054d8:	f2c2 0300 	movt	r3, #8192	; 0x2000

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 80054dc:	4639      	mov	r1, r7
 80054de:	f103 0018 	add.w	r0, r3, #24
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 80054e2:	2a00      	cmp	r2, #0
 80054e4:	d0e9      	beq.n	80054ba <chMBPostAhead.constprop.18+0x1a>
      return MSG_RESET;
 80054e6:	f06f 0001 	mvn.w	r0, #1
 80054ea:	2300      	movs	r3, #0
 80054ec:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80054f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
      if (--mbp->rdptr < mbp->buffer) {
 80054f4:	68d9      	ldr	r1, [r3, #12]
      }
      *mbp->rdptr = msg;
      mbp->cnt++;

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 80054f6:	480b      	ldr	r0, [pc, #44]	; (8005524 <chMBPostAhead.constprop.18+0x84>)
      return MSG_RESET;
    }

    /* Is there a free message slot in queue? if so then post.*/
    if (chMBGetFreeCountI(mbp) > (cnt_t)0) {
      if (--mbp->rdptr < mbp->buffer) {
 80054f8:	3904      	subs	r1, #4
 80054fa:	4291      	cmp	r1, r2
        mbp->rdptr = mbp->top - 1;
 80054fc:	bf38      	it	cc
 80054fe:	f1ae 0104 	subcc.w	r1, lr, #4
 8005502:	60d9      	str	r1, [r3, #12]
      }
      *mbp->rdptr = msg;
 8005504:	f8c1 8000 	str.w	r8, [r1]
      mbp->cnt++;
 8005508:	6933      	ldr	r3, [r6, #16]
 800550a:	3301      	adds	r3, #1
 800550c:	6133      	str	r3, [r6, #16]

      /* If there is a reader waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 800550e:	f7fd f9e7 	bl	80028e0 <chThdDequeueNextI.constprop.49>
      chSchRescheduleS();
 8005512:	f7fb fb65 	bl	8000be0 <chSchRescheduleS>
 8005516:	2000      	movs	r0, #0
 8005518:	2300      	movs	r3, #0
 800551a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 800551e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005522:	bf00      	nop
 8005524:	20000858 	.word	0x20000858
 8005528:	f3af 8000 	nop.w
 800552c:	f3af 8000 	nop.w

08005530 <chMBFetch.constprop.16>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8005530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005532:	4607      	mov	r7, r0
 8005534:	460d      	mov	r5, r1
 8005536:	2320      	movs	r3, #32
 8005538:	f383 8811 	msr	BASEPRI, r3
 800553c:	f640 0438 	movw	r4, #2104	; 0x838
 8005540:	f2c2 0400 	movt	r4, #8192	; 0x2000
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005544:	4626      	mov	r6, r4
 8005546:	e005      	b.n	8005554 <chMBFetch.constprop.16+0x24>
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
 8005548:	6932      	ldr	r2, [r6, #16]
 800554a:	2a00      	cmp	r2, #0
 800554c:	dc12      	bgt.n	8005574 <chMBFetch.constprop.16+0x44>

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 800554e:	f7ff fdef 	bl	8005130 <chThdEnqueueTimeoutS.4263>
  } while (rdymsg == MSG_OK);
 8005552:	b958      	cbnz	r0, 800556c <chMBFetch.constprop.16+0x3c>
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005554:	f640 0338 	movw	r3, #2104	; 0x838
 8005558:	7d22      	ldrb	r2, [r4, #20]
 800555a:	f2c2 0300 	movt	r3, #8192	; 0x2000

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 800555e:	4629      	mov	r1, r5
 8005560:	f103 0020 	add.w	r0, r3, #32
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  do {
    /* If the mailbox is in reset state then returns immediately.*/
    if (mbp->reset) {
 8005564:	2a00      	cmp	r2, #0
 8005566:	d0ef      	beq.n	8005548 <chMBFetch.constprop.16+0x18>
      return MSG_RESET;
 8005568:	f06f 0001 	mvn.w	r0, #1
 800556c:	2300      	movs	r3, #0
 800556e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005572:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
      *msgp = *mbp->rdptr++;
 8005574:	68da      	ldr	r2, [r3, #12]
      if (mbp->rdptr >= mbp->top) {
 8005576:	6859      	ldr	r1, [r3, #4]
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
      *msgp = *mbp->rdptr++;
 8005578:	6810      	ldr	r0, [r2, #0]
 800557a:	3204      	adds	r2, #4
      if (mbp->rdptr >= mbp->top) {
 800557c:	428a      	cmp	r2, r1
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
      *msgp = *mbp->rdptr++;
 800557e:	60da      	str	r2, [r3, #12]
      if (mbp->rdptr >= mbp->top) {
        mbp->rdptr = mbp->buffer;
 8005580:	bf28      	it	cs
 8005582:	681a      	ldrcs	r2, [r3, #0]
      return MSG_RESET;
    }

    /* Is there a message in queue? if so then fetch.*/
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
      *msgp = *mbp->rdptr++;
 8005584:	6038      	str	r0, [r7, #0]
      if (mbp->rdptr >= mbp->top) {
        mbp->rdptr = mbp->buffer;
 8005586:	bf28      	it	cs
 8005588:	60da      	strcs	r2, [r3, #12]
      }
      mbp->cnt--;
 800558a:	6923      	ldr	r3, [r4, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 800558c:	4805      	ldr	r0, [pc, #20]	; (80055a4 <chMBFetch.constprop.16+0x74>)
    if (chMBGetUsedCountI(mbp) > (cnt_t)0) {
      *msgp = *mbp->rdptr++;
      if (mbp->rdptr >= mbp->top) {
        mbp->rdptr = mbp->buffer;
      }
      mbp->cnt--;
 800558e:	3b01      	subs	r3, #1
 8005590:	6123      	str	r3, [r4, #16]

      /* If there is a writer waiting then makes it ready.*/
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8005592:	f7fd f9a5 	bl	80028e0 <chThdDequeueNextI.constprop.49>
      chSchRescheduleS();
 8005596:	f7fb fb23 	bl	8000be0 <chSchRescheduleS>
 800559a:	2000      	movs	r0, #0
 800559c:	2300      	movs	r3, #0
 800559e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 80055a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80055a4:	20000850 	.word	0x20000850
 80055a8:	f3af 8000 	nop.w
 80055ac:	f3af 8000 	nop.w

080055b0 <test_009_002_execute.10105>:

static void test_009_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_002_execute(void) {
 80055b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [9.2.1] Testing the mailbox size.*/
  test_set_step(1);
 80055b4:	f241 3530 	movw	r5, #4912	; 0x1330
 80055b8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80055bc:	2301      	movs	r3, #1

static void test_009_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_009_002_execute(void) {
 80055be:	b082      	sub	sp, #8
  msg_t msg1, msg2;
  unsigned i;

  /* [9.2.1] Testing the mailbox size.*/
  test_set_step(1);
 80055c0:	602b      	str	r3, [r5, #0]
 80055c2:	2320      	movs	r3, #32
 80055c4:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 80055c8:	f640 0438 	movw	r4, #2104	; 0x838
 80055cc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 80055d0:	6861      	ldr	r1, [r4, #4]
 80055d2:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80055d4:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 80055d6:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80055d8:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80055dc:	1f02      	subs	r2, r0, #4
 80055de:	4250      	negs	r0, r2
 80055e0:	f647 11c8 	movw	r1, #31176	; 0x79c8
 80055e4:	4150      	adcs	r0, r2
 80055e6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80055ea:	f7fb f889 	bl	8000700 <_test_assert>
 80055ee:	b128      	cbz	r0, 80055fc <test_009_002_execute.10105+0x4c>
 80055f0:	2300      	movs	r3, #0
 80055f2:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80055f6:	b002      	add	sp, #8
 80055f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80055fc:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [9.2.2] Resetting the mailbox, conditions are checked, no errors
     expected. The mailbox is then returned in active state.*/
  test_set_step(2);
 8005600:	2302      	movs	r3, #2
 8005602:	602b      	str	r3, [r5, #0]
 8005604:	2320      	movs	r3, #32
 8005606:	f383 8811 	msr	BASEPRI, r3
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 800560a:	6823      	ldr	r3, [r4, #0]
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (cnt_t)0;
  mbp->reset = true;
 800560c:	2201      	movs	r2, #1
  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (cnt_t)0;
 800560e:	2600      	movs	r6, #0
  mbp->reset = true;
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8005610:	48bc      	ldr	r0, [pc, #752]	; (8005904 <test_009_002_execute.10105+0x354>)
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (cnt_t)0;
  mbp->reset = true;
 8005612:	7522      	strb	r2, [r4, #20]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8005614:	60a3      	str	r3, [r4, #8]
  mbp->rdptr = mbp->buffer;
 8005616:	60e3      	str	r3, [r4, #12]
  mbp->cnt   = (cnt_t)0;
 8005618:	6126      	str	r6, [r4, #16]
  mbp->reset = true;
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 800561a:	f7fd fad9 	bl	8002bd0 <chThdDequeueAllI.constprop.48>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 800561e:	48ba      	ldr	r0, [pc, #744]	; (8005908 <test_009_002_execute.10105+0x358>)
 8005620:	f7fd fad6 	bl	8002bd0 <chThdDequeueAllI.constprop.48>
 8005624:	f386 8811 	msr	BASEPRI, r6
 8005628:	2320      	movs	r3, #32
 800562a:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {
 800562e:	f640 0438 	movw	r4, #2104	; 0x838
 8005632:	f2c2 0400 	movt	r4, #8192	; 0x2000
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8005636:	6861      	ldr	r1, [r4, #4]
 8005638:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800563a:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 800563c:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800563e:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
  {
    chSysLock();
    chMBResetI(&mb1);
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005642:	1f03      	subs	r3, r0, #4
 8005644:	4258      	negs	r0, r3
 8005646:	f247 7138 	movw	r1, #30520	; 0x7738
 800564a:	4158      	adcs	r0, r3
 800564c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005650:	f7fb f856 	bl	8000700 <_test_assert>
 8005654:	2800      	cmp	r0, #0
 8005656:	d1cb      	bne.n	80055f0 <test_009_002_execute.10105+0x40>
 8005658:	f380 8811 	msr	BASEPRI, r0
 800565c:	2320      	movs	r3, #32
 800565e:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8005662:	6920      	ldr	r0, [r4, #16]
 8005664:	f647 11d4 	movw	r1, #31188	; 0x79d4
 8005668:	f1d0 0001 	rsbs	r0, r0, #1
 800566c:	bf38      	it	cc
 800566e:	2000      	movcc	r0, #0
 8005670:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005674:	f7fb f844 	bl	8000700 <_test_assert>
 8005678:	2800      	cmp	r0, #0
 800567a:	d1b9      	bne.n	80055f0 <test_009_002_execute.10105+0x40>
 800567c:	f380 8811 	msr	BASEPRI, r0
 8005680:	2320      	movs	r3, #32
 8005682:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8005686:	6820      	ldr	r0, [r4, #0]
 8005688:	68a3      	ldr	r3, [r4, #8]
 800568a:	f647 11e0 	movw	r1, #31200	; 0x79e0
 800568e:	ebb0 0803 	subs.w	r8, r0, r3
 8005692:	f1d8 0000 	rsbs	r0, r8, #0
 8005696:	eb50 0008 	adcs.w	r0, r0, r8
 800569a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800569e:	f7fb f82f 	bl	8000700 <_test_assert>
 80056a2:	2800      	cmp	r0, #0
 80056a4:	d1a4      	bne.n	80055f0 <test_009_002_execute.10105+0x40>
 80056a6:	f380 8811 	msr	BASEPRI, r0
 80056aa:	2320      	movs	r3, #32
 80056ac:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80056b0:	6820      	ldr	r0, [r4, #0]
 80056b2:	68e3      	ldr	r3, [r4, #12]
 80056b4:	f647 2104 	movw	r1, #31236	; 0x7a04
 80056b8:	ebb0 0c03 	subs.w	ip, r0, r3
 80056bc:	f1dc 0000 	rsbs	r0, ip, #0
 80056c0:	eb50 000c 	adcs.w	r0, r0, ip
 80056c4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80056c8:	f7fb f81a 	bl	8000700 <_test_assert>
 80056cc:	2800      	cmp	r0, #0
 80056ce:	d18f      	bne.n	80055f0 <test_009_002_execute.10105+0x40>
 80056d0:	f380 8811 	msr	BASEPRI, r0
    chMBResumeX(&mb1);
  }

  /* [9.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 80056d4:	2303      	movs	r3, #3
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 80056d6:	f04f 0800 	mov.w	r8, #0
 80056da:	602b      	str	r3, [r5, #0]
 80056dc:	f884 8014 	strb.w	r8, [r4, #20]
 80056e0:	2642      	movs	r6, #66	; 0x42
 80056e2:	2720      	movs	r7, #32
 80056e4:	f387 8811 	msr	BASEPRI, r7
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
 80056e8:	4630      	mov	r0, r6
 80056ea:	f7fd fa49 	bl	8002b80 <chMBPostI.constprop.19>
 80056ee:	f388 8811 	msr	BASEPRI, r8
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80056f2:	f647 1110 	movw	r1, #30992	; 0x7910
 80056f6:	f1d0 0001 	rsbs	r0, r0, #1
 80056fa:	bf38      	it	cc
 80056fc:	2000      	movcc	r0, #0
 80056fe:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005702:	3601      	adds	r6, #1
 8005704:	f7fa fffc 	bl	8000700 <_test_assert>
 8005708:	2800      	cmp	r0, #0
 800570a:	f47f af74 	bne.w	80055f6 <test_009_002_execute.10105+0x46>

  /* [9.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 800570e:	2e45      	cmp	r6, #69	; 0x45
 8005710:	d1e8      	bne.n	80056e4 <test_009_002_execute.10105+0x134>
 8005712:	2320      	movs	r3, #32
 8005714:	f383 8811 	msr	BASEPRI, r3
      msg1 = chMBPostI(&mb1, 'B' + i);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'A');
 8005718:	2041      	movs	r0, #65	; 0x41
 800571a:	f7fd fa09 	bl	8002b30 <chMBPostAheadI.constprop.17>
 800571e:	2300      	movs	r3, #0
 8005720:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005724:	f647 1110 	movw	r1, #30992	; 0x7910
 8005728:	f1d0 0001 	rsbs	r0, r0, #1
 800572c:	bf38      	it	cc
 800572e:	2000      	movcc	r0, #0
 8005730:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005734:	f7fa ffe4 	bl	8000700 <_test_assert>
 8005738:	2800      	cmp	r0, #0
 800573a:	f47f af5c 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
  }

  /* [9.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 800573e:	2304      	movs	r3, #4
 8005740:	602b      	str	r3, [r5, #0]
 8005742:	2320      	movs	r3, #32
 8005744:	f383 8811 	msr	BASEPRI, r3
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 8005748:	6861      	ldr	r1, [r4, #4]
 800574a:	6822      	ldr	r2, [r4, #0]
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 800574c:	6923      	ldr	r3, [r4, #16]
 800574e:	1a8a      	subs	r2, r1, r2
 8005750:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8005754:	f647 213c 	movw	r1, #31292	; 0x7a3c
 8005758:	bf14      	ite	ne
 800575a:	2000      	movne	r0, #0
 800575c:	2001      	moveq	r0, #1
 800575e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005762:	f7fa ffcd 	bl	8000700 <_test_assert>
 8005766:	2800      	cmp	r0, #0
 8005768:	f47f af42 	bne.w	80055f0 <test_009_002_execute.10105+0x40>
 800576c:	f380 8811 	msr	BASEPRI, r0
 8005770:	2320      	movs	r3, #32
 8005772:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8005776:	6920      	ldr	r0, [r4, #16]
 8005778:	f647 2148 	movw	r1, #31304	; 0x7a48
 800577c:	f1b0 0e04 	subs.w	lr, r0, #4
 8005780:	f1de 0000 	rsbs	r0, lr, #0
 8005784:	eb50 000e 	adcs.w	r0, r0, lr
 8005788:	f6c0 0100 	movt	r1, #2048	; 0x800
 800578c:	f7fa ffb8 	bl	8000700 <_test_assert>
 8005790:	2800      	cmp	r0, #0
 8005792:	f47f af2d 	bne.w	80055f0 <test_009_002_execute.10105+0x40>
 8005796:	f380 8811 	msr	BASEPRI, r0
 800579a:	2320      	movs	r3, #32
 800579c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 80057a0:	68e0      	ldr	r0, [r4, #12]
 80057a2:	68a3      	ldr	r3, [r4, #8]
 80057a4:	f647 2154 	movw	r1, #31316	; 0x7a54
 80057a8:	1ac7      	subs	r7, r0, r3
 80057aa:	4278      	negs	r0, r7
 80057ac:	4178      	adcs	r0, r7
 80057ae:	f6c0 0100 	movt	r1, #2048	; 0x800
 80057b2:	f7fa ffa5 	bl	8000700 <_test_assert>
 80057b6:	2800      	cmp	r0, #0
 80057b8:	f47f af1a 	bne.w	80055f0 <test_009_002_execute.10105+0x40>
 80057bc:	f380 8811 	msr	BASEPRI, r0
  }

  /* [9.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 80057c0:	2305      	movs	r3, #5
 80057c2:	602b      	str	r3, [r5, #0]
 80057c4:	2604      	movs	r6, #4
 80057c6:	f04f 0820 	mov.w	r8, #32
 80057ca:	2700      	movs	r7, #0
 80057cc:	f388 8811 	msr	BASEPRI, r8
  {
    for (i = 0; i < MB_SIZE; i++) {
      chSysLock();
      msg1 = chMBFetchI(&mb1, &msg2);
 80057d0:	a801      	add	r0, sp, #4
 80057d2:	f7fd f985 	bl	8002ae0 <chMBFetchI.constprop.15>
 80057d6:	f387 8811 	msr	BASEPRI, r7
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80057da:	f647 1110 	movw	r1, #30992	; 0x7910
 80057de:	f1d0 0001 	rsbs	r0, r0, #1
 80057e2:	bf38      	it	cc
 80057e4:	2000      	movcc	r0, #0
 80057e6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80057ea:	f7fa ff89 	bl	8000700 <_test_assert>
 80057ee:	2800      	cmp	r0, #0
 80057f0:	f47f af01 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
      test_emit_token(msg2);
 80057f4:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80057f8:	f7fa feda 	bl	80005b0 <test_emit_token>

  /* [9.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 80057fc:	3e01      	subs	r6, #1
 80057fe:	d1e5      	bne.n	80057cc <test_009_002_execute.10105+0x21c>
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8005800:	f647 0054 	movw	r0, #30804	; 0x7854
 8005804:	f647 216c 	movw	r1, #31340	; 0x7a6c
 8005808:	f6c0 0000 	movt	r0, #2048	; 0x800
 800580c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005810:	f7fa ff46 	bl	80006a0 <_test_assert_sequence>
 8005814:	2800      	cmp	r0, #0
 8005816:	f47f aeee 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
  }

  /* [9.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800581a:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800581c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8005820:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8005822:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8005824:	f7ff fdf4 	bl	8005410 <chMBPost.constprop.20>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005828:	f647 1110 	movw	r1, #30992	; 0x7910
 800582c:	f1d0 0001 	rsbs	r0, r0, #1
 8005830:	bf38      	it	cc
 8005832:	2000      	movcc	r0, #0
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8005834:	f241 3530 	movw	r5, #4912	; 0x1330
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005838:	f6c0 0100 	movt	r1, #2048	; 0x800
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [9.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800583c:	f2c2 0500 	movt	r5, #8192	; 0x2000
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005840:	f7fa ff5e 	bl	8000700 <_test_assert>
 8005844:	2800      	cmp	r0, #0
 8005846:	f47f aed6 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800584a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800584e:	a801      	add	r0, sp, #4
 8005850:	f7ff fe6e 	bl	8005530 <chMBFetch.constprop.16>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005854:	f647 1110 	movw	r1, #30992	; 0x7910
 8005858:	f1d0 0001 	rsbs	r0, r0, #1
 800585c:	bf38      	it	cc
 800585e:	2000      	movcc	r0, #0
 8005860:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005864:	f7fa ff4c 	bl	8000700 <_test_assert>
 8005868:	2800      	cmp	r0, #0
 800586a:	f47f aec4 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
  }

  /* [9.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 800586e:	2307      	movs	r3, #7
 8005870:	602b      	str	r3, [r5, #0]
 8005872:	2320      	movs	r3, #32
 8005874:	f383 8811 	msr	BASEPRI, r3
 8005878:	6861      	ldr	r1, [r4, #4]
 800587a:	6822      	ldr	r2, [r4, #0]
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800587c:	6923      	ldr	r3, [r4, #16]
 */
static inline cnt_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (cnt_t)(mbp->top - mbp->buffer);
 800587e:	1a8a      	subs	r2, r1, r2
 */
static inline cnt_t chMBGetFreeCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8005880:	ebc3 00a2 	rsb	r0, r3, r2, asr #2
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005884:	1f06      	subs	r6, r0, #4
 8005886:	4270      	negs	r0, r6
 8005888:	f247 7138 	movw	r1, #30520	; 0x7738
 800588c:	4170      	adcs	r0, r6
 800588e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005892:	f7fa ff35 	bl	8000700 <_test_assert>
 8005896:	2800      	cmp	r0, #0
 8005898:	f47f aeaa 	bne.w	80055f0 <test_009_002_execute.10105+0x40>
 800589c:	f380 8811 	msr	BASEPRI, r0
 80058a0:	2320      	movs	r3, #32
 80058a2:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80058a6:	6920      	ldr	r0, [r4, #16]
 80058a8:	f647 11d4 	movw	r1, #31188	; 0x79d4
 80058ac:	f1d0 0001 	rsbs	r0, r0, #1
 80058b0:	bf38      	it	cc
 80058b2:	2000      	movcc	r0, #0
 80058b4:	f6c0 0100 	movt	r1, #2048	; 0x800
 80058b8:	f7fa ff22 	bl	8000700 <_test_assert>
 80058bc:	2800      	cmp	r0, #0
 80058be:	f47f ae97 	bne.w	80055f0 <test_009_002_execute.10105+0x40>
 80058c2:	f380 8811 	msr	BASEPRI, r0
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80058c6:	6820      	ldr	r0, [r4, #0]
 80058c8:	68a3      	ldr	r3, [r4, #8]
 80058ca:	f647 11e0 	movw	r1, #31200	; 0x79e0
 80058ce:	1ac5      	subs	r5, r0, r3
 80058d0:	4268      	negs	r0, r5
 80058d2:	4168      	adcs	r0, r5
 80058d4:	f640 0438 	movw	r4, #2104	; 0x838
 80058d8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80058dc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80058e0:	f7fa ff0e 	bl	8000700 <_test_assert>
 80058e4:	2800      	cmp	r0, #0
 80058e6:	f47f ae86 	bne.w	80055f6 <test_009_002_execute.10105+0x46>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80058ea:	6820      	ldr	r0, [r4, #0]
 80058ec:	68e3      	ldr	r3, [r4, #12]
 80058ee:	f647 2104 	movw	r1, #31236	; 0x7a04
 80058f2:	1ac4      	subs	r4, r0, r3
 80058f4:	4260      	negs	r0, r4
 80058f6:	4160      	adcs	r0, r4
 80058f8:	f6c0 0100 	movt	r1, #2048	; 0x800
 80058fc:	f7fa ff00 	bl	8000700 <_test_assert>
 8005900:	e679      	b.n	80055f6 <test_009_002_execute.10105+0x46>
 8005902:	bf00      	nop
 8005904:	20000850 	.word	0x20000850
 8005908:	20000858 	.word	0x20000858
 800590c:	f3af 8000 	nop.w

08005910 <chThdCreateStatic.constprop.52>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8005910:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005914:	4604      	mov	r4, r0
 8005916:	2020      	movs	r0, #32
 8005918:	f380 8811 	msr	BASEPRI, r0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800591c:	f241 26c0 	movw	r6, #4800	; 0x12c0
 8005920:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8005924:	f8d6 b014 	ldr.w	fp, [r6, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005928:	f240 2e65 	movw	lr, #613	; 0x265
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800592c:	f647 20e8 	movw	r0, #31464	; 0x7ae8
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005930:	2500      	movs	r5, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8005932:	f504 7780 	add.w	r7, r4, #256	; 0x100
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005936:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
 800593a:	f6c0 0e00 	movt	lr, #2048	; 0x800
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 800593e:	f504 7296 	add.w	r2, r4, #300	; 0x12c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8005942:	f504 7c94 	add.w	ip, r4, #296	; 0x128
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005946:	f104 0adc 	add.w	sl, r4, #220	; 0xdc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800594a:	f04f 0902 	mov.w	r9, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800594e:	f04f 0801 	mov.w	r8, #1
  tp->name      = name;
 8005952:	f6c0 0000 	movt	r0, #2048	; 0x800
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8005956:	f8c4 1108 	str.w	r1, [r4, #264]	; 0x108
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800595a:	f8c4 113c 	str.w	r1, [r4, #316]	; 0x13c
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800595e:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8005962:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005966:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 800596a:	f8c4 a10c 	str.w	sl, [r4, #268]	; 0x10c
 800596e:	f8c4 e0fc 	str.w	lr, [r4, #252]	; 0xfc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005972:	f884 9120 	strb.w	r9, [r4, #288]	; 0x120
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005976:	f884 8122 	strb.w	r8, [r4, #290]	; 0x122
  tp->name      = name;
  REG_INSERT(tp);
 800597a:	f8c4 6110 	str.w	r6, [r4, #272]	; 0x110
 800597e:	f8c4 b114 	str.w	fp, [r4, #276]	; 0x114
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005982:	f884 5121 	strb.w	r5, [r4, #289]	; 0x121
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005986:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800598a:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800598e:	4638      	mov	r0, r7
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005990:	f8cb 7010 	str.w	r7, [fp, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005994:	4629      	mov	r1, r5
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005996:	f8c4 c128 	str.w	ip, [r4, #296]	; 0x128
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800599a:	f8c4 212c 	str.w	r2, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 800599e:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80059a2:	6177      	str	r7, [r6, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80059a4:	f7fb f9bc 	bl	8000d20 <chSchWakeupS>
 80059a8:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 80059ac:	4638      	mov	r0, r7
 80059ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80059b2:	bf00      	nop
 80059b4:	f3af 8000 	nop.w
 80059b8:	f3af 8000 	nop.w
 80059bc:	f3af 8000 	nop.w

080059c0 <test_005_005_execute.9271>:

static void test_005_005_teardown(void) {
  test_wait_threads();
}

static void test_005_005_execute(void) {
 80059c0:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80059c2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80059c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80059ca:	699b      	ldr	r3, [r3, #24]

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80059cc:	f241 3530 	movw	r5, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80059d0:	6899      	ldr	r1, [r3, #8]
 80059d2:	f640 1050 	movw	r0, #2384	; 0x950
 80059d6:	f640 62e1 	movw	r2, #3809	; 0xee1
 80059da:	3101      	adds	r1, #1

static void test_005_005_execute(void) {

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80059dc:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80059e0:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80059e2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80059e6:	2300      	movs	r3, #0
 80059e8:	f2c2 0000 	movt	r0, #8192	; 0x2000

static void test_005_005_execute(void) {

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80059ec:	602c      	str	r4, [r5, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80059ee:	f7ff ff8f 	bl	8005910 <chThdCreateStatic.constprop.52>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80059f2:	f640 74c8 	movw	r4, #4040	; 0xfc8
 80059f6:	f640 73d4 	movw	r3, #4052	; 0xfd4
 80059fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [5.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80059fe:	2202      	movs	r2, #2
 8005a00:	f2c2 0400 	movt	r4, #8192	; 0x2000

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8005a04:	6018      	str	r0, [r3, #0]
  }

  /* [5.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 8005a06:	602a      	str	r2, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8005a08:	f7fd f8fa 	bl	8002c00 <chSemSignalWait.constprop.45>
 8005a0c:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8005a0e:	f247 6198 	movw	r1, #30360	; 0x7698
 8005a12:	ebb0 0e04 	subs.w	lr, r0, r4
 8005a16:	f1de 0000 	rsbs	r0, lr, #0
 8005a1a:	eb50 000e 	adcs.w	r0, r0, lr
 8005a1e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005a22:	f7fa fe6d 	bl	8000700 <_test_assert>
 8005a26:	b100      	cbz	r0, 8005a2a <test_005_005_execute.9271+0x6a>
 8005a28:	bd38      	pop	{r3, r4, r5, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 8005a2a:	68a0      	ldr	r0, [r4, #8]
 8005a2c:	f647 118c 	movw	r1, #31116	; 0x798c
 8005a30:	f1d0 0001 	rsbs	r0, r0, #1
 8005a34:	bf38      	it	cc
 8005a36:	2000      	movcc	r0, #0
 8005a38:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005a3c:	f7fa fe60 	bl	8000700 <_test_assert>
 8005a40:	2800      	cmp	r0, #0
 8005a42:	d1f1      	bne.n	8005a28 <test_005_005_execute.9271+0x68>
  }

  /* [5.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 8005a44:	2303      	movs	r3, #3
 8005a46:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8005a48:	f7fd f8da 	bl	8002c00 <chSemSignalWait.constprop.45>
 8005a4c:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8005a4e:	f247 6198 	movw	r1, #30360	; 0x7698
 8005a52:	1b05      	subs	r5, r0, r4
 8005a54:	4268      	negs	r0, r5
 8005a56:	4168      	adcs	r0, r5
 8005a58:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005a5c:	f7fa fe50 	bl	8000700 <_test_assert>
 8005a60:	2800      	cmp	r0, #0
 8005a62:	d1e1      	bne.n	8005a28 <test_005_005_execute.9271+0x68>
    test_assert(sem1.cnt == 0, "counter not zero");
 8005a64:	68a0      	ldr	r0, [r4, #8]
 8005a66:	f647 118c 	movw	r1, #31116	; 0x798c
 8005a6a:	f1d0 0001 	rsbs	r0, r0, #1
 8005a6e:	bf38      	it	cc
 8005a70:	2000      	movcc	r0, #0
 8005a72:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 8005a76:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     counter value must be one on exit.*/
  test_set_step(3);
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
 8005a7a:	f7fa be41 	b.w	8000700 <_test_assert>
 8005a7e:	bf00      	nop

08005a80 <test_009_002_setup.10101>:
 * - [9.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_009_002_setup(void) {
 8005a80:	b430      	push	{r4, r5}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8005a82:	f640 0338 	movw	r3, #2104	; 0x838
 8005a86:	f640 72b8 	movw	r2, #4024	; 0xfb8
 8005a8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a8e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005a92:	f103 0418 	add.w	r4, r3, #24
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8005a96:	f102 0510 	add.w	r5, r2, #16
 8005a9a:	f103 0020 	add.w	r0, r3, #32
  mbp->cnt    = (cnt_t)0;
 8005a9e:	2100      	movs	r1, #0
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8005aa0:	605d      	str	r5, [r3, #4]
 8005aa2:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8005aa4:	61dc      	str	r4, [r3, #28]
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8005aa6:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 8005aa8:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 8005aaa:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005aac:	6218      	str	r0, [r3, #32]
  tqp->prev = (thread_t *)tqp;
 8005aae:	6258      	str	r0, [r3, #36]	; 0x24
  mbp->top    = &buf[n];
  mbp->cnt    = (cnt_t)0;
 8005ab0:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8005ab2:	7519      	strb	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8005ab4:	bc30      	pop	{r4, r5}
 8005ab6:	4770      	bx	lr
 8005ab8:	f3af 8000 	nop.w
 8005abc:	f3af 8000 	nop.w

08005ac0 <test_009_003_setup.10099>:
 *   active state.
 * - [9.3.4] Testing chMBFetch() and chMBFetchI() timeout.
 * .
 */

static void test_009_003_setup(void) {
 8005ac0:	b430      	push	{r4, r5}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8005ac2:	f640 0338 	movw	r3, #2104	; 0x838
 8005ac6:	f640 72b8 	movw	r2, #4024	; 0xfb8
 8005aca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ace:	f2c2 0200 	movt	r2, #8192	; 0x2000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005ad2:	f103 0418 	add.w	r4, r3, #24
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8005ad6:	f102 0510 	add.w	r5, r2, #16
 8005ada:	f103 0020 	add.w	r0, r3, #32
  mbp->cnt    = (cnt_t)0;
 8005ade:	2100      	movs	r1, #0
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8005ae0:	605d      	str	r5, [r3, #4]
 8005ae2:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8005ae4:	61dc      	str	r4, [r3, #28]
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8005ae6:	601a      	str	r2, [r3, #0]
  mbp->rdptr  = buf;
 8005ae8:	60da      	str	r2, [r3, #12]
  mbp->wrptr  = buf;
 8005aea:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005aec:	6218      	str	r0, [r3, #32]
  tqp->prev = (thread_t *)tqp;
 8005aee:	6258      	str	r0, [r3, #36]	; 0x24
  mbp->top    = &buf[n];
  mbp->cnt    = (cnt_t)0;
 8005af0:	6119      	str	r1, [r3, #16]
  mbp->reset  = false;
 8005af2:	7519      	strb	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8005af4:	bc30      	pop	{r4, r5}
 8005af6:	4770      	bx	lr
 8005af8:	f3af 8000 	nop.w
 8005afc:	f3af 8000 	nop.w

08005b00 <test_012_001_setup.10525>:
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8005b00:	f640 1250 	movw	r2, #2384	; 0x950
 *   freeing memory.
 * - [12.1.7] Getting heap info again for verification.
 * .
 */

static void test_012_001_setup(void) {
 8005b04:	b410      	push	{r4}

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8005b06:	2100      	movs	r1, #0
  H_NEXT(&heapp->header) = hp;
 8005b08:	f2c2 0200 	movt	r2, #8192	; 0x2000
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8005b0c:	24cc      	movs	r4, #204	; 0xcc

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8005b0e:	f640 1320 	movw	r3, #2336	; 0x920
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8005b12:	e882 0012 	stmia.w	r2, {r1, r4}

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8005b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005b1a:	f103 0010 	add.w	r0, r3, #16
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
 8005b1e:	60d9      	str	r1, [r3, #12]
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8005b20:	609a      	str	r2, [r3, #8]
 8005b22:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8005b24:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8005b26:	6019      	str	r1, [r3, #0]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8005b28:	6199      	str	r1, [r3, #24]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 8005b2a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005b2e:	4770      	bx	lr

08005b30 <test_013_011_setup.10703>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005b30:	f640 73ec 	movw	r3, #4076	; 0xfec
 8005b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b38:	2200      	movs	r2, #0
 8005b3a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8005b3c:	605b      	str	r3, [r3, #4]
 8005b3e:	609a      	str	r2, [r3, #8]
 8005b40:	4770      	bx	lr
 8005b42:	bf00      	nop
 8005b44:	f3af 8000 	nop.w
 8005b48:	f3af 8000 	nop.w
 8005b4c:	f3af 8000 	nop.w

08005b50 <chThdRelease>:
 8005b50:	2320      	movs	r3, #32
 8005b52:	f383 8811 	msr	BASEPRI, r3
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8005b56:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 8005b5a:	3b01      	subs	r3, #1
 8005b5c:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005b60:	6a03      	ldr	r3, [r0, #32]
 8005b62:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8005b66:	2b0f      	cmp	r3, #15
 8005b68:	d003      	beq.n	8005b72 <chThdRelease+0x22>
 8005b6a:	2300      	movs	r3, #0
 8005b6c:	f383 8811 	msr	BASEPRI, r3
 8005b70:	4770      	bx	lr
    REG_REMOVE(tp);
 8005b72:	6902      	ldr	r2, [r0, #16]
 8005b74:	6943      	ldr	r3, [r0, #20]
 8005b76:	2100      	movs	r1, #0
 8005b78:	611a      	str	r2, [r3, #16]
 8005b7a:	6902      	ldr	r2, [r0, #16]
 8005b7c:	6153      	str	r3, [r2, #20]
 8005b7e:	f381 8811 	msr	BASEPRI, r1
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8005b82:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8005b86:	f003 0303 	and.w	r3, r3, #3
 8005b8a:	2b01      	cmp	r3, #1
 8005b8c:	d002      	beq.n	8005b94 <chThdRelease+0x44>
 8005b8e:	2b02      	cmp	r3, #2
 8005b90:	d003      	beq.n	8005b9a <chThdRelease+0x4a>
 8005b92:	4770      	bx	lr
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 8005b94:	69c0      	ldr	r0, [r0, #28]
 8005b96:	f7fb bb73 	b.w	8001280 <chHeapFree>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8005b9a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8005b9c:	69c2      	ldr	r2, [r0, #28]
 8005b9e:	2120      	movs	r1, #32
 8005ba0:	f381 8811 	msr	BASEPRI, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005ba4:	6819      	ldr	r1, [r3, #0]
 8005ba6:	2000      	movs	r0, #0
 8005ba8:	6011      	str	r1, [r2, #0]
  mp->next = php;
 8005baa:	601a      	str	r2, [r3, #0]
 8005bac:	f380 8811 	msr	BASEPRI, r0
 8005bb0:	4770      	bx	lr
 8005bb2:	bf00      	nop
 8005bb4:	f3af 8000 	nop.w
 8005bb8:	f3af 8000 	nop.w
 8005bbc:	f3af 8000 	nop.w

08005bc0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8005bc0:	b538      	push	{r3, r4, r5, lr}
 8005bc2:	4604      	mov	r4, r0
 8005bc4:	2320      	movs	r3, #32
 8005bc6:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 8005bca:	f890 3020 	ldrb.w	r3, [r0, #32]
 8005bce:	2b0f      	cmp	r3, #15
 8005bd0:	d00a      	beq.n	8005be8 <chThdWait+0x28>
    list_insert(currp, &tp->waiting);
 8005bd2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005bd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
 8005bda:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8005bdc:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8005bde:	2009      	movs	r0, #9
 8005be0:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 8005be2:	62a3      	str	r3, [r4, #40]	; 0x28
 8005be4:	f7fb f8f4 	bl	8000dd0 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8005be8:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8005bea:	2300      	movs	r3, #0
 8005bec:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8005bf0:	4620      	mov	r0, r4
 8005bf2:	f7ff ffad 	bl	8005b50 <chThdRelease>
#endif

  return msg;
}
 8005bf6:	4628      	mov	r0, r5
 8005bf8:	bd38      	pop	{r3, r4, r5, pc}
 8005bfa:	bf00      	nop
 8005bfc:	f3af 8000 	nop.w

08005c00 <test_wait_threads>:
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8005c00:	b570      	push	{r4, r5, r6, lr}
 8005c02:	f640 74d4 	movw	r4, #4052	; 0xfd4
 8005c06:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8005c0a:	f104 0514 	add.w	r5, r4, #20
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8005c0e:	2600      	movs	r6, #0
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8005c10:	f854 3b04 	ldr.w	r3, [r4], #4
      chThdWait(threads[i]);
 8005c14:	4618      	mov	r0, r3
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8005c16:	b11b      	cbz	r3, 8005c20 <test_wait_threads+0x20>
      chThdWait(threads[i]);
 8005c18:	f7ff ffd2 	bl	8005bc0 <chThdWait>
      threads[i] = NULL;
 8005c1c:	f844 6c04 	str.w	r6, [r4, #-4]
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8005c20:	42ac      	cmp	r4, r5
 8005c22:	d1f5      	bne.n	8005c10 <test_wait_threads+0x10>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8005c24:	bd70      	pop	{r4, r5, r6, pc}
 8005c26:	bf00      	nop
 8005c28:	f3af 8000 	nop.w
 8005c2c:	f3af 8000 	nop.w

08005c30 <test_008_004_execute.9884>:

static void test_008_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_008_004_execute(void) {
 8005c30:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8005c32:	f241 3430 	movw	r4, #4912	; 0x1330
 8005c36:	2301      	movs	r3, #1
 8005c38:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    chEvtAddEvents(5);
 8005c3c:	2005      	movs	r0, #5
static void test_008_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8005c3e:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8005c40:	f7fa ff5e 	bl	8000b00 <chEvtAddEvents>
  }

  /* [8.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8005c44:	2302      	movs	r3, #2
 8005c46:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8005c48:	f7fd f8b2 	bl	8002db0 <chEvtWaitAny.constprop.30>
    test_assert(m == 5, "unexpected pending bit");
 8005c4c:	1f42      	subs	r2, r0, #5
 8005c4e:	4250      	negs	r0, r2
 8005c50:	f647 01d8 	movw	r1, #30936	; 0x78d8
 8005c54:	4150      	adcs	r0, r2
 8005c56:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005c5a:	f7fa fd51 	bl	8000700 <_test_assert>
 8005c5e:	b100      	cbz	r0, 8005c62 <test_008_004_execute.9884+0x32>
 8005c60:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005c62:	f7fd f83d 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8005c66:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8005c6a:	f1d0 0001 	rsbs	r0, r0, #1
 8005c6e:	bf38      	it	cc
 8005c70:	2000      	movcc	r0, #0
 8005c72:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005c76:	f7fa fd43 	bl	8000700 <_test_assert>
 8005c7a:	2800      	cmp	r0, #0
 8005c7c:	d1f0      	bne.n	8005c60 <test_008_004_execute.9884+0x30>
  }

  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8005c7e:	2303      	movs	r3, #3
 8005c80:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8005c82:	f7ff f975 	bl	8004f70 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8005c86:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005c8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c8e:	699b      	ldr	r3, [r3, #24]
 8005c90:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005c92:	6899      	ldr	r1, [r3, #8]
 8005c94:	f640 1050 	movw	r0, #2384	; 0x950
 8005c98:	f641 42f1 	movw	r2, #7409	; 0x1cf1
 8005c9c:	3901      	subs	r1, #1
 8005c9e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005ca2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005ca6:	f7ff fe33 	bl	8005910 <chThdCreateStatic.constprop.52>
 8005caa:	f640 73d4 	movw	r3, #4052	; 0xfd4
 8005cae:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8005cb2:	2204      	movs	r2, #4
 8005cb4:	6022      	str	r2, [r4, #0]
  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005cb6:	6018      	str	r0, [r3, #0]
  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8005cb8:	f7fd f87a 	bl	8002db0 <chEvtWaitAny.constprop.30>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8005cbc:	f105 0134 	add.w	r1, r5, #52	; 0x34
  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8005cc0:	4604      	mov	r4, r0

  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8005cc2:	f105 0032 	add.w	r0, r5, #50	; 0x32
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8005cc6:	b280      	uxth	r0, r0
 8005cc8:	b289      	uxth	r1, r1
 8005cca:	f7fd f909 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8005cce:	2800      	cmp	r0, #0
 8005cd0:	d1c6      	bne.n	8005c60 <test_008_004_execute.9884+0x30>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8005cd2:	1e63      	subs	r3, r4, #1
 8005cd4:	4258      	negs	r0, r3
 8005cd6:	f647 21f0 	movw	r1, #31472	; 0x7af0
 8005cda:	4158      	adcs	r0, r3
 8005cdc:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005ce0:	f7fa fd0e 	bl	8000700 <_test_assert>
 8005ce4:	2800      	cmp	r0, #0
 8005ce6:	d1bb      	bne.n	8005c60 <test_008_004_execute.9884+0x30>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005ce8:	f7fc fffa 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8005cec:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8005cf0:	f1d0 0001 	rsbs	r0, r0, #1
 8005cf4:	bf38      	it	cc
 8005cf6:	2000      	movcc	r0, #0
 8005cf8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005cfc:	f7fa fd00 	bl	8000700 <_test_assert>
 8005d00:	2800      	cmp	r0, #0
 8005d02:	d1ad      	bne.n	8005c60 <test_008_004_execute.9884+0x30>
    test_wait_threads();
  }
}
 8005d04:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8005d08:	f7ff bf7a 	b.w	8005c00 <test_wait_threads>
 8005d0c:	f3af 8000 	nop.w

08005d10 <test_008_003_execute.9888>:

static void test_008_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_008_003_execute(void) {
 8005d10:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8005d12:	f241 3430 	movw	r4, #4912	; 0x1330
 8005d16:	2301      	movs	r3, #1
 8005d18:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    chEvtAddEvents(7);
 8005d1c:	2007      	movs	r0, #7
static void test_008_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8005d1e:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(7);
 8005d20:	f7fa feee 	bl	8000b00 <chEvtAddEvents>
  }

  /* [8.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 8005d24:	2302      	movs	r3, #2
 8005d26:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8005d28:	f7fd f822 	bl	8002d70 <chEvtWaitOne.constprop.31>
    test_assert(m == 1, "single event error");
 8005d2c:	f1b0 0c01 	subs.w	ip, r0, #1
 8005d30:	f1dc 0000 	rsbs	r0, ip, #0
 8005d34:	f647 3104 	movw	r1, #31492	; 0x7b04
 8005d38:	eb50 000c 	adcs.w	r0, r0, ip
 8005d3c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005d40:	f7fa fcde 	bl	8000700 <_test_assert>
 8005d44:	b100      	cbz	r0, 8005d48 <test_008_003_execute.9888+0x38>
 8005d46:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 8005d48:	f7fd f812 	bl	8002d70 <chEvtWaitOne.constprop.31>
    test_assert(m == 2, "single event error");
 8005d4c:	f1b0 0e02 	subs.w	lr, r0, #2
 8005d50:	f1de 0000 	rsbs	r0, lr, #0
 8005d54:	f647 3104 	movw	r1, #31492	; 0x7b04
 8005d58:	eb50 000e 	adcs.w	r0, r0, lr
 8005d5c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005d60:	f7fa fcce 	bl	8000700 <_test_assert>
 8005d64:	2800      	cmp	r0, #0
 8005d66:	d1ee      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
    m = chEvtWaitOne(ALL_EVENTS);
 8005d68:	f7fd f802 	bl	8002d70 <chEvtWaitOne.constprop.31>
    test_assert(m == 4, "single event error");
 8005d6c:	1f05      	subs	r5, r0, #4
 8005d6e:	4268      	negs	r0, r5
 8005d70:	f647 3104 	movw	r1, #31492	; 0x7b04
 8005d74:	4168      	adcs	r0, r5
 8005d76:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005d7a:	f7fa fcc1 	bl	8000700 <_test_assert>
 8005d7e:	2800      	cmp	r0, #0
 8005d80:	d1e1      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005d82:	f7fc ffad 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8005d86:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8005d8a:	f1d0 0001 	rsbs	r0, r0, #1
 8005d8e:	bf38      	it	cc
 8005d90:	2000      	movcc	r0, #0
 8005d92:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005d96:	f7fa fcb3 	bl	8000700 <_test_assert>
 8005d9a:	2800      	cmp	r0, #0
 8005d9c:	d1d3      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
  }

  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8005d9e:	2303      	movs	r3, #3
 8005da0:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8005da2:	f7ff f8e5 	bl	8004f70 <test_wait_tick>
 8005da6:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005daa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dae:	699b      	ldr	r3, [r3, #24]
 8005db0:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005db2:	6899      	ldr	r1, [r3, #8]
 8005db4:	f640 1050 	movw	r0, #2384	; 0x950
 8005db8:	f641 42f1 	movw	r2, #7409	; 0x1cf1
 8005dbc:	3901      	subs	r1, #1
 8005dbe:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005dc2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005dc6:	f7ff fda3 	bl	8005910 <chThdCreateStatic.constprop.52>
 8005dca:	f640 73d4 	movw	r3, #4052	; 0xfd4
 8005dce:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8005dd2:	2204      	movs	r2, #4
 8005dd4:	6022      	str	r2, [r4, #0]
  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005dd6:	6018      	str	r0, [r3, #0]
  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8005dd8:	f7fc ffca 	bl	8002d70 <chEvtWaitOne.constprop.31>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8005ddc:	f105 0134 	add.w	r1, r5, #52	; 0x34
  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8005de0:	4604      	mov	r4, r0

  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8005de2:	f105 0032 	add.w	r0, r5, #50	; 0x32
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8005de6:	b280      	uxth	r0, r0
 8005de8:	b289      	uxth	r1, r1
 8005dea:	f7fd f879 	bl	8002ee0 <_test_assert_time_window.constprop.2>
 8005dee:	2800      	cmp	r0, #0
 8005df0:	d1a9      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8005df2:	3c01      	subs	r4, #1
 8005df4:	4260      	negs	r0, r4
 8005df6:	f647 21f0 	movw	r1, #31472	; 0x7af0
 8005dfa:	4160      	adcs	r0, r4
 8005dfc:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005e00:	f7fa fc7e 	bl	8000700 <_test_assert>
 8005e04:	2800      	cmp	r0, #0
 8005e06:	d19e      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8005e08:	f7fc ff6a 	bl	8002ce0 <chEvtGetAndClearEvents.constprop.35>
    test_assert(m == 0, "stuck event");
 8005e0c:	f647 01f0 	movw	r1, #30960	; 0x78f0
 8005e10:	f1d0 0001 	rsbs	r0, r0, #1
 8005e14:	bf38      	it	cc
 8005e16:	2000      	movcc	r0, #0
 8005e18:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005e1c:	f7fa fc70 	bl	8000700 <_test_assert>
 8005e20:	2800      	cmp	r0, #0
 8005e22:	d190      	bne.n	8005d46 <test_008_003_execute.9888+0x36>
    test_wait_threads();
  }
}
 8005e24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8005e28:	f7ff beea 	b.w	8005c00 <test_wait_threads>
 8005e2c:	f3af 8000 	nop.w

08005e30 <test_007_001_execute.9621>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_007_001_execute(void) {
 8005e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005e32:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005e36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e3a:	699b      	ldr	r3, [r3, #24]
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8005e3c:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005e40:	6899      	ldr	r1, [r3, #8]
 8005e42:	f640 1050 	movw	r0, #2384	; 0x950
 8005e46:	f640 7271 	movw	r2, #3953	; 0xf71
static void test_007_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8005e4a:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005e4e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005e52:	3101      	adds	r1, #1
static void test_007_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8005e54:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005e56:	f2c2 0000 	movt	r0, #8192	; 0x2000
static void test_007_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8005e5a:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005e5c:	f7ff fd58 	bl	8005910 <chThdCreateStatic.constprop.52>
 8005e60:	f640 73d4 	movw	r3, #4052	; 0xfd4
 8005e64:	f2c2 0300 	movt	r3, #8192	; 0x2000
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8005e68:	2202      	movs	r2, #2
 8005e6a:	6022      	str	r2, [r4, #0]
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005e6c:	6018      	str	r0, [r3, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8005e6e:	2404      	movs	r4, #4
 8005e70:	2720      	movs	r7, #32
 8005e72:	2600      	movs	r6, #0
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8005e74:	f7fa ffc4 	bl	8000e00 <chMsgWait>
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_007_001_execute(void) {
  thread_t *tp;
 8005e78:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8005e7a:	f387 8811 	msr	BASEPRI, r7
 8005e7e:	4629      	mov	r1, r5
 8005e80:	f7fa ff4e 	bl	8000d20 <chSchWakeupS>
 8005e84:	f386 8811 	msr	BASEPRI, r6

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 8005e88:	b2e8      	uxtb	r0, r5
 8005e8a:	f7fa fb91 	bl	80005b0 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8005e8e:	3c01      	subs	r4, #1
 8005e90:	d1f0      	bne.n	8005e74 <test_007_001_execute.9621+0x44>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 8005e92:	f7ff feb5 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
  }
}
 8005e96:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8005e9a:	f647 0054 	movw	r0, #30804	; 0x7854
 8005e9e:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8005ea2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005ea6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005eaa:	f7fa bbf9 	b.w	80006a0 <_test_assert_sequence>
 8005eae:	bf00      	nop

08005eb0 <test_006_004_teardown.9492>:
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_006_004_teardown(void) {
  test_wait_threads();
 8005eb0:	f7ff bea6 	b.w	8005c00 <test_wait_threads>
 8005eb4:	f3af 8000 	nop.w
 8005eb8:	f3af 8000 	nop.w
 8005ebc:	f3af 8000 	nop.w

08005ec0 <test_006_009_execute.9494>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_006_009_execute(void) {
 8005ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ec2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005ec6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8005eca:	699b      	ldr	r3, [r3, #24]

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005ecc:	f640 1650 	movw	r6, #2384	; 0x950
 8005ed0:	689f      	ldr	r7, [r3, #8]
 8005ed2:	f2c2 0600 	movt	r6, #8192	; 0x2000
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8005ed6:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005eda:	f241 7231 	movw	r2, #5937	; 0x1731
 8005ede:	f247 6340 	movw	r3, #30272	; 0x7640
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8005ee2:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005ee6:	1c79      	adds	r1, r7, #1
 8005ee8:	4630      	mov	r0, r6
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8005eea:	2502      	movs	r5, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005eec:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005ef0:	f6c0 0300 	movt	r3, #2048	; 0x800
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8005ef4:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005ef6:	f7ff fd0b 	bl	8005910 <chThdCreateStatic.constprop.52>
 8005efa:	f640 75d4 	movw	r5, #4052	; 0xfd4
 8005efe:	f2c2 0500 	movt	r5, #8192	; 0x2000

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005f02:	f242 3271 	movw	r2, #9073	; 0x2371
 8005f06:	f647 0308 	movw	r3, #30728	; 0x7808
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8005f0a:	f04f 0e03 	mov.w	lr, #3

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005f0e:	6028      	str	r0, [r5, #0]

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005f10:	1cb9      	adds	r1, r7, #2
 8005f12:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8005f16:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005f1a:	f6c0 0300 	movt	r3, #2048	; 0x800
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8005f1e:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005f22:	f7ff fcf5 	bl	8005910 <chThdCreateStatic.constprop.52>

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005f26:	f241 12e1 	movw	r2, #4577	; 0x11e1
 8005f2a:	f247 6344 	movw	r3, #30276	; 0x7644
 8005f2e:	1cf9      	adds	r1, r7, #3
 8005f30:	f6c0 0200 	movt	r2, #2048	; 0x800

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005f34:	6068      	str	r0, [r5, #4]

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005f36:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005f3a:	f506 7024 	add.w	r0, r6, #656	; 0x290
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8005f3e:	2604      	movs	r6, #4
 8005f40:	6026      	str	r6, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005f42:	f7ff fce5 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8005f46:	2305      	movs	r3, #5

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005f48:	60a8      	str	r0, [r5, #8]
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8005f4a:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8005f4c:	f7fc fe98 	bl	8002c80 <chCondSignal.constprop.42>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8005f50:	2306      	movs	r3, #6
 8005f52:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8005f54:	f7fc fe94 	bl	8002c80 <chCondSignal.constprop.42>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 8005f58:	2307      	movs	r3, #7
 8005f5a:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8005f5c:	f7ff fe50 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
  }
}
 8005f60:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
  {
    test_wait_threads();
    test_assert_sequence("ABC", "invalid sequence");
 8005f64:	f247 60a8 	movw	r0, #30376	; 0x76a8
 8005f68:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8005f6c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005f70:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005f74:	f7fa bb94 	b.w	80006a0 <_test_assert_sequence>
 8005f78:	f3af 8000 	nop.w
 8005f7c:	f3af 8000 	nop.w

08005f80 <test_006_008_execute.9508>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8005f80:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8005f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8005f88:	699b      	ldr	r3, [r3, #24]
static void test_006_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_006_008_execute(void) {
 8005f8a:	b570      	push	{r4, r5, r6, lr}
 8005f8c:	689d      	ldr	r5, [r3, #8]

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8005f8e:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005f92:	f640 1050 	movw	r0, #2384	; 0x950
 8005f96:	f242 3271 	movw	r2, #9073	; 0x2371
 8005f9a:	f647 13a4 	movw	r3, #31140	; 0x79a4
 8005f9e:	1c69      	adds	r1, r5, #1

static void test_006_008_execute(void) {

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8005fa0:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8005fa4:	2401      	movs	r4, #1
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005fa6:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005faa:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005fae:	f2c2 0000 	movt	r0, #8192	; 0x2000

static void test_006_008_execute(void) {

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8005fb2:	6034      	str	r4, [r6, #0]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005fb4:	f7ff fcac 	bl	8005910 <chThdCreateStatic.constprop.52>
 8005fb8:	f640 74d4 	movw	r4, #4052	; 0xfd4
 8005fbc:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005fc0:	f242 3271 	movw	r2, #9073	; 0x2371
 8005fc4:	f647 0314 	movw	r3, #30740	; 0x7814
  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8005fc8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005fca:	1ca9      	adds	r1, r5, #2
 8005fcc:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005fd0:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005fd4:	482b      	ldr	r0, [pc, #172]	; (8006084 <test_006_008_execute.9508+0x104>)
 8005fd6:	f7ff fc9b 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005fda:	f242 3271 	movw	r2, #9073	; 0x2371
 8005fde:	f647 0308 	movw	r3, #30728	; 0x7808
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8005fe2:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005fe4:	1ce9      	adds	r1, r5, #3
 8005fe6:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005fea:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005fee:	4826      	ldr	r0, [pc, #152]	; (8006088 <test_006_008_execute.9508+0x108>)
 8005ff0:	f7ff fc8e 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8005ff4:	f242 3271 	movw	r2, #9073	; 0x2371
 8005ff8:	f247 6344 	movw	r3, #30276	; 0x7644
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8005ffc:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8005ffe:	1d29      	adds	r1, r5, #4
 8006000:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006004:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006008:	4820      	ldr	r0, [pc, #128]	; (800608c <test_006_008_execute.9508+0x10c>)
 800600a:	f7ff fc81 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800600e:	f242 3271 	movw	r2, #9073	; 0x2371
 8006012:	f247 6340 	movw	r3, #30272	; 0x7640
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8006016:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8006018:	1d69      	adds	r1, r5, #5
 800601a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800601e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006022:	481b      	ldr	r0, [pc, #108]	; (8006090 <test_006_008_execute.9508+0x110>)
 8006024:	f7ff fc74 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8006028:	2302      	movs	r3, #2
 800602a:	6033      	str	r3, [r6, #0]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800602c:	6120      	str	r0, [r4, #16]
 800602e:	2320      	movs	r3, #32
 8006030:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8006034:	f640 0464 	movw	r4, #2148	; 0x864
 8006038:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800603c:	6823      	ldr	r3, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 800603e:	42a3      	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8006040:	bf18      	it	ne
 8006042:	f06f 0501 	mvnne.w	r5, #1
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8006046:	d009      	beq.n	800605c <test_006_008_execute.9508+0xdc>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8006048:	681a      	ldr	r2, [r3, #0]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 800604a:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 800604c:	6054      	str	r4, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800604e:	6022      	str	r2, [r4, #0]
 8006050:	f7fa ff56 	bl	8000f00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8006054:	6823      	ldr	r3, [r4, #0]
 8006056:	6245      	str	r5, [r0, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8006058:	42a3      	cmp	r3, r4
 800605a:	d1f5      	bne.n	8006048 <test_006_008_execute.9508+0xc8>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 800605c:	f7fa fdc0 	bl	8000be0 <chSchRescheduleS>
 8006060:	2300      	movs	r3, #0
 8006062:	f383 8811 	msr	BASEPRI, r3
  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
 8006066:	f7ff fdcb 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  }
}
 800606a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 800606e:	f647 10a0 	movw	r0, #31136	; 0x79a0
 8006072:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8006076:	f6c0 0000 	movt	r0, #2048	; 0x800
 800607a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800607e:	f7fa bb0f 	b.w	80006a0 <_test_assert_sequence>
 8006082:	bf00      	nop
 8006084:	20000a98 	.word	0x20000a98
 8006088:	20000be0 	.word	0x20000be0
 800608c:	20000d28 	.word	0x20000d28
 8006090:	20000e70 	.word	0x20000e70
 8006094:	f3af 8000 	nop.w
 8006098:	f3af 8000 	nop.w
 800609c:	f3af 8000 	nop.w

080060a0 <test_006_007_execute.9510>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80060a0:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80060a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80060a8:	699b      	ldr	r3, [r3, #24]
static void test_006_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_006_007_execute(void) {
 80060aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80060ae:	689f      	ldr	r7, [r3, #8]
  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060b0:	f640 1650 	movw	r6, #2384	; 0x950
 80060b4:	f242 3571 	movw	r5, #9073	; 0x2371
 80060b8:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80060bc:	f6c0 0500 	movt	r5, #2048	; 0x800

static void test_006_007_execute(void) {

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80060c0:	f241 3830 	movw	r8, #4912	; 0x1330
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060c4:	f647 13a4 	movw	r3, #31140	; 0x79a4
 80060c8:	1c79      	adds	r1, r7, #1
 80060ca:	462a      	mov	r2, r5

static void test_006_007_execute(void) {

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80060cc:	f2c2 0800 	movt	r8, #8192	; 0x2000
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060d0:	4630      	mov	r0, r6

static void test_006_007_execute(void) {

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80060d2:	2401      	movs	r4, #1
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060d4:	f6c0 0300 	movt	r3, #2048	; 0x800

static void test_006_007_execute(void) {

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80060d8:	f8c8 4000 	str.w	r4, [r8]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060dc:	f7ff fc18 	bl	8005910 <chThdCreateStatic.constprop.52>
 80060e0:	f640 74d4 	movw	r4, #4052	; 0xfd4
 80060e4:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80060e8:	f647 0314 	movw	r3, #30740	; 0x7814
  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80060ec:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80060ee:	1cb9      	adds	r1, r7, #2
 80060f0:	462a      	mov	r2, r5
 80060f2:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 80060f6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80060fa:	f7ff fc09 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80060fe:	f647 0308 	movw	r3, #30728	; 0x7808
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8006102:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006104:	1cf9      	adds	r1, r7, #3
 8006106:	462a      	mov	r2, r5
 8006108:	f506 7024 	add.w	r0, r6, #656	; 0x290
 800610c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006110:	f7ff fbfe 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8006114:	f247 6344 	movw	r3, #30276	; 0x7644
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006118:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800611a:	1d39      	adds	r1, r7, #4
 800611c:	462a      	mov	r2, r5
 800611e:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8006122:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006126:	f7ff fbf3 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800612a:	f247 6340 	movw	r3, #30272	; 0x7640
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800612e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8006130:	1d79      	adds	r1, r7, #5
 8006132:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 8006136:	462a      	mov	r2, r5
 8006138:	f6c0 0300 	movt	r3, #2048	; 0x800
 800613c:	f7ff fbe8 	bl	8005910 <chThdCreateStatic.constprop.52>
  }

  /* [6.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8006140:	2302      	movs	r3, #2
 8006142:	f8c8 3000 	str.w	r3, [r8]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8006146:	6120      	str	r0, [r4, #16]
 8006148:	2320      	movs	r3, #32
 800614a:	f383 8811 	msr	BASEPRI, r3
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
  {
    chSysLock();
    chCondSignalI(&c1);
 800614e:	f7fc fdaf 	bl	8002cb0 <chCondSignalI.constprop.41>
    chCondSignalI(&c1);
 8006152:	f7fc fdad 	bl	8002cb0 <chCondSignalI.constprop.41>
    chCondSignalI(&c1);
 8006156:	f7fc fdab 	bl	8002cb0 <chCondSignalI.constprop.41>
    chCondSignalI(&c1);
 800615a:	f7fc fda9 	bl	8002cb0 <chCondSignalI.constprop.41>
    chCondSignalI(&c1);
 800615e:	f7fc fda7 	bl	8002cb0 <chCondSignalI.constprop.41>
    chSchRescheduleS();
 8006162:	f7fa fd3d 	bl	8000be0 <chSchRescheduleS>
 8006166:	2300      	movs	r3, #0
 8006168:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_wait_threads();
 800616c:	f7ff fd48 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  }
}
 8006170:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chCondSignalI(&c1);
    chCondSignalI(&c1);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 8006174:	f647 10a0 	movw	r0, #31136	; 0x79a0
 8006178:	f247 61ac 	movw	r1, #30380	; 0x76ac
 800617c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006180:	f6c0 0100 	movt	r1, #2048	; 0x800
 8006184:	f7fa ba8c 	b.w	80006a0 <_test_assert_sequence>
 8006188:	f3af 8000 	nop.w
 800618c:	f3af 8000 	nop.w

08006190 <test_006_001_execute.9512>:

static void test_006_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_006_001_execute(void) {
 8006190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8006192:	f241 27c0 	movw	r7, #4800	; 0x12c0
 8006196:	f2c2 0700 	movt	r7, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800619a:	69bb      	ldr	r3, [r7, #24]
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 800619c:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    chMtxLock(&m1);
 80061a0:	f640 006c 	movw	r0, #2156	; 0x86c
 80061a4:	689d      	ldr	r5, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80061a6:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80061aa:	2302      	movs	r3, #2
  {
    chMtxLock(&m1);
 80061ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80061b0:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 80061b2:	f7fa ffed 	bl	8001190 <chMtxLock>
  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80061b6:	f640 1050 	movw	r0, #2384	; 0x950
 80061ba:	f241 12b1 	movw	r2, #4529	; 0x11b1
 80061be:	f647 13a4 	movw	r3, #31140	; 0x79a4
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80061c2:	2403      	movs	r4, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80061c4:	1c69      	adds	r1, r5, #1
 80061c6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80061ca:	f6c0 0300 	movt	r3, #2048	; 0x800
 80061ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80061d2:	6034      	str	r4, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80061d4:	f7ff fb9c 	bl	8005910 <chThdCreateStatic.constprop.52>
 80061d8:	f640 74d4 	movw	r4, #4052	; 0xfd4
 80061dc:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80061e0:	f241 12b1 	movw	r2, #4529	; 0x11b1
 80061e4:	f647 0314 	movw	r3, #30740	; 0x7814
  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80061e8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80061ea:	1ca9      	adds	r1, r5, #2
 80061ec:	f6c0 0200 	movt	r2, #2048	; 0x800
 80061f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80061f4:	4826      	ldr	r0, [pc, #152]	; (8006290 <test_006_001_execute.9512+0x100>)
 80061f6:	f7ff fb8b 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80061fa:	f241 12b1 	movw	r2, #4529	; 0x11b1
 80061fe:	f647 0308 	movw	r3, #30728	; 0x7808
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006202:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006204:	1ce9      	adds	r1, r5, #3
 8006206:	f6c0 0200 	movt	r2, #2048	; 0x800
 800620a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800620e:	4821      	ldr	r0, [pc, #132]	; (8006294 <test_006_001_execute.9512+0x104>)
 8006210:	f7ff fb7e 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006214:	f241 12b1 	movw	r2, #4529	; 0x11b1
 8006218:	f247 6344 	movw	r3, #30276	; 0x7644
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800621c:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800621e:	1d29      	adds	r1, r5, #4
 8006220:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006224:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006228:	481b      	ldr	r0, [pc, #108]	; (8006298 <test_006_001_execute.9512+0x108>)
 800622a:	f7ff fb71 	bl	8005910 <chThdCreateStatic.constprop.52>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800622e:	f241 12b1 	movw	r2, #4529	; 0x11b1
 8006232:	f247 6340 	movw	r3, #30272	; 0x7640
 8006236:	1d69      	adds	r1, r5, #5
 8006238:	f6c0 0200 	movt	r2, #2048	; 0x800
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800623c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800623e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006242:	4816      	ldr	r0, [pc, #88]	; (800629c <test_006_001_execute.9512+0x10c>)
 8006244:	f7ff fb64 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006248:	6120      	str	r0, [r4, #16]

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 800624a:	f640 006c 	movw	r0, #2156	; 0x86c
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 800624e:	2304      	movs	r3, #4
  {
    chMtxUnlock(&m1);
 8006250:	f2c2 0000 	movt	r0, #8192	; 0x2000
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8006254:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 8006256:	f7fa fefb 	bl	8001050 <chMtxUnlock>
    test_wait_threads();
 800625a:	f7ff fcd1 	bl	8005c00 <test_wait_threads>
 800625e:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8006260:	f247 6148 	movw	r1, #30280	; 0x7648
 8006264:	6898      	ldr	r0, [r3, #8]
 8006266:	f6c0 0100 	movt	r1, #2048	; 0x800
 800626a:	1a2b      	subs	r3, r5, r0
 800626c:	4258      	negs	r0, r3
 800626e:	4158      	adcs	r0, r3
 8006270:	f7fa fa46 	bl	8000700 <_test_assert>
 8006274:	b100      	cbz	r0, 8006278 <test_006_001_execute.9512+0xe8>
 8006276:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 8006278:	f647 10a0 	movw	r0, #31136	; 0x79a0
 800627c:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8006280:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006284:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 8006288:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  test_set_step(4);
  {
    chMtxUnlock(&m1);
    test_wait_threads();
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
    test_assert_sequence("ABCDE", "invalid sequence");
 800628c:	f7fa ba08 	b.w	80006a0 <_test_assert_sequence>
 8006290:	20000a98 	.word	0x20000a98
 8006294:	20000be0 	.word	0x20000be0
 8006298:	20000d28 	.word	0x20000d28
 800629c:	20000e70 	.word	0x20000e70

080062a0 <test_005_006_teardown.9263>:
 *   must not change from "not taken".
 * .
 */

static void test_005_006_teardown(void) {
  test_wait_threads();
 80062a0:	f7ff bcae 	b.w	8005c00 <test_wait_threads>
 80062a4:	f3af 8000 	nop.w
 80062a8:	f3af 8000 	nop.w
 80062ac:	f3af 8000 	nop.w

080062b0 <test_005_005_teardown.9265>:
static void test_005_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_005_005_teardown(void) {
  test_wait_threads();
 80062b0:	f7ff bca6 	b.w	8005c00 <test_wait_threads>
 80062b4:	f3af 8000 	nop.w
 80062b8:	f3af 8000 	nop.w
 80062bc:	f3af 8000 	nop.w

080062c0 <test_005_002_execute.9267>:

static void test_005_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_005_002_execute(void) {
 80062c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80062c4:	f241 27c0 	movw	r7, #4800	; 0x12c0
 80062c8:	f2c2 0700 	movt	r7, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80062cc:	69bb      	ldr	r3, [r7, #24]
  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062ce:	f640 1650 	movw	r6, #2384	; 0x950
 80062d2:	6899      	ldr	r1, [r3, #8]
 80062d4:	f640 65c1 	movw	r5, #3777	; 0xec1
 80062d8:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80062dc:	f6c0 0500 	movt	r5, #2048	; 0x800
static void test_005_002_execute(void) {

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80062e0:	f241 3830 	movw	r8, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062e4:	f247 6340 	movw	r3, #30272	; 0x7640
 80062e8:	462a      	mov	r2, r5
static void test_005_002_execute(void) {

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80062ea:	f2c2 0800 	movt	r8, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062ee:	3105      	adds	r1, #5
 80062f0:	4630      	mov	r0, r6
static void test_005_002_execute(void) {

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80062f2:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062f4:	f6c0 0300 	movt	r3, #2048	; 0x800
static void test_005_002_execute(void) {

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80062f8:	f8c8 4000 	str.w	r4, [r8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80062fc:	f7ff fb08 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006300:	69bb      	ldr	r3, [r7, #24]
 8006302:	f640 74d4 	movw	r4, #4052	; 0xfd4
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8006306:	6899      	ldr	r1, [r3, #8]
  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006308:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800630c:	f247 6344 	movw	r3, #30276	; 0x7644
  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006310:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8006312:	462a      	mov	r2, r5
 8006314:	3101      	adds	r1, #1
 8006316:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 800631a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800631e:	f7ff faf7 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006322:	69ba      	ldr	r2, [r7, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006324:	f647 0308 	movw	r3, #30728	; 0x7808
 8006328:	6891      	ldr	r1, [r2, #8]
 800632a:	f6c0 0300 	movt	r3, #2048	; 0x800
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800632e:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006330:	462a      	mov	r2, r5
 8006332:	3103      	adds	r1, #3
 8006334:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8006338:	f7ff faea 	bl	8005910 <chThdCreateStatic.constprop.52>
 800633c:	69ba      	ldr	r2, [r7, #24]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800633e:	f647 0314 	movw	r3, #30740	; 0x7814
 8006342:	6891      	ldr	r1, [r2, #8]
 8006344:	f6c0 0300 	movt	r3, #2048	; 0x800
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8006348:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800634a:	462a      	mov	r2, r5
 800634c:	3104      	adds	r1, #4
 800634e:	f506 7076 	add.w	r0, r6, #984	; 0x3d8
 8006352:	f7ff fadd 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006356:	69ba      	ldr	r2, [r7, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8006358:	f647 13a4 	movw	r3, #31140	; 0x79a4
 800635c:	6891      	ldr	r1, [r2, #8]
 800635e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006362:	3102      	adds	r1, #2
 8006364:	462a      	mov	r2, r5
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8006366:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8006368:	f506 60a4 	add.w	r0, r6, #1312	; 0x520
 800636c:	f7ff fad0 	bl	8005910 <chThdCreateStatic.constprop.52>

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 8006370:	f640 75c8 	movw	r5, #4040	; 0xfc8
 8006374:	f2c2 0500 	movt	r5, #8192	; 0x2000
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8006378:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800637a:	6120      	str	r0, [r4, #16]

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 800637c:	4628      	mov	r0, r5
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 800637e:	f8c8 3000 	str.w	r3, [r8]
  {
    chSemSignal(&sem1);
 8006382:	f7fa fd05 	bl	8000d90 <chSemSignal>
    chSemSignal(&sem1);
 8006386:	4628      	mov	r0, r5
 8006388:	f7fa fd02 	bl	8000d90 <chSemSignal>
    chSemSignal(&sem1);
 800638c:	4628      	mov	r0, r5
 800638e:	f7fa fcff 	bl	8000d90 <chSemSignal>
    chSemSignal(&sem1);
 8006392:	4628      	mov	r0, r5
 8006394:	f7fa fcfc 	bl	8000d90 <chSemSignal>
    chSemSignal(&sem1);
 8006398:	4628      	mov	r0, r5
 800639a:	f7fa fcf9 	bl	8000d90 <chSemSignal>
    test_wait_threads();
 800639e:	f7ff fc2f 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
#endif
  }
}
 80063a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chSemSignal(&sem1);
    test_wait_threads();
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 80063a6:	f647 10a0 	movw	r0, #31136	; 0x79a0
 80063aa:	f247 61ac 	movw	r1, #30380	; 0x76ac
 80063ae:	f6c0 0000 	movt	r0, #2048	; 0x800
 80063b2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80063b6:	f7fa b973 	b.w	80006a0 <_test_assert_sequence>
 80063ba:	bf00      	nop
 80063bc:	f3af 8000 	nop.w

080063c0 <test_005_004_execute.9279>:

static void test_005_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_005_004_execute(void) {
 80063c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80063c2:	f241 23c0 	movw	r3, #4800	; 0x12c0
 80063c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80063ca:	699b      	ldr	r3, [r3, #24]

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80063cc:	f241 3430 	movw	r4, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80063d0:	6899      	ldr	r1, [r3, #8]
 80063d2:	f640 1050 	movw	r0, #2384	; 0x950
 80063d6:	f640 62c1 	movw	r2, #3777	; 0xec1
 80063da:	f247 6340 	movw	r3, #30272	; 0x7640
}

static void test_005_004_execute(void) {

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80063de:	f2c2 0400 	movt	r4, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80063e2:	3101      	adds	r1, #1
}

static void test_005_004_execute(void) {

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80063e4:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80063e6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80063ea:	f6c0 0300 	movt	r3, #2048	; 0x800
 80063ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
}

static void test_005_004_execute(void) {

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80063f2:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80063f4:	f7ff fa8c 	bl	8005910 <chThdCreateStatic.constprop.52>
 80063f8:	f640 73d4 	movw	r3, #4052	; 0xfd4
 80063fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
  }

  /* [5.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 8006400:	2202      	movs	r2, #2
static void test_005_004_execute(void) {

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8006402:	6018      	str	r0, [r3, #0]
  }

  /* [5.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 8006404:	6022      	str	r2, [r4, #0]
 8006406:	2320      	movs	r3, #32
 8006408:	f383 8811 	msr	BASEPRI, r3
 800640c:	f640 75c8 	movw	r5, #4040	; 0xfc8
 8006410:	f2c2 0500 	movt	r5, #8192	; 0x2000
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
 8006414:	462e      	mov	r6, r5
 8006416:	2402      	movs	r4, #2
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8006418:	2700      	movs	r7, #0
 800641a:	e001      	b.n	8006420 <test_005_004_execute.9279+0x60>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800641c:	3c01      	subs	r4, #1
 800641e:	d00d      	beq.n	800643c <test_005_004_execute.9279+0x7c>
    if (++sp->cnt <= (cnt_t)0) {
 8006420:	68ab      	ldr	r3, [r5, #8]
 8006422:	3301      	adds	r3, #1
 8006424:	2b00      	cmp	r3, #0
 8006426:	60ab      	str	r3, [r5, #8]
 8006428:	dcf8      	bgt.n	800641c <test_005_004_execute.9279+0x5c>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800642a:	6830      	ldr	r0, [r6, #0]

  tqp->next             = tp->queue.next;
 800642c:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800642e:	605e      	str	r6, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8006430:	6033      	str	r3, [r6, #0]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8006432:	f7fa fd65 	bl	8000f00 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8006436:	3c01      	subs	r4, #1
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8006438:	6247      	str	r7, [r0, #36]	; 0x24
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800643a:	d1f1      	bne.n	8006420 <test_005_004_execute.9279+0x60>
  {
    chSysLock();
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
 800643c:	f7fa fbd0 	bl	8000be0 <chSchRescheduleS>
 8006440:	f384 8811 	msr	BASEPRI, r4
    chSysUnlock();
    test_wait_threads();
 8006444:	f7ff fbdc 	bl	8005c00 <test_wait_threads>
 8006448:	2320      	movs	r3, #32
 800644a:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800644e:	68a8      	ldr	r0, [r5, #8]
 8006450:	f647 3118 	movw	r1, #31512	; 0x7b18
 8006454:	1e42      	subs	r2, r0, #1
 8006456:	4250      	negs	r0, r2
 8006458:	4150      	adcs	r0, r2
 800645a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800645e:	f7fa f94f 	bl	8000700 <_test_assert>
 8006462:	b118      	cbz	r0, 800646c <test_005_004_execute.9279+0xac>
 8006464:	2300      	movs	r3, #0
 8006466:	f383 8811 	msr	BASEPRI, r3
 800646a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800646c:	f380 8811 	msr	BASEPRI, r0
    test_assert_sequence("A", "invalid sequence");
 8006470:	f247 6040 	movw	r0, #30272	; 0x7640
 8006474:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8006478:	f6c0 0000 	movt	r0, #2048	; 0x800
 800647c:	f6c0 0100 	movt	r1, #2048	; 0x800
  }
}
 8006480:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
    test_assert_sequence("A", "invalid sequence");
 8006484:	f7fa b90c 	b.w	80006a0 <_test_assert_sequence>
 8006488:	f3af 8000 	nop.w
 800648c:	f3af 8000 	nop.w

08006490 <test_003_002_execute.8791>:
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void test_003_002_execute(void) {
 8006490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8006492:	f241 25c0 	movw	r5, #4800	; 0x12c0
 8006496:	f2c2 0500 	movt	r5, #8192	; 0x2000
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800649a:	69ab      	ldr	r3, [r5, #24]

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 800649c:	f241 3630 	movw	r6, #4912	; 0x1330
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064a0:	6899      	ldr	r1, [r3, #8]
 80064a2:	f640 1050 	movw	r0, #2384	; 0x950
 80064a6:	f240 6221 	movw	r2, #1569	; 0x621
 80064aa:	f647 13a4 	movw	r3, #31140	; 0x79a4
 80064ae:	3905      	subs	r1, #5

static void test_003_002_execute(void) {

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80064b0:	2401      	movs	r4, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064b2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80064b6:	f6c0 0300 	movt	r3, #2048	; 0x800

static void test_003_002_execute(void) {

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80064ba:	f2c2 0600 	movt	r6, #8192	; 0x2000
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064be:	f2c2 0000 	movt	r0, #8192	; 0x2000

static void test_003_002_execute(void) {

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80064c2:	6034      	str	r4, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064c4:	f7ff fa24 	bl	8005910 <chThdCreateStatic.constprop.52>
 80064c8:	69ab      	ldr	r3, [r5, #24]
 80064ca:	f640 74d4 	movw	r4, #4052	; 0xfd4
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80064ce:	6899      	ldr	r1, [r3, #8]

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064d0:	f2c2 0400 	movt	r4, #8192	; 0x2000
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80064d4:	f240 6221 	movw	r2, #1569	; 0x621
 80064d8:	f647 0314 	movw	r3, #30740	; 0x7814

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80064dc:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80064de:	3904      	subs	r1, #4
 80064e0:	f6c0 0200 	movt	r2, #2048	; 0x800
 80064e4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80064e8:	487d      	ldr	r0, [pc, #500]	; (80066e0 <test_003_002_execute.8791+0x250>)
 80064ea:	f7ff fa11 	bl	8005910 <chThdCreateStatic.constprop.52>
 80064ee:	69ab      	ldr	r3, [r5, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80064f0:	f240 6221 	movw	r2, #1569	; 0x621
 80064f4:	6899      	ldr	r1, [r3, #8]
 80064f6:	f647 0308 	movw	r3, #30728	; 0x7808
  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80064fa:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80064fc:	3903      	subs	r1, #3
 80064fe:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006502:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006506:	4877      	ldr	r0, [pc, #476]	; (80066e4 <test_003_002_execute.8791+0x254>)
 8006508:	f7ff fa02 	bl	8005910 <chThdCreateStatic.constprop.52>
 800650c:	69ab      	ldr	r3, [r5, #24]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800650e:	f240 6221 	movw	r2, #1569	; 0x621
 8006512:	6899      	ldr	r1, [r3, #8]
 8006514:	f247 6344 	movw	r3, #30276	; 0x7644
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8006518:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800651a:	3902      	subs	r1, #2
 800651c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006520:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006524:	4870      	ldr	r0, [pc, #448]	; (80066e8 <test_003_002_execute.8791+0x258>)
 8006526:	f7ff f9f3 	bl	8005910 <chThdCreateStatic.constprop.52>
 800652a:	69ab      	ldr	r3, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800652c:	f240 6221 	movw	r2, #1569	; 0x621
 8006530:	6899      	ldr	r1, [r3, #8]
 8006532:	f247 6340 	movw	r3, #30272	; 0x7640
 8006536:	3901      	subs	r1, #1
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006538:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800653a:	f6c0 0200 	movt	r2, #2048	; 0x800
 800653e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006542:	486a      	ldr	r0, [pc, #424]	; (80066ec <test_003_002_execute.8791+0x25c>)
 8006544:	f7ff f9e4 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006548:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 800654a:	f7ff fb59 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800654e:	f647 10a0 	movw	r0, #31136	; 0x79a0
 8006552:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8006556:	f6c0 0000 	movt	r0, #2048	; 0x800
 800655a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800655e:	f7fa f89f 	bl	80006a0 <_test_assert_sequence>
 8006562:	b100      	cbz	r0, 8006566 <test_003_002_execute.8791+0xd6>
 8006564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006566:	69ab      	ldr	r3, [r5, #24]

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006568:	f240 6221 	movw	r2, #1569	; 0x621
 800656c:	6899      	ldr	r1, [r3, #8]
 800656e:	f247 6340 	movw	r3, #30272	; 0x7640
 8006572:	3901      	subs	r1, #1
 8006574:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006578:	f6c0 0300 	movt	r3, #2048	; 0x800
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 800657c:	2702      	movs	r7, #2
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800657e:	485b      	ldr	r0, [pc, #364]	; (80066ec <test_003_002_execute.8791+0x25c>)
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8006580:	6037      	str	r7, [r6, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006582:	f7ff f9c5 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006586:	69ab      	ldr	r3, [r5, #24]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006588:	f240 6221 	movw	r2, #1569	; 0x621
 800658c:	6899      	ldr	r1, [r3, #8]
 800658e:	f247 6344 	movw	r3, #30276	; 0x7644

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006592:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006594:	3902      	subs	r1, #2
 8006596:	f6c0 0200 	movt	r2, #2048	; 0x800
 800659a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800659e:	4852      	ldr	r0, [pc, #328]	; (80066e8 <test_003_002_execute.8791+0x258>)
 80065a0:	f7ff f9b6 	bl	8005910 <chThdCreateStatic.constprop.52>
 80065a4:	69ab      	ldr	r3, [r5, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80065a6:	f240 6221 	movw	r2, #1569	; 0x621
 80065aa:	6899      	ldr	r1, [r3, #8]
 80065ac:	f647 0308 	movw	r3, #30728	; 0x7808
  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80065b0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80065b2:	3903      	subs	r1, #3
 80065b4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80065b8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80065bc:	4849      	ldr	r0, [pc, #292]	; (80066e4 <test_003_002_execute.8791+0x254>)
 80065be:	f7ff f9a7 	bl	8005910 <chThdCreateStatic.constprop.52>
 80065c2:	69ab      	ldr	r3, [r5, #24]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80065c4:	f240 6221 	movw	r2, #1569	; 0x621
 80065c8:	6899      	ldr	r1, [r3, #8]
 80065ca:	f647 0314 	movw	r3, #30740	; 0x7814
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80065ce:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80065d0:	3904      	subs	r1, #4
 80065d2:	f6c0 0200 	movt	r2, #2048	; 0x800
 80065d6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80065da:	4841      	ldr	r0, [pc, #260]	; (80066e0 <test_003_002_execute.8791+0x250>)
 80065dc:	f7ff f998 	bl	8005910 <chThdCreateStatic.constprop.52>
 80065e0:	69ab      	ldr	r3, [r5, #24]
 80065e2:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80065e4:	6899      	ldr	r1, [r3, #8]
 80065e6:	f640 1050 	movw	r0, #2384	; 0x950
 80065ea:	f240 6221 	movw	r2, #1569	; 0x621
 80065ee:	f647 13a4 	movw	r3, #31140	; 0x79a4
 80065f2:	3905      	subs	r1, #5
 80065f4:	f6c0 0200 	movt	r2, #2048	; 0x800
 80065f8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80065fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006600:	f7ff f986 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006604:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 8006606:	f7ff fafb 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800660a:	f647 10a0 	movw	r0, #31136	; 0x79a0
 800660e:	f247 61ac 	movw	r1, #30380	; 0x76ac
 8006612:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006616:	f6c0 0100 	movt	r1, #2048	; 0x800
 800661a:	f7fa f841 	bl	80006a0 <_test_assert_sequence>
 800661e:	2800      	cmp	r0, #0
 8006620:	d1a0      	bne.n	8006564 <test_003_002_execute.8791+0xd4>
 8006622:	69ab      	ldr	r3, [r5, #24]

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8006624:	f240 6221 	movw	r2, #1569	; 0x621
 8006628:	6899      	ldr	r1, [r3, #8]
 800662a:	f647 0314 	movw	r3, #30740	; 0x7814
 800662e:	3904      	subs	r1, #4
 8006630:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006634:	f6c0 0300 	movt	r3, #2048	; 0x800
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 8006638:	2703      	movs	r7, #3
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800663a:	4829      	ldr	r0, [pc, #164]	; (80066e0 <test_003_002_execute.8791+0x250>)
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 800663c:	6037      	str	r7, [r6, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800663e:	f7ff f967 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006642:	69ab      	ldr	r3, [r5, #24]
 8006644:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8006646:	6899      	ldr	r1, [r3, #8]
 8006648:	f640 1050 	movw	r0, #2384	; 0x950
 800664c:	f240 6221 	movw	r2, #1569	; 0x621
 8006650:	f647 13a4 	movw	r3, #31140	; 0x79a4
 8006654:	3905      	subs	r1, #5
 8006656:	f6c0 0200 	movt	r2, #2048	; 0x800
 800665a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800665e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006662:	f7ff f955 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006666:	69ab      	ldr	r3, [r5, #24]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006668:	f240 6221 	movw	r2, #1569	; 0x621
 800666c:	6899      	ldr	r1, [r3, #8]
 800666e:	f247 6340 	movw	r3, #30272	; 0x7640
  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8006672:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006674:	3901      	subs	r1, #1
 8006676:	f6c0 0200 	movt	r2, #2048	; 0x800
 800667a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800667e:	481b      	ldr	r0, [pc, #108]	; (80066ec <test_003_002_execute.8791+0x25c>)
 8006680:	f7ff f946 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006684:	69ab      	ldr	r3, [r5, #24]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006686:	f240 6221 	movw	r2, #1569	; 0x621
 800668a:	6899      	ldr	r1, [r3, #8]
 800668c:	f247 6344 	movw	r3, #30276	; 0x7644
     sequence is tested.*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006690:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006692:	3902      	subs	r1, #2
 8006694:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006698:	f6c0 0300 	movt	r3, #2048	; 0x800
 800669c:	4812      	ldr	r0, [pc, #72]	; (80066e8 <test_003_002_execute.8791+0x258>)
 800669e:	f7ff f937 	bl	8005910 <chThdCreateStatic.constprop.52>
 80066a2:	69ab      	ldr	r3, [r5, #24]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80066a4:	f240 6221 	movw	r2, #1569	; 0x621
 80066a8:	6899      	ldr	r1, [r3, #8]
 80066aa:	f647 0308 	movw	r3, #30728	; 0x7808
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80066ae:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80066b0:	3903      	subs	r1, #3
 80066b2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80066b6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80066ba:	480a      	ldr	r0, [pc, #40]	; (80066e4 <test_003_002_execute.8791+0x254>)
 80066bc:	f7ff f928 	bl	8005910 <chThdCreateStatic.constprop.52>
 80066c0:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 80066c2:	f7ff fa9d 	bl	8005c00 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
  }
}
 80066c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 80066ca:	f647 10a0 	movw	r0, #31136	; 0x79a0
 80066ce:	f247 61ac 	movw	r1, #30380	; 0x76ac
 80066d2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80066d6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80066da:	f7f9 bfe1 	b.w	80006a0 <_test_assert_sequence>
 80066de:	bf00      	nop
 80066e0:	20000a98 	.word	0x20000a98
 80066e4:	20000be0 	.word	0x20000be0
 80066e8:	20000d28 	.word	0x20000d28
 80066ec:	20000e70 	.word	0x20000e70

080066f0 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 80066f0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80066f4:	2200      	movs	r2, #0
 80066f6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80066fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80066fe:	690b      	ldr	r3, [r1, #16]
}

/*
 * Application entry point.
 */
int main(void) {
 8006700:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8006704:	6108      	str	r0, [r1, #16]
 8006706:	610a      	str	r2, [r1, #16]
  rccResetAPB2(0xFFFFFFFF);
 8006708:	68cb      	ldr	r3, [r1, #12]
 800670a:	60c8      	str	r0, [r1, #12]
 800670c:	60ca      	str	r2, [r1, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 800670e:	69cb      	ldr	r3, [r1, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8006710:	f44f 44e0 	mov.w	r4, #28672	; 0x7000
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8006714:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8006718:	61cb      	str	r3, [r1, #28]
  rccEnableBKPInterface(FALSE);
 800671a:	69cb      	ldr	r3, [r1, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800671c:	f2c4 0400 	movt	r4, #16384	; 0x4000
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
  rccEnableBKPInterface(FALSE);
 8006720:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8006724:	61cb      	str	r3, [r1, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8006726:	6825      	ldr	r5, [r4, #0]
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8006728:	f248 705c 	movw	r0, #34652	; 0x875c
 800672c:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 8006730:	6025      	str	r5, [r4, #0]
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8006732:	698c      	ldr	r4, [r1, #24]
 8006734:	b08b      	sub	sp, #44	; 0x2c
 8006736:	f044 047d 	orr.w	r4, r4, #125	; 0x7d
 800673a:	f6c0 0000 	movt	r0, #2048	; 0x800

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 800673e:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  GPIOA->CRH = config->PAData.crh;
 8006742:	f248 4bb8 	movw	fp, #33976	; 0x84b8
  GPIOA->CRL = config->PAData.crl;
 8006746:	f644 3a84 	movw	sl, #19332	; 0x4b84
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800674a:	618c      	str	r4, [r1, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 800674c:	f2c4 0e01 	movt	lr, #16385	; 0x4001
 8006750:	9002      	str	r0, [sp, #8]
  GPIOA->CRH = config->PAData.crh;
 8006752:	f6c8 0b88 	movt	fp, #34952	; 0x8888
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8006756:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
 800675a:	f2cb 4ab3 	movt	sl, #46259	; 0xb4b3
  GPIOB->ODR = config->PBData.odr;
 800675e:	f44f 6740 	mov.w	r7, #3072	; 0xc00
  GPIOB->CRH = config->PBData.crh;
 8006762:	f648 0988 	movw	r9, #34952	; 0x8888
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 8006766:	f44f 5680 	mov.w	r6, #4096	; 0x1000
  GPIOC->CRH = config->PCData.crh;
 800676a:	f648 0833 	movw	r8, #34867	; 0x8833
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 800676e:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 8006772:	f648 0c44 	movw	ip, #34884	; 0x8844
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8006776:	f44f 54c0 	mov.w	r4, #6144	; 0x1800
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 800677a:	f8ce 000c 	str.w	r0, [lr, #12]
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 800677e:	f2c4 0701 	movt	r7, #16385	; 0x4001

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 8006782:	f8ce b004 	str.w	fp, [lr, #4]
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 8006786:	f2c4 0601 	movt	r6, #16385	; 0x4001
  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
 800678a:	f8ce a000 	str.w	sl, [lr]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 800678e:	f2c4 0501 	movt	r5, #16385	; 0x4001
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 8006792:	f04f 3e88 	mov.w	lr, #2290649224	; 0x88888888
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8006796:	f2c4 0401 	movt	r4, #16385	; 0x4001
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 800679a:	f2cb 49b3 	movt	r9, #46259	; 0xb4b3
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
 800679e:	f6c8 0888 	movt	r8, #34952	; 0x8888
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 80067a2:	f6c8 0c88 	movt	ip, #34952	; 0x8888
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 80067a6:	f46f 7a40 	mvn.w	sl, #768	; 0x300
 80067aa:	f241 0320 	movw	r3, #4128	; 0x1020
 80067ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 80067b2:	60f8      	str	r0, [r7, #12]
  GPIOB->CRH = config->PBData.crh;
 80067b4:	f8c7 9004 	str.w	r9, [r7, #4]
  GPIOB->CRL = config->PBData.crl;
 80067b8:	f8c7 e000 	str.w	lr, [r7]
  GPIOC->ODR = config->PCData.odr;
 80067bc:	f8c6 a00c 	str.w	sl, [r6, #12]
  GPIOC->CRH = config->PCData.crh;
 80067c0:	f8c6 8004 	str.w	r8, [r6, #4]
  GPIOC->CRL = config->PCData.crl;
 80067c4:	f8c6 e000 	str.w	lr, [r6]
  GPIOD->ODR = config->PDData.odr;
 80067c8:	60e8      	str	r0, [r5, #12]
  GPIOD->CRH = config->PDData.crh;
 80067ca:	f8c5 e004 	str.w	lr, [r5, #4]
  GPIOD->CRL = config->PDData.crl;
 80067ce:	f8c5 c000 	str.w	ip, [r5]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 80067d2:	60e0      	str	r0, [r4, #12]
 80067d4:	9802      	ldr	r0, [sp, #8]
 80067d6:	4699      	mov	r9, r3
  GPIOE->CRH = config->PEData.crh;
 80067d8:	f8c4 e004 	str.w	lr, [r4, #4]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80067dc:	2610      	movs	r6, #16
  GPIOE->CRL = config->PEData.crl;
 80067de:	f8c4 e000 	str.w	lr, [r4]
 80067e2:	f849 0b04 	str.w	r0, [r9], #4
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80067e6:	f8c3 9004 	str.w	r9, [r3, #4]
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80067ea:	615a      	str	r2, [r3, #20]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80067ec:	639e      	str	r6, [r3, #56]	; 0x38

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80067ee:	69cc      	ldr	r4, [r1, #28]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80067f0:	2701      	movs	r7, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80067f2:	f103 0a0c 	add.w	sl, r3, #12
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80067f6:	f240 3c21 	movw	ip, #801	; 0x321
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 80067fa:	f44f 5960 	mov.w	r9, #14336	; 0x3800
 80067fe:	f8c3 a00c 	str.w	sl, [r3, #12]
  tqp->prev = (thread_t *)tqp;
 8006802:	f8c3 a010 	str.w	sl, [r3, #16]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8006806:	f103 0e54 	add.w	lr, r3, #84	; 0x54
 800680a:	ea44 0a07 	orr.w	sl, r4, r7
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800680e:	f103 0830 	add.w	r8, r3, #48	; 0x30
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8006812:	f103 0464 	add.w	r4, r3, #100	; 0x64
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8006816:	f103 0b74 	add.w	fp, r3, #116	; 0x74
  oqp->q_notify  = onfy;
 800681a:	f6c0 0c00 	movt	ip, #2048	; 0x800
 800681e:	f2c4 0901 	movt	r9, #16385	; 0x4001

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006822:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 8006826:	721f      	strb	r7, [r3, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8006828:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800682a:	f8c3 b040 	str.w	fp, [r3, #64]	; 0x40
  oqp->q_notify  = onfy;
 800682e:	f8c3 c04c 	str.w	ip, [r3, #76]	; 0x4c
 8006832:	f8c3 9074 	str.w	r9, [r3, #116]	; 0x74
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8006836:	f8c3 e018 	str.w	lr, [r3, #24]
  iqp->q_rdptr   = bp;
 800683a:	f8c3 e024 	str.w	lr, [r3, #36]	; 0x24
  iqp->q_wrptr   = bp;
 800683e:	f8c3 e020 	str.w	lr, [r3, #32]
  iqp->q_top     = bp + size;
 8006842:	61dc      	str	r4, [r3, #28]
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8006844:	63dc      	str	r4, [r3, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8006846:	649c      	str	r4, [r3, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8006848:	645c      	str	r4, [r3, #68]	; 0x44
 800684a:	f8c3 8030 	str.w	r8, [r3, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 800684e:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8006852:	62db      	str	r3, [r3, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8006854:	651b      	str	r3, [r3, #80]	; 0x50
 8006856:	f2ce 0504 	movt	r5, #57348	; 0xe004

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800685a:	f8c1 a01c 	str.w	sl, [r1, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800685e:	686c      	ldr	r4, [r5, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006860:	f44f 4e61 	mov.w	lr, #57600	; 0xe100
 8006864:	f444 6b00 	orr.w	fp, r4, #2048	; 0x800
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006868:	f241 23c0 	movw	r3, #4800	; 0x12c0
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 800686c:	f241 3138 	movw	r1, #4920	; 0x1338
 8006870:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006874:	f8c5 b004 	str.w	fp, [r5, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006878:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 800687c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8006880:	f2ce 0e00 	movt	lr, #57344	; 0xe000
 8006884:	f04f 0c80 	mov.w	ip, #128	; 0x80
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006888:	f04f 5880 	mov.w	r8, #268435456	; 0x10000000
 800688c:	f645 5abf 	movw	sl, #23999	; 0x5dbf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006890:	f64f 79ff 	movw	r9, #65535	; 0xffff
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006894:	f44f 456d 	mov.w	r5, #60672	; 0xed00

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006898:	f8c4 a028 	str.w	sl, [r4, #40]	; 0x28
 800689c:	f2ce 0500 	movt	r5, #57344	; 0xe000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80068a0:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80068a4:	61a2      	str	r2, [r4, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80068a6:	6362      	str	r2, [r4, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80068a8:	60e2      	str	r2, [r4, #12]
  STM32_ST_TIM->CR2    = 0;
 80068aa:	6062      	str	r2, [r4, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80068ac:	6167      	str	r7, [r4, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80068ae:	6027      	str	r7, [r4, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80068b0:	f88e c31c 	strb.w	ip, [lr, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80068b4:	f8ce 8180 	str.w	r8, [lr, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80068b8:	f8ce 8000 	str.w	r8, [lr]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80068bc:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80068be:	f8c3 c034 	str.w	ip, [r3, #52]	; 0x34
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80068c2:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 80068c6:	f8c3 c068 	str.w	ip, [r3, #104]	; 0x68
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 80068ca:	661a      	str	r2, [r3, #96]	; 0x60
  H_NEXT(&default_heap.header) = NULL;
 80068cc:	608a      	str	r2, [r1, #8]
  H_PAGES(&default_heap.header) = 0;
 80068ce:	60ca      	str	r2, [r1, #12]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80068d0:	f883 704e 	strb.w	r7, [r3, #78]	; 0x4e
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 80068d4:	f883 704c 	strb.w	r7, [r3, #76]	; 0x4c
 80068d8:	68ef      	ldr	r7, [r5, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80068da:	f64f 0aff 	movw	sl, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
 80068de:	f44f 7440 	mov.w	r4, #768	; 0x300
  tp->name      = name;
 80068e2:	f248 69b4 	movw	r9, #34484	; 0x86b4
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80068e6:	f240 3861 	movw	r8, #865	; 0x361
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80068ea:	ea07 0a0a 	and.w	sl, r7, sl
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 80068ee:	f103 0b54 	add.w	fp, r3, #84	; 0x54
 80068f2:	f6c0 0900 	movt	r9, #2048	; 0x800
 80068f6:	f6c0 0800 	movt	r8, #2048	; 0x800
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 80068fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  reg_value  =  (reg_value                                   |
 80068fe:	f2c0 54fa 	movt	r4, #1530	; 0x5fa
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8006902:	f241 070c 	movw	r7, #4108	; 0x100c
 8006906:	f241 4ca8 	movw	ip, #5288	; 0x14a8
  ch_memcore.endmem  = __heap_end__;
 800690a:	f242 0e00 	movw	lr, #8192	; 0x2000
 800690e:	ea4a 0404 	orr.w	r4, sl, r4
 8006912:	8498      	strh	r0, [r3, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006914:	f103 0a1c 	add.w	sl, r3, #28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006918:	1988      	adds	r0, r1, r6
 800691a:	f8c3 9044 	str.w	r9, [r3, #68]	; 0x44
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800691e:	f8c3 b054 	str.w	fp, [r3, #84]	; 0x54
  REG_INSERT(tp);
 8006922:	f103 092c 	add.w	r9, r3, #44	; 0x2c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006926:	f103 0b58 	add.w	fp, r3, #88	; 0x58
 800692a:	f8c1 8000 	str.w	r8, [r1]
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 800692e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8006932:	f2c2 0c00 	movt	ip, #8192	; 0x2000
  ch_memcore.endmem  = __heap_end__;
 8006936:	f2c2 0e00 	movt	lr, #8192	; 0x2000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800693a:	f64e 58f0 	movw	r8, #60912	; 0xedf0
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800693e:	84da      	strh	r2, [r3, #38]	; 0x26
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8006940:	665a      	str	r2, [r3, #100]	; 0x64
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8006942:	649a      	str	r2, [r3, #72]	; 0x48
 8006944:	618a      	str	r2, [r1, #24]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006946:	f8c3 a01c 	str.w	sl, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800694a:	f8c3 a020 	str.w	sl, [r3, #32]
 800694e:	6108      	str	r0, [r1, #16]
  tqp->prev = (thread_t *)tqp;
 8006950:	6148      	str	r0, [r1, #20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8006952:	f8c3 9010 	str.w	r9, [r3, #16]
 8006956:	f8c3 9014 	str.w	r9, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800695a:	f8c3 9018 	str.w	r9, [r3, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800695e:	f8c3 b058 	str.w	fp, [r3, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 8006962:	f8c3 b05c 	str.w	fp, [r3, #92]	; 0x5c
 8006966:	f2ce 0800 	movt	r8, #57344	; 0xe000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800696a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800696c:	605b      	str	r3, [r3, #4]
 800696e:	63db      	str	r3, [r3, #60]	; 0x3c
 8006970:	641b      	str	r3, [r3, #64]	; 0x40
 8006972:	e887 5000 	stmia.w	r7, {ip, lr}
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8006976:	60ec      	str	r4, [r5, #12]
 8006978:	f8d8 100c 	ldr.w	r1, [r8, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800697c:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006980:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8006984:	f8c8 100c 	str.w	r1, [r8, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006988:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800698c:	6818      	ldr	r0, [r3, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800698e:	2120      	movs	r1, #32
 8006990:	f040 0001 	orr.w	r0, r0, #1
 8006994:	6018      	str	r0, [r3, #0]
 8006996:	77ee      	strb	r6, [r5, #31]
 8006998:	f885 1022 	strb.w	r1, [r5, #34]	; 0x22
 800699c:	f382 8811 	msr	BASEPRI, r2
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80069a0:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80069a2:	2320      	movs	r3, #32
 80069a4:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 80069a8:	f647 3064 	movw	r0, #31588	; 0x7b64
 80069ac:	f6c0 0000 	movt	r0, #2048	; 0x800
 80069b0:	f7fa f8ce 	bl	8000b50 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 80069b4:	2100      	movs	r1, #0
 80069b6:	f7fa f9b3 	bl	8000d20 <chSchWakeupS>
 80069ba:	2300      	movs	r3, #0
 80069bc:	f383 8811 	msr	BASEPRI, r3
 80069c0:	2320      	movs	r3, #32
 80069c2:	f383 8811 	msr	BASEPRI, r3
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80069c6:	f241 0120 	movw	r1, #4128	; 0x1020
 80069ca:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80069ce:	7a0b      	ldrb	r3, [r1, #8]
 80069d0:	9106      	str	r1, [sp, #24]
 80069d2:	2b01      	cmp	r3, #1
 80069d4:	d112      	bne.n	80069fc <main+0x30c>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 80069d6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80069da:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80069de:	6994      	ldr	r4, [r2, #24]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80069e0:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80069e4:	f2ce 0300 	movt	r3, #57344	; 0xe000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80069e8:	2120      	movs	r1, #32
 80069ea:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80069ee:	20c0      	movs	r0, #192	; 0xc0
 80069f0:	6194      	str	r4, [r2, #24]
 80069f2:	f883 0325 	strb.w	r0, [r3, #805]	; 0x325
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80069f6:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80069fa:	6059      	str	r1, [r3, #4]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 80069fc:	9806      	ldr	r0, [sp, #24]
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 80069fe:	f240 2271 	movw	r2, #625	; 0x271
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8006a02:	6f43      	ldr	r3, [r0, #116]	; 0x74
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8006a04:	2101      	movs	r1, #1
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8006a06:	609a      	str	r2, [r3, #8]
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8006a08:	2040      	movs	r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8006a0a:	f242 142c 	movw	r4, #8492	; 0x212c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8006a0e:	2200      	movs	r2, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8006a10:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8006a12:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8006a14:	60dc      	str	r4, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8006a16:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8006a18:	681c      	ldr	r4, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8006a1a:	685b      	ldr	r3, [r3, #4]
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
    sdp->rxmask = 0x7F;
  }
  else {
    sdp->rxmask = 0xFF;
 8006a1c:	9b06      	ldr	r3, [sp, #24]
 8006a1e:	20ff      	movs	r0, #255	; 0xff

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8006a20:	2102      	movs	r1, #2
 8006a22:	f883 0078 	strb.w	r0, [r3, #120]	; 0x78
 8006a26:	7219      	strb	r1, [r3, #8]
 8006a28:	f382 8811 	msr	BASEPRI, r2
  sdStart(&SD1, NULL);

  /*
   * Creates the example threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8006a2c:	f241 1078 	movw	r0, #4472	; 0x1178
 8006a30:	f641 4291 	movw	r2, #7313	; 0x1c91
 8006a34:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006a38:	2181      	movs	r1, #129	; 0x81
 8006a3a:	2300      	movs	r3, #0
 8006a3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006a40:	f7fe ff66 	bl	8005910 <chThdCreateStatic.constprop.52>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO+1, Thread2, NULL);
 8006a44:	f241 3060 	movw	r0, #4960	; 0x1360
 8006a48:	f641 4251 	movw	r2, #7249	; 0x1c51
 8006a4c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8006a50:	2300      	movs	r3, #0
 8006a52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006a56:	2181      	movs	r1, #129	; 0x81
 8006a58:	f7fe ff5a 	bl	8005910 <chThdCreateStatic.constprop.52>
 8006a5c:	f241 021c 	movw	r2, #4124	; 0x101c
 8006a60:	f640 037c 	movw	r3, #2172	; 0x87c
 8006a64:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a6c:	9207      	str	r2, [sp, #28]
 8006a6e:	9309      	str	r3, [sp, #36]	; 0x24
 8006a70:	f640 72fc 	movw	r2, #4092	; 0xffc
 8006a74:	f241 0318 	movw	r3, #4120	; 0x1018
 8006a78:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006a7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a80:	9202      	str	r2, [sp, #8]
 8006a82:	9304      	str	r3, [sp, #16]
 8006a84:	f241 3230 	movw	r2, #4912	; 0x1330
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 8006a88:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006a8c:	f241 3434 	movw	r4, #4916	; 0x1334
 8006a90:	f241 3558 	movw	r5, #4952	; 0x1358
 8006a94:	f241 0914 	movw	r9, #4116	; 0x1014
 8006a98:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8006a9c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8006aa0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8006aa4:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8006aa8:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8006aac:	9205      	str	r2, [sp, #20]
 8006aae:	9308      	str	r3, [sp, #32]
 8006ab0:	e003      	b.n	8006aba <main+0x3ca>
      test_execute((BaseSequentialStream *)&SD1);
    chThdSleepMilliseconds(500);
 8006ab2:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8006ab6:	f7fe f9db 	bl	8004e70 <chThdSleep>
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 8006aba:	9a08      	ldr	r2, [sp, #32]
 8006abc:	6893      	ldr	r3, [r2, #8]
 8006abe:	07db      	lsls	r3, r3, #31
 8006ac0:	d5f7      	bpl.n	8006ab2 <main+0x3c2>
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 8006ac2:	9b06      	ldr	r3, [sp, #24]
  test_println("");
 8006ac4:	f247 70e0 	movw	r0, #30688	; 0x77e0
 8006ac8:	f6c0 0000 	movt	r0, #2048	; 0x800
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 8006acc:	6023      	str	r3, [r4, #0]
  test_println("");
 8006ace:	f7f9 fdaf 	bl	8000630 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 8006ad2:	f647 4058 	movw	r0, #31832	; 0x7c58
 8006ad6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006ada:	f7f9 fda9 	bl	8000630 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8006ade:	f647 4074 	movw	r0, #31860	; 0x7c74
 8006ae2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006ae6:	f647 4678 	movw	r6, #31864	; 0x7c78
 8006aea:	f7f9 fda1 	bl	8000630 <test_println>
 8006aee:	f6c0 0600 	movt	r6, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006af2:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8006af4:	6820      	ldr	r0, [r4, #0]
 8006af6:	6803      	ldr	r3, [r0, #0]
 8006af8:	689b      	ldr	r3, [r3, #8]
 8006afa:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006afc:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8006b00:	2900      	cmp	r1, #0
 8006b02:	d1f7      	bne.n	8006af4 <main+0x404>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8006b04:	f647 507c 	movw	r0, #32124	; 0x7d7c
 8006b08:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b0c:	f647 5694 	movw	r6, #32148	; 0x7d94
 8006b10:	f7f9 fd8e 	bl	8000630 <test_println>
 8006b14:	f6c0 0600 	movt	r6, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006b18:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8006b1a:	6820      	ldr	r0, [r4, #0]
 8006b1c:	6803      	ldr	r3, [r0, #0]
 8006b1e:	689b      	ldr	r3, [r3, #8]
 8006b20:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006b22:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8006b26:	2900      	cmp	r1, #0
 8006b28:	d1f7      	bne.n	8006b1a <main+0x42a>
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8006b2a:	f647 50a8 	movw	r0, #32168	; 0x7da8
 8006b2e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b32:	f647 56cc 	movw	r6, #32204	; 0x7dcc
 8006b36:	f7f9 fd7b 	bl	8000630 <test_println>
 8006b3a:	f6c0 0600 	movt	r6, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006b3e:	212a      	movs	r1, #42	; 0x2a
    streamPut(test_chp, *msgp++);
 8006b40:	6820      	ldr	r0, [r4, #0]
 8006b42:	6803      	ldr	r3, [r0, #0]
 8006b44:	689b      	ldr	r3, [r3, #8]
 8006b46:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006b48:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8006b4c:	2900      	cmp	r1, #0
 8006b4e:	d1f7      	bne.n	8006b40 <main+0x450>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8006b50:	f647 408c 	movw	r0, #31884	; 0x7c8c
 8006b54:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b58:	9101      	str	r1, [sp, #4]
 8006b5a:	f7f9 fd69 	bl	8000630 <test_println>
/*===========================================================================*/

void test_print_port_info(void) {

#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 8006b5e:	f647 40a4 	movw	r0, #31908	; 0x7ca4
 8006b62:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b66:	f7f9 fd83 	bl	8000670 <test_print>
  test_println(PORT_COMPILER_NAME);
 8006b6a:	f647 40b8 	movw	r0, #31928	; 0x7cb8
 8006b6e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b72:	f7f9 fd5d 	bl	8000630 <test_println>
#endif
  test_print("*** Architecture: ");
 8006b76:	f647 40c4 	movw	r0, #31940	; 0x7cc4
 8006b7a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b7e:	f7f9 fd77 	bl	8000670 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 8006b82:	f647 40d8 	movw	r0, #31960	; 0x7cd8
 8006b86:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b8a:	f7f9 fd51 	bl	8000630 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 8006b8e:	f647 40e0 	movw	r0, #31968	; 0x7ce0
 8006b92:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006b96:	f7f9 fd6b 	bl	8000670 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 8006b9a:	f647 40f4 	movw	r0, #31988	; 0x7cf4
 8006b9e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006ba2:	f7f9 fd45 	bl	8000630 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 8006ba6:	f647 5000 	movw	r0, #32000	; 0x7d00
 8006baa:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006bae:	f7f9 fd5f 	bl	8000670 <test_print>
  test_println(PORT_INFO);
 8006bb2:	f647 5014 	movw	r0, #32020	; 0x7d14
 8006bb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006bba:	f7f9 fd39 	bl	8000630 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8006bbe:	f247 70e0 	movw	r0, #30688	; 0x77e0
 8006bc2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006bc6:	f7f9 fd33 	bl	8000630 <test_println>

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8006bca:	9a09      	ldr	r2, [sp, #36]	; 0x24
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
 8006bcc:	9901      	ldr	r1, [sp, #4]
  i = 0;
  while (test_suite[i]) {
 8006bce:	6813      	ldr	r3, [r2, #0]
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
 8006bd0:	9a07      	ldr	r2, [sp, #28]
 8006bd2:	7011      	strb	r1, [r2, #0]
  i = 0;
  while (test_suite[i]) {
 8006bd4:	2b00      	cmp	r3, #0
 8006bd6:	f000 80c9 	beq.w	8006d6c <main+0x67c>
 8006bda:	4f7b      	ldr	r7, [pc, #492]	; (8006dc8 <main+0x6d8>)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
 8006bdc:	9103      	str	r1, [sp, #12]
 8006bde:	9a03      	ldr	r2, [sp, #12]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006be0:	2600      	movs	r6, #0

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8006be2:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8006be6:	3201      	adds	r2, #1
 8006be8:	9203      	str	r2, [sp, #12]
 8006bea:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8006bee:	2b00      	cmp	r3, #0
 8006bf0:	f000 80b7 	beq.w	8006d62 <main+0x672>
 8006bf4:	f647 5a2c 	movw	sl, #32044	; 0x7d2c
      print_line();
 8006bf8:	f7f9 feda 	bl	80009b0 <print_line.8334>
 8006bfc:	f6c0 0a00 	movt	sl, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c00:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8006c02:	6820      	ldr	r0, [r4, #0]
 8006c04:	f241 3b34 	movw	fp, #4916	; 0x1334
 8006c08:	6803      	ldr	r3, [r0, #0]
 8006c0a:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8006c0e:	689b      	ldr	r3, [r3, #8]
 8006c10:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c12:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8006c16:	2900      	cmp	r1, #0
 8006c18:	d1f3      	bne.n	8006c02 <main+0x512>
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8006c1a:	9803      	ldr	r0, [sp, #12]
 8006c1c:	f7f9 fe00 	bl	8000820 <test_printn>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8006c20:	f8db 0000 	ldr.w	r0, [fp]
 8006c24:	212e      	movs	r1, #46	; 0x2e
 8006c26:	6803      	ldr	r3, [r0, #0]
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8006c28:	3601      	adds	r6, #1
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8006c2a:	689b      	ldr	r3, [r3, #8]
 8006c2c:	4798      	blx	r3
 8006c2e:	f647 5be0 	movw	fp, #32224	; 0x7de0
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8006c32:	4630      	mov	r0, r6
 8006c34:	f7f9 fdf4 	bl	8000820 <test_printn>
 8006c38:	f6c0 0b00 	movt	fp, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c3c:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8006c3e:	6820      	ldr	r0, [r4, #0]
 8006c40:	6803      	ldr	r3, [r0, #0]
 8006c42:	689b      	ldr	r3, [r3, #8]
 8006c44:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c46:	f81b 1f01 	ldrb.w	r1, [fp, #1]!
 8006c4a:	2900      	cmp	r1, #0
 8006c4c:	d1f7      	bne.n	8006c3e <main+0x54e>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
 8006c4e:	f857 3c04 	ldr.w	r3, [r7, #-4]
 8006c52:	f853 3008 	ldr.w	r3, [r3, r8]
 8006c56:	681b      	ldr	r3, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c58:	7819      	ldrb	r1, [r3, #0]
 8006c5a:	469b      	mov	fp, r3
 8006c5c:	b139      	cbz	r1, 8006c6e <main+0x57e>
    streamPut(test_chp, *msgp++);
 8006c5e:	6820      	ldr	r0, [r4, #0]
 8006c60:	6803      	ldr	r3, [r0, #0]
 8006c62:	689b      	ldr	r3, [r3, #8]
 8006c64:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006c66:	f81b 1f01 	ldrb.w	r1, [fp, #1]!
 8006c6a:	2900      	cmp	r1, #0
 8006c6c:	d1f7      	bne.n	8006c5e <main+0x56e>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
      test_println(")");
 8006c6e:	f647 503c 	movw	r0, #32060	; 0x7d3c
 8006c72:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006c76:	f7f9 fcdb 	bl	8000630 <test_println>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 8006c7a:	20c8      	movs	r0, #200	; 0xc8
 8006c7c:	f7fe f8f8 	bl	8004e70 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 8006c80:	f857 3c04 	ldr.w	r3, [r7, #-4]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8006c84:	2200      	movs	r2, #0
      test_print(test_suite[i][j]->name);
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 8006c86:	f853 8008 	ldr.w	r8, [r3, r8]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8006c8a:	9b02      	ldr	r3, [sp, #8]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8006c8c:	f889 2000 	strb.w	r2, [r9]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8006c90:	602b      	str	r3, [r5, #0]

  /* Initialization */
  clear_tokens();
  test_local_fail = false;

  if (tcp->setup != NULL)
 8006c92:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8006c96:	b103      	cbz	r3, 8006c9a <main+0x5aa>
    tcp->setup();
 8006c98:	4798      	blx	r3
  tcp->execute();
 8006c9a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8006c9e:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8006ca0:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8006ca4:	b103      	cbz	r3, 8006ca8 <main+0x5b8>
    tcp->teardown();
 8006ca6:	4798      	blx	r3
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
 8006ca8:	f899 3000 	ldrb.w	r3, [r9]
 8006cac:	2b00      	cmp	r3, #0
 8006cae:	d07c      	beq.n	8006daa <main+0x6ba>
 8006cb0:	f647 5840 	movw	r8, #32064	; 0x7d40
 8006cb4:	f6c0 0800 	movt	r8, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006cb8:	212d      	movs	r1, #45	; 0x2d
    streamPut(test_chp, *msgp++);
 8006cba:	6820      	ldr	r0, [r4, #0]
 8006cbc:	6803      	ldr	r3, [r0, #0]
 8006cbe:	689b      	ldr	r3, [r3, #8]
 8006cc0:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006cc2:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8006cc6:	2900      	cmp	r1, #0
 8006cc8:	d1f7      	bne.n	8006cba <main+0x5ca>
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8006cca:	9b05      	ldr	r3, [sp, #20]
 8006ccc:	f647 58e4 	movw	r8, #32228	; 0x7de4
 8006cd0:	6818      	ldr	r0, [r3, #0]
 8006cd2:	f7f9 fda5 	bl	8000820 <test_printn>
 8006cd6:	f6c0 0800 	movt	r8, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006cda:	2120      	movs	r1, #32
    streamPut(test_chp, *msgp++);
 8006cdc:	6820      	ldr	r0, [r4, #0]
 8006cde:	6803      	ldr	r3, [r0, #0]
 8006ce0:	689b      	ldr	r3, [r3, #8]
 8006ce2:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006ce4:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8006ce8:	2900      	cmp	r1, #0
 8006cea:	d1f7      	bne.n	8006cdc <main+0x5ec>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8006cec:	682b      	ldr	r3, [r5, #0]
 8006cee:	9a02      	ldr	r2, [sp, #8]
 8006cf0:	4293      	cmp	r3, r2
 8006cf2:	bf88      	it	hi
 8006cf4:	f8df 80d4 	ldrhi.w	r8, [pc, #212]	; 8006dcc <main+0x6dc>
 8006cf8:	d90a      	bls.n	8006d10 <main+0x620>
    streamPut(test_chp, *cp++);
 8006cfa:	6820      	ldr	r0, [r4, #0]
 8006cfc:	f818 1c01 	ldrb.w	r1, [r8, #-1]
 8006d00:	6803      	ldr	r3, [r0, #0]
 8006d02:	689b      	ldr	r3, [r3, #8]
 8006d04:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8006d06:	682b      	ldr	r3, [r5, #0]
 8006d08:	4598      	cmp	r8, r3
 8006d0a:	f108 0801 	add.w	r8, r8, #1
 8006d0e:	d3f4      	bcc.n	8006cfa <main+0x60a>
 8006d10:	f647 5858 	movw	r8, #32088	; 0x7d58
 8006d14:	f6c0 0800 	movt	r8, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d18:	215d      	movs	r1, #93	; 0x5d
    streamPut(test_chp, *msgp++);
 8006d1a:	6820      	ldr	r0, [r4, #0]
 8006d1c:	6803      	ldr	r3, [r0, #0]
 8006d1e:	689b      	ldr	r3, [r3, #8]
 8006d20:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d22:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8006d26:	2900      	cmp	r1, #0
 8006d28:	d1f7      	bne.n	8006d1a <main+0x62a>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 8006d2a:	9a04      	ldr	r2, [sp, #16]
 8006d2c:	6813      	ldr	r3, [r2, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d2e:	7819      	ldrb	r1, [r3, #0]
 8006d30:	4698      	mov	r8, r3
 8006d32:	b139      	cbz	r1, 8006d44 <main+0x654>
    streamPut(test_chp, *msgp++);
 8006d34:	6820      	ldr	r0, [r4, #0]
 8006d36:	6803      	ldr	r3, [r0, #0]
 8006d38:	689b      	ldr	r3, [r3, #8]
 8006d3a:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d3c:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8006d40:	2900      	cmp	r1, #0
 8006d42:	d1f7      	bne.n	8006d34 <main+0x644>
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
 8006d44:	f647 505c 	movw	r0, #32092	; 0x7d5c
 8006d48:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006d4c:	f7f9 fc70 	bl	8000630 <test_println>
 8006d50:	f857 3c04 	ldr.w	r3, [r7, #-4]
 8006d54:	ea4f 0886 	mov.w	r8, r6, lsl #2

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8006d58:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8006d5c:	2b00      	cmp	r3, #0
 8006d5e:	f47f af49 	bne.w	8006bf4 <main+0x504>
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8006d62:	f857 3b04 	ldr.w	r3, [r7], #4
 8006d66:	2b00      	cmp	r3, #0
 8006d68:	f47f af39 	bne.w	8006bde <main+0x4ee>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8006d6c:	f7f9 fe20 	bl	80009b0 <print_line.8334>
  test_println("");
 8006d70:	f247 70e0 	movw	r0, #30688	; 0x77e0
 8006d74:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006d78:	f647 56e8 	movw	r6, #32232	; 0x7de8
 8006d7c:	f7f9 fc58 	bl	8000630 <test_println>
 8006d80:	f6c0 0600 	movt	r6, #2048	; 0x800
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d84:	2146      	movs	r1, #70	; 0x46
    streamPut(test_chp, *msgp++);
 8006d86:	6820      	ldr	r0, [r4, #0]
 8006d88:	6803      	ldr	r3, [r0, #0]
 8006d8a:	689b      	ldr	r3, [r3, #8]
 8006d8c:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8006d8e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8006d92:	2900      	cmp	r1, #0
 8006d94:	d1f7      	bne.n	8006d86 <main+0x696>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 8006d96:	9a07      	ldr	r2, [sp, #28]
 8006d98:	7813      	ldrb	r3, [r2, #0]
 8006d9a:	b96b      	cbnz	r3, 8006db8 <main+0x6c8>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8006d9c:	f647 506c 	movw	r0, #32108	; 0x7d6c
 8006da0:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006da4:	f7f9 fc44 	bl	8000630 <test_println>
 8006da8:	e683      	b.n	8006ab2 <main+0x3c2>
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else
        test_println("--- Result: SUCCESS");
 8006daa:	f647 5060 	movw	r0, #32096	; 0x7d60
 8006dae:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006db2:	f7f9 fc3d 	bl	8000630 <test_println>
 8006db6:	e7cb      	b.n	8006d50 <main+0x660>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8006db8:	f647 5074 	movw	r0, #32116	; 0x7d74
 8006dbc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006dc0:	f7f9 fc36 	bl	8000630 <test_println>
 8006dc4:	e675      	b.n	8006ab2 <main+0x3c2>
 8006dc6:	bf00      	nop
 8006dc8:	20000880 	.word	0x20000880
 8006dcc:	20000ffd 	.word	0x20000ffd

08006dd0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8006dd0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006dd4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006dd8:	681a      	ldr	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8006dda:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8006ddc:	f042 0201 	orr.w	r2, r2, #1
 8006de0:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8006de2:	680a      	ldr	r2, [r1, #0]
 8006de4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006de8:	0792      	lsls	r2, r2, #30
 8006dea:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006dee:	d5f8      	bpl.n	8006de2 <__early_init+0x12>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8006df0:	6819      	ldr	r1, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8006df2:	2200      	movs	r2, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8006df4:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8006df8:	6019      	str	r1, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8006dfa:	4619      	mov	r1, r3
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8006dfc:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8006dfe:	684a      	ldr	r2, [r1, #4]
 8006e00:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006e04:	f012 0f0c 	tst.w	r2, #12
 8006e08:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e0c:	d1f7      	bne.n	8006dfe <__early_init+0x2e>
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8006e0e:	681a      	ldr	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8006e10:	4619      	mov	r1, r3
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8006e12:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006e16:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8006e18:	680a      	ldr	r2, [r1, #0]
 8006e1a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006e1e:	0390      	lsls	r0, r2, #14
 8006e20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e24:	d5f8      	bpl.n	8006e18 <__early_init+0x48>
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 8006e26:	685a      	ldr	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8006e28:	4619      	mov	r1, r3
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 8006e2a:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 8006e2e:	605a      	str	r2, [r3, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8006e30:	681a      	ldr	r2, [r3, #0]
 8006e32:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8006e36:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8006e38:	680a      	ldr	r2, [r1, #0]
 8006e3a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006e3e:	0192      	lsls	r2, r2, #6
 8006e40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8006e44:	d5f8      	bpl.n	8006e38 <__early_init+0x68>
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8006e46:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8006e4a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8006e4e:	2110      	movs	r1, #16
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#else
  RCC->CFGR = STM32_MCOSEL |                STM32_PLLMUL | STM32_PLLXTPRE |
 8006e50:	f44f 20a0 	mov.w	r0, #327680	; 0x50000
 8006e54:	6058      	str	r0, [r3, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8006e56:	6011      	str	r1, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8006e58:	6859      	ldr	r1, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8006e5a:	461a      	mov	r2, r3
  FLASH->ACR = STM32_FLASHBITS;

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8006e5c:	f041 0102 	orr.w	r1, r1, #2
 8006e60:	6059      	str	r1, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8006e62:	6853      	ldr	r3, [r2, #4]
 8006e64:	f003 030c 	and.w	r3, r3, #12
 8006e68:	2b08      	cmp	r3, #8
 8006e6a:	d1fa      	bne.n	8006e62 <__early_init+0x92>
 * any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 8006e6c:	4770      	bx	lr
 8006e6e:	bf00      	nop

08006e70 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8006e70:	b538      	push	{r3, r4, r5, lr}
 8006e72:	4602      	mov	r2, r0
 8006e74:	2320      	movs	r3, #32
 8006e76:	f383 8811 	msr	BASEPRI, r3
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8006e7a:	f241 23c0 	movw	r3, #4800	; 0x12c0
 8006e7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006e82:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8006e84:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8006e86:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8006e8a:	42a8      	cmp	r0, r5
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8006e8c:	6262      	str	r2, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8006e8e:	d006      	beq.n	8006e9e <chThdExit+0x2e>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8006e90:	6803      	ldr	r3, [r0, #0]
 8006e92:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8006e94:	f7fa f834 	bl	8000f00 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8006e98:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8006e9a:	42a8      	cmp	r0, r5
 8006e9c:	d1f8      	bne.n	8006e90 <chThdExit+0x20>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8006e9e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8006ea2:	b94b      	cbnz	r3, 8006eb8 <chThdExit+0x48>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8006ea4:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8006ea8:	0799      	lsls	r1, r3, #30
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8006eaa:	bf01      	itttt	eq
 8006eac:	6922      	ldreq	r2, [r4, #16]
 8006eae:	6963      	ldreq	r3, [r4, #20]
 8006eb0:	611a      	streq	r2, [r3, #16]
 8006eb2:	6922      	ldreq	r2, [r4, #16]
 8006eb4:	bf08      	it	eq
 8006eb6:	6153      	streq	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8006eb8:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8006eba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8006ebe:	f7f9 bf87 	b.w	8000dd0 <chSchGoSleepS>
 8006ec2:	bf00      	nop
 8006ec4:	f3af 8000 	nop.w
 8006ec8:	f3af 8000 	nop.w
 8006ecc:	f3af 8000 	nop.w

08006ed0 <bmk_thread3.10690>:
#endif

static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
 8006ed0:	f7ff bfce 	b.w	8006e70 <chThdExit>
 8006ed4:	f3af 8000 	nop.w
 8006ed8:	f3af 8000 	nop.w
 8006edc:	f3af 8000 	nop.w

08006ee0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8006ee0:	f241 22c0 	movw	r2, #4800	; 0x12c0
 8006ee4:	f2c2 0200 	movt	r2, #8192	; 0x2000
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8006ee8:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8006eea:	b470      	push	{r4, r5, r6}

  tqp->next             = tp->queue.next;
 8006eec:	6803      	ldr	r3, [r0, #0]
  thread_t *otp = currp;
 8006eee:	6995      	ldr	r5, [r2, #24]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8006ef0:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006ef2:	2100      	movs	r1, #0
 8006ef4:	68ac      	ldr	r4, [r5, #8]
 8006ef6:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8006ef8:	605a      	str	r2, [r3, #4]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8006efa:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8006efe:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006f00:	f885 1020 	strb.w	r1, [r5, #32]
 8006f04:	e000      	b.n	8006f08 <chSchDoReschedule+0x28>
 8006f06:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8006f08:	689a      	ldr	r2, [r3, #8]
 8006f0a:	42a2      	cmp	r2, r4
 8006f0c:	d8fb      	bhi.n	8006f06 <chSchDoReschedule+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006f0e:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006f10:	4629      	mov	r1, r5
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8006f12:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8006f14:	606a      	str	r2, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8006f16:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 8006f18:	605d      	str	r5, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 8006f1a:	bc70      	pop	{r4, r5, r6}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006f1c:	f7f9 b99a 	b.w	8000254 <_port_switch>

08006f20 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8006f20:	b4f0      	push	{r4, r5, r6, r7}
 8006f22:	4e13      	ldr	r6, [pc, #76]	; (8006f70 <__init_ram_areas+0x50>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8006f24:	2500      	movs	r5, #0
 8006f26:	f106 0770 	add.w	r7, r6, #112	; 0x70
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 8006f2a:	f1a6 0110 	sub.w	r1, r6, #16
 8006f2e:	c91a      	ldmia	r1, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8006f30:	42a3      	cmp	r3, r4
 8006f32:	d20d      	bcs.n	8006f50 <__init_ram_areas+0x30>
 8006f34:	3904      	subs	r1, #4
 8006f36:	461a      	mov	r2, r3
      *p = *tp;
 8006f38:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8006f3c:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8006f40:	42a2      	cmp	r2, r4
 8006f42:	d3f9      	bcc.n	8006f38 <__init_ram_areas+0x18>
 8006f44:	43da      	mvns	r2, r3
 8006f46:	4414      	add	r4, r2
 8006f48:	f024 0403 	bic.w	r4, r4, #3
 8006f4c:	3404      	adds	r4, #4
 8006f4e:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8006f50:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8006f54:	4293      	cmp	r3, r2
 8006f56:	d203      	bcs.n	8006f60 <__init_ram_areas+0x40>
      *p = 0;
 8006f58:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8006f5c:	4293      	cmp	r3, r2
 8006f5e:	d3fb      	bcc.n	8006f58 <__init_ram_areas+0x38>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8006f60:	42be      	cmp	r6, r7
 8006f62:	f106 0310 	add.w	r3, r6, #16
 8006f66:	d201      	bcs.n	8006f6c <__init_ram_areas+0x4c>
 8006f68:	461e      	mov	r6, r3
 8006f6a:	e7de      	b.n	8006f2a <__init_ram_areas+0xa>
#endif
}
 8006f6c:	bcf0      	pop	{r4, r5, r6, r7}
 8006f6e:	4770      	bx	lr
 8006f70:	0800881c 	.word	0x0800881c
 8006f74:	f3af 8000 	nop.w
 8006f78:	f3af 8000 	nop.w
 8006f7c:	f3af 8000 	nop.w

08006f80 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8006f80:	e7fe      	b.n	8006f80 <__default_exit>
 8006f82:	bf00      	nop
 8006f84:	f3af 8000 	nop.w
 8006f88:	f3af 8000 	nop.w
 8006f8c:	f3af 8000 	nop.w
